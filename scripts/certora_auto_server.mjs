import { chromium } from 'playwright';
import express from 'express';
import cors from 'cors';
import fetch from 'node-fetch';

const app = express();
app.use(cors());
app.use(express.json({ limit: '100mb' }));  // 增加请求体大小限制到 100MB
app.use(express.urlencoded({ limit: '100mb', extended: true })); // 同样增加表单数据限制

// 处理 Codex 输出，只保留最终回答
function extractCodexAnswer(fullOutput) {
    // 从最后一个 tokens used: 回溯，找到最近一个非空候选块
    const lines = fullOutput.split('\n');
    const tokenIdxs = [];
    for (let i = 0; i < lines.length; i++) {
        if (/tokens used:/i.test(lines[i])) tokenIdxs.push(i);
    }

    const isMetaLine = (l) => (
        /^\[[\d\-T:\.Z]+\]/.test(l) ||
        /\] (exec|bash -lc|codex|thinking)\b/i.test(l) ||
        /workdir:|model:|provider:|approval:|sandbox:|reasoning/i.test(l) ||
        /OpenAI Codex/i.test(l)
    );

    for (let k = tokenIdxs.length - 1; k >= 0; k--) {
        const t = tokenIdxs[k];
        // 找到 t 之前最近的时间戳行
        let s = -1;
        for (let i = t - 1; i >= 0; i--) {
            if (/^\[[\d\-T:\.Z]+\]/.test(lines[i])) { s = i; break; }
        }
        const slice = lines.slice(s + 1, t);
        const filtered = slice.filter(l => !isMetaLine(l)).join('\n').trim();
        if (filtered) return filtered;
    }

    // 尝试从 "Final answer:" 标记提取
    const finalIdx = lines.findIndex(l => /^(Final answer|最终答案)\s*:/i.test(l));
    if (finalIdx !== -1) {
        return lines.slice(finalIdx + 1).join('\n').trim();
    }

    // 回退：从最后一个 "User instructions:" 之后开始，过滤明显的系统行
    let userInstrIdx = -1;
    for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].includes('User instructions:')) { userInstrIdx = i; break; }
    }
    let candidate = (userInstrIdx >= 0 ? lines.slice(userInstrIdx + 1) : lines)
        .filter(l => !isMetaLine(l) && !/tokens used:/i.test(l))
        .join('\n').trim();
    return candidate || fullOutput;
}

// 过滤 Codex 输出，移除prompt回显和系统信息
function filterCodexOutput(output) {
    const lines = output.split('\n');
    const filteredLines = [];
    let inSystemInfo = true;
    let inPromptSection = false;

    for (const line of lines) {
        // 系统信息阶段 - 保留到 "User instructions:" 之前的所有内容
        if (inSystemInfo) {
            if (line.includes('User instructions:')) {
                inSystemInfo = false;
                inPromptSection = true;
                continue; // 跳过 "User instructions:" 这一行
            }
            // 保留系统信息
            filteredLines.push(line);
            continue;
        }

        // 检测prompt结束，开始实际分析
        if (inPromptSection) {
            // 检测prompt结束（通常是开始实际分析的地方）
            if (line.match(/^(根据|基于|分析|这个|我来|让我|首先|## |### |\*\*|# )/)) {
                inPromptSection = false;
                filteredLines.push(line); // 包含这行分析开始的内容
            }
            // 在prompt阶段，跳过所有内容
            continue;
        }

        // 跳过其他系统信息行（如tokens used等）
        if (line.includes('[') && line.includes(']') &&
            (line.includes('codex') || line.includes('tokens used'))) {
            continue;
        }

        // 保留实际的分析内容
        filteredLines.push(line);
    }

    return filteredLines.join('\n');
}

function parseRunInfo(urlStr) {
    const u = new URL(urlStr);
    const parts = u.pathname.split('/').filter(Boolean);
    let runId, outputId;
    for (let i = 0; i < parts.length; i++) {
        if (parts[i] === 'output' && parts[i - 1] !== 'outputs') {
            runId = parts[i + 1];
            outputId = parts[i + 2];
            break;
        }
    }
    const anonymousKey = u.searchParams.get('anonymousKey') || '';
    return { origin: `${u.protocol}//${u.host}`, runId, outputId, anonymousKey };
}

function parseMaybeJson(val) {
    if (typeof val === 'string') {
        try { return JSON.parse(val); } catch { return val; }
    }
    return val;
}

function getProgressRoots(progressJson) {
    const roots = [];
    if (!progressJson) return roots;
    const pj = parseMaybeJson(progressJson);
    if (pj && pj.verificationProgress != null) {
        const vp = parseMaybeJson(pj.verificationProgress);
        if (vp) {
            if (vp.rules) return Array.isArray(vp.rules) ? vp.rules : [vp.rules];
            if (Array.isArray(vp)) return vp;
            if (vp.children) return Array.isArray(vp.children) ? vp.children : [vp.children];
        }
    }
    if (pj && pj.rules) return Array.isArray(pj.rules) ? pj.rules : [pj.rules];
    if (Array.isArray(pj)) return pj;
    if (pj && pj.children) return Array.isArray(pj.children) ? pj.children : [pj.children];
    return roots;
}

function collectFailedRuleOutputs(node, runInfo, results = [], currentPath = []) {
    if (!node) return results;

    const name = node.name || '';
    const status = (node.status || '').toUpperCase();
    const output = Array.isArray(node.output) ? node.output : [];
    const children = Array.isArray(node.children) ? node.children : [];
    const nextPath = currentPath.concat(name);

    if (status && status !== 'VERIFIED' && output.length > 0) {
        for (const outputFile of output) {
            if (typeof outputFile === 'string' && /^rule_output_\d+\.json$/.test(outputFile)) {
                const baseUrl = `${runInfo.origin}/result/${runInfo.runId}/${runInfo.outputId}`;
                const params = new URLSearchParams();
                if (runInfo.anonymousKey) {
                    params.append('anonymousKey', runInfo.anonymousKey);
                }
                params.append('output', outputFile);
                const fullUrl = `${baseUrl}?${params.toString()}`;

                results.push({
                    ruleName: nextPath.join(' > '),
                    status: status,
                    outputFile: outputFile,
                    url: fullUrl
                });
            }
        }
    }

    for (const child of children) {
        collectFailedRuleOutputs(child, runInfo, results, nextPath);
    }

    return results;
}

// 主要端点：分析URL并返回所有JSON内容（支持实时进度）
app.post('/analyze-and-fetch-stream', async (req, res) => {
    const { url } = req.body;

    if (!url) {
        return res.status(400).json({ error: '请提供URL' });
    }

    // 设置SSE响应头
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });

    const sendProgress = (message, type = 'info') => {
        res.write(`data: ${JSON.stringify({ type, message })}\n\n`);
    };

    try {
        sendProgress(`分析URL: ${url}`);
        console.log('分析URL:', url);
        const runInfo = parseRunInfo(url);

        const browser = await chromium.launch({ headless: true });
        const context = await browser.newContext({
            userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36',
        });
        const page = await context.newPage();

        let progressData = null;

        sendProgress('访问页面...');

        page.on('response', async (response) => {
            try {
                const resUrl = response.url();
                const status = response.status();

                if (resUrl.includes('progress') && status === 200) {
                    const text = await response.text();
                    if (text && text.trim() !== '') {
                        try {
                            progressData = JSON.parse(text);
                            sendProgress('找到progress数据');
                        } catch (parseError) {
                            console.log('Progress响应解析失败:', parseError.message);
                        }
                    }
                }
            } catch (responseError) {
                console.log('响应处理错误:', responseError.message);
            }
        });

        await page.goto(url, { waitUntil: 'networkidle' });
        await page.waitForTimeout(3000);

        if (!progressData) {
            sendProgress('未找到progress数据', 'error');
            res.write(`data: ${JSON.stringify({ type: 'error', message: '未找到progress数据' })}\n\n`);
            res.end();
            await browser.close();
            return;
        }

        const failedRules = collectFailedRuleOutputs(progressData, runInfo, [], '');
        sendProgress(`找到 ${failedRules.length} 个非verified规则，正在获取JSON内容...`);

        const results = [];
        for (const rule of failedRules) {
            try {
                sendProgress(`获取 ${rule.outputFile}...`);
                const jsonResponse = await page.goto(rule.jsonUrl, { waitUntil: 'networkidle' });
                const jsonText = await jsonResponse.text();
                const jsonContent = JSON.parse(jsonText);

                results.push({
                    ...rule,
                    content: jsonContent
                });
            } catch (jsonError) {
                console.log(`获取${rule.outputFile}失败:`, jsonError.message);
                results.push({
                    ...rule,
                    content: null,
                    error: jsonError.message
                });
            }
        }

        await browser.close();

        const response = {
            url,
            timestamp: new Date().toISOString(),
            totalRules: failedRules.length,
            rules: results
        };

        sendProgress('分析完成！', 'success');
        res.write(`data: ${JSON.stringify({ type: 'complete', data: response })}\n\n`);
        res.end();

    } catch (error) {
        console.error('处理错误:', error);
        sendProgress(`错误: ${error.message}`, 'error');
        res.write(`data: ${JSON.stringify({ type: 'error', message: error.message })}\n\n`);
        res.end();
    }
});

// 主要端点：分析URL并返回所有JSON内容
app.post('/analyze-and-fetch', async (req, res) => {
    const { url } = req.body;

    if (!url) {
        return res.status(400).json({ error: '请提供URL' });
    }

    console.log('分析URL:', url);
    const runInfo = parseRunInfo(url);

    const browser = await chromium.launch({ headless: true });
    const context = await browser.newContext({
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36',
    });
    const page = await context.newPage();

    let progressData = null;

    page.on('response', async (response) => {
        try {
            const resUrl = response.url();
            const status = response.status();
            if (status < 200 || status >= 300) return;

            const ct = (response.headers()['content-type'] || '').toLowerCase();
            if (ct.includes('application/json') || ct.includes('text/json')) {
                if (resUrl.includes('progress') || resUrl.includes(runInfo.outputId)) {
                    const body = await response.text();
                    try {
                        const json = JSON.parse(body);
                        if (json.verificationProgress || json.rules) {
                            progressData = json;
                            console.log('找到progress数据');
                        }
                    } catch { }
                }
            }
        } catch { }
    });

    try {
        console.log('访问页面...');
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });
        await page.waitForLoadState('networkidle', { timeout: 30000 }).catch(() => { });
        await browser.close();

        if (!progressData) {
            return res.status(404).json({ error: '未找到验证数据' });
        }

        const roots = getProgressRoots(progressData);
        const failedRules = [];

        for (const root of roots) {
            collectFailedRuleOutputs(root, runInfo, failedRules);
        }

        // 去重
        const uniqueRules = new Map();
        for (const rule of failedRules) {
            if (!uniqueRules.has(rule.outputFile)) {
                uniqueRules.set(rule.outputFile, rule);
            }
        }

        const sortedRules = Array.from(uniqueRules.values()).sort((a, b) => {
            const numA = parseInt(a.outputFile.match(/\d+/)?.[0] || '0');
            const numB = parseInt(b.outputFile.match(/\d+/)?.[0] || '0');
            return numA - numB;
        });

        console.log(`找到 ${sortedRules.length} 个非verified规则，正在获取JSON内容...`);

        // 带重试的获取函数：直至成功
        const fetchJsonWithRetry = async (rule, delayMs = 2000) => {
            let attempt = 0;
            // 无限重试直到成功
            // 注意：为防止过快重试，增加固定等待
            while (true) {
                attempt++;
                try {
                    console.log(`获取 ${rule.outputFile} (尝试 ${attempt})...`);
                    const response = await fetch(rule.url);
                    if (!response.ok) {
                        console.warn(`HTTP ${response.status} 获取 ${rule.outputFile} 失败，重试中...`);
                    } else {
                        const jsonContent = await response.json();
                        // 简单校验
                        if (jsonContent && typeof jsonContent === 'object') {
                            return { ...rule, content: jsonContent };
                        }
                        console.warn(`解析 ${rule.outputFile} JSON 失败，重试中...`);
                    }
                } catch (e) {
                    console.warn(`获取 ${rule.outputFile} 出错: ${e.message}，重试中...`);
                }
                // 等待后重试
                await new Promise(r => setTimeout(r, delayMs));
            }
        };

        // 并发获取所有JSON文件的内容（每个都有自身的无限重试）
        const rulesWithContent = await Promise.all(sortedRules.map(rule => fetchJsonWithRetry(rule)));

        // 返回完整结果
        res.json({
            url: url,
            runInfo: runInfo,
            timestamp: new Date().toISOString(),
            totalRules: rulesWithContent.length,
            rules: rulesWithContent
        });

    } catch (error) {
        console.error('分析错误:', error);
        await browser.close();
        res.status(500).json({ error: error.message });
    }
});

// 新增 /analyze-rule-stream 端点用于单个规则的流式 Codex 分析
app.post('/analyze-rule-stream', async (req, res) => {
    const { content, type, projectPath } = req.body;

    if (!content || !type) {
        return res.status(400).json({
            success: false,
            error: '缺少必需参数: content 和 type'
        });
    }

    // 设置SSE响应头
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });

    const sendProgress = (message, type = 'output') => {
        res.write(`data: ${JSON.stringify({ type, message })}\n\n`);
    };

    try {
        const { spawn } = await import('child_process');
        let promptText;

        if (type === 'VIOLATED') {
            promptText = `First, please read the entire workflow guide in the YAML:
workflow guide:            
\`\`\`yaml
# ** STRATEGIES FOR HANDLING UNREACHABLE INITIAL STATE PROBLEMS AND FALSE POSITIVES CAUSED BY HAVOC IN CERTORA FORMAL VERIFICATION **

## ** 1. OVERVIEW **

                IN FORMAL VERIFICATION, THE CERTORA PROVER'S DEFAULT NON-DETERMINISTIC MODELING OF INITIAL STATES AND EXTERNAL INTERACTIONS (THROUGH THE HAVOC MECHANISM) CAN LEAD TO THE EMERGENCE OF SPURIOUS COUNTEREXAMPLES (FALSE POSITIVES). THESE FALSE POSITIVES ARISE BECAUSE THE VERIFICATION TOOL EXPLORES STATES AND BEHAVIORS THAT ARE UNREACHABLE OR IRRELEVANT IN THE ACTUAL SYSTEM. THIS GUIDE WILL DELVE INTO THE PRINCIPLES OF THE HAVOC MECHANISM AND ITS APPLICATION IN THE CERTORA PROVER, ANALYZING HOW IT LEADS TO FALSE POSITIVES ORIGINATING FROM UNREACHABLE INITIAL STATE PROBLEMS. THE GUIDE WILL DETAIL KEY STRATEGIES FOR MITIGATING THESE ISSUES, INCLUDING PRECISELY CONSTRAINING INITIAL STATES, OPTIMIZING EXTERNAL CALL SUMMARIES, AND TARGETEDLY SCOPING THE VERIFICATION. THE GOAL IS TO ENHANCE THE ACCURACY AND EFFICIENCY OF VERIFICATION RESULTS, THEREBY BOOSTING CONFIDENCE IN THE SECURITY OF SMART CONTRACTS.

## ** 2. INTRODUCTION TO NON - DETERMINISM AND THE HAVOC MECHANISM IN CERTORA PROVER **

                THIS SECTION WILL ESTABLISH A FUNDAMENTAL UNDERSTANDING OF NON - DETERMINISM IN THE CERTORA PROVER AND CLARIFY THE CRITICAL ROLE OF THE HAVOC MECHANISM.

### ** 2.1.THE ROLE OF HAVOC IN FORMAL VERIFICATION **

                THE CERTORA PROVER, AS AN ADVANCED FORMAL VERIFICATION TOOL, CAN TRANSFORM SMART CONTRACT BYTECODE AND USER - DEFINED PROPERTIES INTO MATHEMATICAL FORMULAS FOR ANALYSIS BY AN SMT SOLVER.THIS PROCESS ALGORITHMICALLY EXPLORES THE SYSTEM'S STATE SPACE TO VERIFY EXPECTED BEHAVIORAL PROPERTIES.
            THE HAVOC KEYWORD IN THE CERTORA VERIFICATION LANGUAGE(CVL) PLAYS A CENTRAL ROLE IN MODELING UNCERTAINTY AND NON - DETERMINISM.IT ALLOWS VARIABLES TO ASSUME ARBITRARY, NON - DETERMINISTIC VALUES, WHICH IS CRUCIAL FOR ACHIEVING COMPREHENSIVE COVERAGE OF THE INPUT SPACE AND CONSIDERING ALL POSSIBLE CALL CONTEXTS.
THIS INHERENT NON - DETERMINISM OF THE HAVOC MECHANISM IS NOT A FLAW IN THE CERTORA PROVER BUT AN INTENTIONAL DESIGN CHOICE TO ENSURE THE * SOUNDNESS * OF THE FORMAL VERIFICATION.BY EXPLORING ALL LOGICALLY POSSIBLE BEHAVIORS, INCLUDING THOSE NOT EXPLICITLY MODELED OR CONSTRAINED, THE PROVER AIMS TO AVOID MISSING GENUINE VULNERABILITIES.THEREFORE, THE CHALLENGE FOR THE USER IS TO * CONSTRAIN * THIS BROAD NON - DETERMINISM TO ONLY * RELEVANT * AND * REACHABLE * BEHAVIORS TO AVOID GENERATING SPURIOUS(FALSE POSITIVE) COUNTEREXAMPLES.
HAVOC IS DESCRIBED AS ASSIGNING ARBITRARY VALUES AND MODELING UNCERTAINTY, WHICH IS KEY TO "COMPLETE COVERAGE".THIS MECHANISM, WHILE POWERFUL, IS A DIRECT CAUSE OF "UNREACHABLE INITIAL STATES" AND "FALSE POSITIVES." THE CERTORA PROVER AIMS TO AUTOMATICALLY LOCATE CRITICAL VULNERABILITIES THAT EVEN THE BEST AUDITORS MIGHT MISS AND "NEVER MAKES A REASONING ERROR".
THE PURPOSE OF HAVOC IS TO CREATE AN * OVER - APPROXIMATION * OF THE SYSTEM'S BEHAVIOR. AN OVER-APPROXIMATION IS *SOUND* BECAUSE IT ENCOMPASSES ALL POSSIBLE REAL BEHAVIORS, GUARANTEEING THAT IF A BUG EXISTS, THE PROVER WILL FIND IT. HOWEVER, THIS OVER-APPROXIMATION MAY ALSO CONTAIN BEHAVIORS THAT ARE *LOGICALLY POSSIBLE BUT PRACTICALLY IMPOSSIBLE* WITHIN THE OPERATIONAL CONTEXT OF THE ACTUAL SYSTEM. WHEN THESE IMPOSSIBLE BEHAVIORS LEAD TO A PROPERTY VIOLATION, THEY MANIFEST AS *SPURIOUS COUNTEREXAMPLES* (FALSE POSITIVES). THIS TRADEOFF IS FUNDAMENTAL: SOUNDNESS (NOT MISSING BUGS) OFTEN COMES WITH THE RISK OF FALSE POSITIVES IF THE MODEL IS NOT PRECISE ENOUGH. THUS, A "FALSE POSITIVE" IS NOT AN ERROR IN THE PROVER'S LOGIC BUT A VALUABLE SIGNAL THAT THE USER'S *SPECIFICATION* OF THE SYSTEM'S ENVIRONMENT OR UNVERIFIED COMPONENTS IS TOO LOOSE.THE SOLUTION IS NOT TO DISABLE HAVOC, BUT TO REFINE ITS SCOPE BY ADDING MORE PRECISE CONSTRAINTS.

### ** 2.2.INITIAL STATE MODELING AND UNSPECIFIED VARIABLES **

                A KEY ASPECT OF CERTORA'S NON-DETERMINISM LIES IN ITS MODELING OF THE INITIAL STATE. AT THE START OF A VERIFICATION, THE STORAGE STATE IS UNSPECIFIED, AND ALL VARIABLES ARE HAVOCED BY DEFAULT. THIS MEANS THE PROVER CONSIDERS ALL POSSIBLE INITIAL VALUES FOR VARIABLES UNLESS EXPLICITLY CONSTRAINED IN THE SPECIFICATION.
THIS DEFAULT HAVOC BEHAVIOR IS A PRIMARY CAUSE OF FALSE POSITIVES.THE PROVER MAY GENERATE COUNTEREXAMPLES FROM STATES THAT ARE LOGICALLY POSSIBLE BUT DEMONSTRABLY IMPOSSIBLE OR IRRELEVANT IN THE CONTEXT OF THE ACTUAL CONTRACT'S DEPLOYMENT OR OPERATION.
THE "UNREACHABLE INITIAL STATE" PROBLEM IS A DIRECT CONSEQUENCE OF THE CERTORA PROVER'S "MAXIMAL NON-DETERMINISM" APPROACH TO INITIAL CONDITIONS. THIS CONSERVATIVE DEFAULT ENSURES SOUNDNESS BY CONSIDERING THE WIDEST POSSIBLE RANGE OF STARTING POINTS, BUT IT PLACES THE ONUS ON THE USER TO EXPLICITLY INTERVENE AND NARROW THE VERIFICATION SCOPE TO THE SYSTEM'S * VALID * INITIAL STATES.THE INITIAL STATE IS UNSPECIFIED, AND VARIABLES ARE HAVOCED BY DEFAULT.IF AN INITIAL STATE LEADS TO A COUNTEREXAMPLE, IT DOES NOT NECESSARILY INDICATE A VULNERABILITY UNLESS IT CAN BE PROVEN THAT THE INITIAL STATE WAS NOT OVER - APPROXIMATED.
HAVOC IS EXPLICITLY DEFINED AS "ASSIGNING ARBITRARY, NON-DETERMINISTIC VALUES TO VARIABLES... AT THE START OF A VERIFICATION, ALL VARIABLES ARE HAVOCED TO SIMULATE AN UNKNOWN INITIAL STATE".THIS IS A "PESSIMISTIC" APPROACH.THE DEFAULT SETTING IS DESIGNED FOR MAXIMUM COVERAGE AND SOUNDNESS, ASSUMING * ANY * POSSIBLE INITIAL STATE TO ENSURE NO GENUINE VULNERABILITIES ARE MISSED DUE TO UNCONSIDERED STARTING POINTS.WHILE SOUND, THIS OFTEN GENERATES COUNTEREXAMPLES FROM STATES THAT ARE * LOGICALLY POSSIBLE * IN A GENERIC MATHEMATICAL MODEL BUT * IMPOSSIBLE * IN THE ACTUAL OPERATION OF THE SPECIFIC CONTRACT OR PROTOCOL BEING VERIFIED.THIS HIGHLIGHTS A CRITICAL GAP: THE DISCREPANCY BETWEEN THE PROVER'S GENERIC MODEL AND THE REAL-WORLD INVARIANTS AND DEPLOYMENT CONDITIONS OF A SPECIFIC SYSTEM. TO MAKE THE VERIFICATION RESULTS MEANINGFUL, THE USER MUST EXPLICITLY ENCODE THEIR ASSUMPTIONS ABOUT *VALID* INITIAL STATES INTO THE SPECIFICATION. THIS IS WHERE SPECIFIC CVL CONSTRUCTS LIKE REQUIRE INVARIANT AND HAVOC ASSUMING BECOME INDISPENSABLE FOR PRUNING THE SEARCH SPACE AND ELIMINATING SPURIOUS COUNTEREXAMPLES.

                ** SUMMARY DECLARATIONS ** ARE USED TO REPLACE CALLS TO CERTAIN CONTRACT METHODS, ESPECIALLY WHEN THE PRECISE CODE OF AN EXTERNAL CONTRACT IS UNAVAILABLE, OR TO SIMPLIFY COMPLEX CODE TO PREVENT TIMEOUTS.

*   ** HAVOC_ALL **: THIS IS THE MOST CONSERVATIVE SUMMARY TYPE.WHEN APPLIED, THE PROVER ASSUMES THE CALLED FUNCTION CAN HAVE ARBITRARY SIDE EFFECTS ON THE STORAGE OF * ANY * CONTRACT(INCLUDING THE CALLING CONTRACT) AND CAN RETURN AN ARBITRARY VALUE.WHILE ALWAYS SOUND, IT IS OFTEN TOO PESSIMISTIC IN PRACTICE AS IT "ERASES ALL THE KNOWLEDGE THE PROVER HAD ABOUT THE STATE OF THE CONTRACT BEFORE THE CALL"¹⁰. THIS MAXIMAL NON - DETERMINISM CAN LEAD TO A LARGE NUMBER OF FALSE POSITIVES.
*   ** HAVOC_ECF **: THIS SUMMARY TYPE PROVIDES A MORE REFINED APPROXIMATION THAN HAVOC_ALL.IT ASSUMES THE CALLED METHOD IS * NON - REENTRANT * AND CAN HAVE ARBITRARY EFFECTS ON CONTRACTS * OTHER THAN * THE ONE BEING VERIFIED.IMPORTANTLY, IT ASSUMES THE STATE AND ETH BALANCE OF THE CURRENT(CALLING) CONTRACT(APART FROM ANY VALUE TRANSFERRED BY THE METHOD CALL ITSELF) * DO NOT * CHANGE¹⁰. THIS PROVIDES A USEFUL MIDDLE GROUND, REDUCING FALSE POSITIVES COMPARED TO HAVOC_ALL WHILE MAINTAINING A HIGH DEGREE OF NON - DETERMINISM FOR EXTERNAL INTERACTIONS.
*   ** NONDET(VIEW SUMMARY) **: THESE ARE USED FOR VIEW FUNCTIONS, ASSUMING THEY HAVE NO SIDE EFFECTS AND SIMPLY REPLACE THE CALL WITH A NON - DETERMINISTIC VALUE.THEY ARE SOUND FOR VIEW FUNCTIONS¹⁰.
*   ** EXPRESSION SUMMARIES **: THESE REPLACE A CALL TO A SUMMARIZED METHOD WITH A CVL EXPRESSION, TYPICALLY A CALL TO A CVL FUNCTION OR GHOST AXIOM.THEY REQUIRE AN EXPECT CLAUSE TO ACCOUNT FOR THE RETURN VALUE¹⁰. THIS ALLOWS FOR PRECISE, DETERMINISTIC MODELING OF AN EXTERNAL CALL WHEN ITS BEHAVIOR IS WELL UNDERSTOOD.
*   ** AUTO SUMMARIES **: THESE ARE THE DEFAULT SUMMARIES FOR UNRESOLVED CALLS¹⁰.
*   ** DISPATCHER SUMMARIES **: THESE ASSUME THE RECEIVER OF A METHOD CALL CAN BE ANY CONTRACT THAT IMPLEMENTS THE METHOD.THEY CAN SIGNIFICANTLY CONTRIBUTE TO THE "PATH EXPLOSION PROBLEM" DUE TO THE LARGE NUMBER OF POTENTIAL CALL TARGETS, ESPECIALLY IN SEQUENTIAL CONTROL FLOW¹⁰. REPLACING A DISPATCHER SUMMARY WITH AN AUTO SUMMARY CAN SIGNIFICANTLY REDUCE THE PATH COUNT AND PREVENT TIMEOUTS¹¹.

THE CHOICE OF HAVOC SUMMARY TYPE REPRESENTS A CRITICAL TRADEOFF BETWEEN SOUNDNESS, PRECISION, AND VERIFICATION PERFORMANCE.HAVOC_ALL GUARANTEES SOUNDNESS BUT MAY INTRODUCE NUMEROUS FALSE POSITIVES AND EXACERBATE STATE EXPLOSION.MORE PRECISE SUMMARIES LIKE HAVOC_ECF AND NONDET OFFER HIGHER PRECISION BY MAKING STRONGER ASSUMPTIONS(E.G., NON - REENTRANCY, NO SIDE EFFECTS), WHICH CAN SIGNIFICANTLY REDUCE FALSE POSITIVES AND IMPROVE PERFORMANCE.HOWEVER, THESE MORE PRECISE SUMMARIES REQUIRE CAREFUL CONSIDERATION AND VALIDATION TO ENSURE THEIR UNDERLYING ASSUMPTIONS ACCURATELY REFLECT THE BEHAVIOR OF THE EXTERNAL CODE, AS AN UNSOUND ASSUMPTION COULD LEAD TO MISSED VULNERABILITIES.
HAVOC SUMMARY TYPES HAVE DIFFERENT EFFECTS ON STATE AND RETURN VALUES¹⁰.
HAVOC_ALL IS "ALWAYS SOUND" BUT "OVERLY PESSIMISTIC" AND "ERASES ALL KNOWLEDGE"¹⁰. THIS INDICATES MAXIMUM NON - DETERMINISM.
HAVOC_ECF IS A "USEFUL MIDDLE GROUND"¹⁰, IMPLYING REDUCED NON - DETERMINISM.
DISPATCHER CAN LEAD TO "PATH EXPLOSION"¹¹, INDICATING A PERFORMANCE COST.SUMMARIES ARE OFTEN HELPFUL TO "SIMPLIFY THE VERIFIED CODE TO AVOID TIMEOUTS"¹⁰. A PROOF ON AN OVER - APPROXIMATED PROGRAM IS SOUND, BUT SPURIOUS COUNTEREXAMPLES MAY ARISE FROM BEHAVIORS NOT EXHIBITED BY THE ORIGINAL CODE⁷.

*   ** HAVOC_ALL(MOST OVER - APPROXIMATED) **: INTRODUCES THE HIGHEST DEGREE OF NON - DETERMINISM FOR EXTERNAL CALLS.WHILE IT MAXIMIZES SOUNDNESS(BY NOT MISSING ANY POTENTIAL SIDE EFFECTS), THIS BROADNESS MEANS IT WILL FIND COUNTEREXAMPLES IN SCENARIOS THAT ARE IMPRACTICAL OR IMPOSSIBLE, LEADING TO A HIGH RATE OF FALSE POSITIVES.THE LARGER NON - DETERMINISTIC STATE SPACE ALSO NEGATIVELY IMPACTS PERFORMANCE.
*   ** HAVOC_ECF(LESS OVER - APPROXIMATED) **: REDUCES NON - DETERMINISM BY ASSUMING NON - REENTRANCY AND LIMITED IMPACT ON THE CALLING CONTRACT'S STATE. THIS *CONSTRAINS* THE POSSIBLE SIDE EFFECTS, THEREBY REDUCING FALSE POSITIVES AND IMPROVING PERFORMANCE. HOWEVER, THIS INTRODUCES AN *ASSUMPTION* ABOUT THE EXTERNAL CODE'S BEHAVIOR(NON - REENTRANT, LIMITED SELF - MODIFICATION) THAT * MUST BE VALID *.IF THIS ASSUMPTION IS VIOLATED IN THE ACTUAL SYSTEM, THE PROOF BECOMES * UNSOUND *.
*   ** NONDET(EVEN LESS OVER - APPROXIMATION FOR VIEW FUNCTIONS) **: ASSUMES NO SIDE EFFECTS AT ALL.THIS FURTHER REDUCES NON - DETERMINISM, LEADING TO FEWER FALSE POSITIVES AND BETTER PERFORMANCE, BUT RELIES ON A STRONGER ASSUMPTION ABOUT THE EXTERNAL FUNCTION'S PURITY.
                *   ** DISPATCHER(COMPLEX, HIGH PATH COUNT) **: WHILE USEFUL FOR MODELING DYNAMIC DISPATCH, ITS INHERENT COMPLEXITY AND THE NEED TO EXPLORE MULTIPLE POTENTIAL CALL TARGETS CAN LEAD TO STATE EXPLOSION AND TIMEOUTS.THESE PERFORMANCE ISSUES CAN INDIRECTLY CONTRIBUTE TO "FALSE POSITIVES" IF THE PROVER FAILS TO COMPLETE VERIFICATION OR SIMPLY HINDER EFFECTIVE VERIFICATION.

                    THEREFORE, SELECTING THE APPROPRIATE SUMMARY IS A CRITICAL DESIGN DECISION IN CVL.IT REQUIRES A DEEP UNDERSTANDING OF THE EXTERNAL SYSTEM'S BEHAVIOR AND A CAREFUL EVALUATION OF THE TRADEOFF BETWEEN DESIRED PRECISION (TO REDUCE FALSE POSITIVES) AND THE RISK OF INTRODUCING UNSOUND ASSUMPTIONS. OVER-SUMMARIZING (E.G., USING HAVOC_ALL WHEN HAVOC_ECF IS SUFFICIENT) LEADS TO UNNECESSARY FALSE POSITIVES, WHILE UNDER-SUMMARIZING (E.G., NOT SUMMARIZING COMPLEX EXTERNAL CALLS) LEADS TO PERFORMANCE BOTTLENECKS.
                        ** TABLE 1: COMPARISON OF CERTORA HAVOC SUMMARY TYPES **

| SUMMARY TYPE | DESCRIPTION | KEY ASSUMPTIONS | EFFECT ON CALLING CONTRACT STATE | EFFECT ON OTHER CONTRACT STATES | EFFECT ON ETH BALANCE | RETURN VALUE HANDLING | SOUNDNESS IMPACT | TYPICAL USE CASE | FALSE POSITIVE / PERFORMANCE POTENTIAL |
| : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- |
| HAVOC_ALL | MOST CONSERVATIVE SUMMARY, ALLOWS ARBITRARY SIDE EFFECTS. | NO SPECIFIC ASSUMPTIONS. | ARBITRARILY CHANGED. | ARBITRARILY CHANGED. | ARBITRARILY CHANGED. | ARBITRARY VALUE. | ALWAYS SOUND. | EXTERNAL CODE IS UNKNOWN OR HIGHLY COMPLEX. | HIGH FALSE POSITIVES, POOR PERFORMANCE. |
| HAVOC_ECF | ASSUMES NON - REENTRANCY, LIMITS IMPACT ON THE CALLING CONTRACT. | NON - REENTRANT. | UNCHANGED(EXCEPT FOR EXPLICIT TRANSFERS). | ARBITRARILY CHANGED. | NOT DECREASED(EXCEPT FOR EXPLICIT TRANSFERS). | ARBITRARY VALUE. | SOUND(IF ASSUMPTION HOLDS). | EXTERNAL CODE IS KNOWN TO BE NON - REENTRANT. | MEDIUM FALSE POSITIVES, MEDIUM PERFORMANCE. |
| NONDET | USED FOR VIEW FUNCTIONS, ASSUMES NO SIDE EFFECTS. | NO SIDE EFFECTS. | NO CHANGE. | NO CHANGE. | NO CHANGE. | NON - DETERMINISTIC VALUE. | SOUND(IF VIEW FUNCTION IS PURE). | EXTERNAL VIEW FUNCTIONS. | LOW FALSE POSITIVES, GOOD PERFORMANCE. |
| AUTO | DEFAULT SUMMARY FOR UNRESOLVED CALLS. | PROVER INFERS AUTOMATICALLY. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON ACCURACY OF INFERENCE. | DEFAULT BEHAVIOR, OR AS DISPATCHER ALTERNATIVE. | VARIABLE FALSE POSITIVES / PERFORMANCE. |
| DISPATCHER | RECEIVER CAN BE ANY CONTRACT IMPLEMENTING THE METHOD. | DYNAMIC DISPATCH. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | SOUND(IF ALL TARGETS ARE EXPLORED). | INTERFACE CALLS, POLYMORPHISM. | HIGH PATH COUNT, PRONE TO TIMEOUTS. |
| EXPRESSION SUMMARY | REPLACES CALL WITH CVL EXPRESSION(FUNCTION / GHOST AXIOM). | EXTERNAL BEHAVIOR CAN BE PRECISELY MODELED. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | SOUND(IF EXPRESSION IS ACCURATE). | EXTERNAL BEHAVIOR IS KNOWN AND DETERMINISTIC. | LOW FALSE POSITIVES, GOOD PERFORMANCE. |

### ** 2.3.WHAT CONSTITUTES AN UNREACHABLE STATE IN FORMAL VERIFICATION **

                IN THE CONTEXT OF FORMAL VERIFICATION, AN UNREACHABLE STATE REFERS TO A SYSTEM CONFIGURATION THAT, WHILE MATHEMATICALLY POSSIBLE GIVEN THE DATA TYPES AND VARIABLE RANGES, CANNOT BE REACHED THROUGH ANY VALID SEQUENCE OF OPERATIONS OR INPUTS STARTING FROM A LEGITIMATE, PRACTICAL INITIAL STATE.THESE STATES ARE "NEITHER VALID NOR INVALID, BUT ONE THE DESIGN CAN NEVER REACH".

IT IS CRUCIAL TO DISTINGUISH UNREACHABLE STATES FROM "INVALID STATES." AN INVALID STATE REPRESENTS AN ERRONEOUS OR UNDESIRABLE CONFIGURATION THAT THE SYSTEM SHOULD NEVER ENTER.THE CORE PROBLEM DISCUSSED IN THIS REPORT ARISES WHEN A FORMAL VERIFIER, DUE TO ITS COMPREHENSIVE EXPLORATION, TREATS THESE PRACTICALLY UNREACHABLE STATES AS VALID STARTING POINTS FOR VERIFICATION, THEREBY LEADING TO SPURIOUS FINDINGS.

IN SMART CONTRACTS, THE FOLLOWING ARE TYPICAL EXAMPLES OF UNREACHABLE STATES:

ASSUME A TOKEN CONTRACT WHERE totalSupply IS ALWAYS EQUAL TO THE SUM OF ALL INDIVIDUAL USER BALANCES.AN INITIAL STATE WHERE, FOR EXAMPLE, totalSupply IS A NEGATIVE NUMBER OR IS LESS THAN THE PRE - MINTED USER BALANCES(IF THE CONSTRUCTOR ENFORCES CORRECTNESS) IS MATHEMATICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE.

IN AN ERC20 IMPLEMENTATION,  unchecked  ARITHMETIC MIGHT BE USED FOR INTERNAL BALANCE UPDATES, RELYING ON HIGHER - LEVEL LOGIC(LIKE totalSupply  LIMITS) TO PREVENT OVERFLOWS.HOWEVER, IF HAVOC  INTRODUCES AN ARBITRARILY LARGE BALANCE FOR A USER, AN OVERFLOW MIGHT OCCUR IN THESE unchecked OPERATIONS, EVEN THOUGH SUCH A LARGE BALANCE IS IMPOSSIBLE IN THE ACTUAL USE OF THE CONTRACT.

A VARIABLE IS GUARANTEED BY THE CONTRACT'S CONSTRUCTOR OR DEPLOYMENT SCRIPT TO BE INITIALIZED TO A SPECIFIC VALUE BUT IS HAVOCED BY THE PROVER TO AN ARBITRARY, UNINITIALIZED VALUE.

A SIGNIFICANT CHALLENGE IS EXPLICITLY STATED: "THE CHALLENGE FOR THE DESIGNER IN THE INDUCTIVE STEP IS THAT YOU HAVE TO DECLARE EVERY UNREACHABLE STATE AS INVALID, OR IT MIGHT START PROCESSING FROM AN UNREACHABLE STATE YOU DIDN'T ANTICIPATE." IT REITERATES THIS POINT: "ANY STATE THAT IS NOT DECLARED AS INVALID CAN BE A STARTING POINT FOR THE INDUCTION—EVEN IF THAT STATE IS UNREACHABLE." THIS REVEALS THE "DESIGNER'S BURDEN" SPECIFIC TO FORMAL VERIFICATION.UNLIKE TRADITIONAL TESTING, WHICH IMPLICITLY FOCUSES ON REACHABLE STATES, FORMAL VERIFICATION BY DEFAULT EXPLORES THE ENTIRE MATHEMATICALLY DEFINED STATE SPACE.IF THE SPECIFICATION DOES NOT EXPLICITLY AND EXHAUSTIVELY CONSTRAIN THE INITIAL STATE OR DECLARE CERTAIN STATES INVALID, THE PROVER WILL CONSIDER THEM.THIS SHIFTS THE TASK FROM MERELY "FINDING BUGS IN REACHABLE STATES" TO THE MORE CHALLENGING "PRECISELY DEFINING THE SET OF ALL REACHABLE AND VALID STATES." THIS CONCEPTUAL SHIFT IS OFTEN A SIGNIFICANT HURDLE FOR DEVELOPERS ACCUSTOMED TO EMPIRICAL TESTING METHODOLOGIES.

### ** 2.4.CERTORA'S OVER-APPROXIMATION PRINCIPLE: WHY UNREACHABLE STATES ARE CONSIDERED**

THE DESIGN OF THE CERTORA PROVER INHERENTLY ADOPTS THE PRINCIPLE OF "OVER-APPROXIMATION." IT "ASSUMES ALL POSSIBLE INPUT VALUES AS A STARTING STATE, EVEN THOSE THAT CAN NEVER BE REACHED".THIS STRATEGY IS A DELIBERATE CHOICE TO ENSURE SOUNDNESS—GUARANTEEING THAT THE PROVER "WILL NOT ALLOW AN UNTRUE RULE TO PASS VERIFICATION" AND "GUARANTEES TO REPORT ANY VIOLATION OF THE RULE".THIS APPROACH PRIORITIZES AVOIDING "FALSE NEGATIVES"(MISSING ACTUAL BUGS) OVER THE STRICT PRECISION OF ALL REPORTED COUNTEREXAMPLES.

                CERTORA'S CORE MECHANISM INVOLVES TRANSLATING THE CONTRACT CODE AND CVL RULES INTO LOGICAL FORMULAS, WHICH ARE THEN FED TO AN SMT SOLVER. THESE SOLVERS ARE DESIGNED TO EXPLORE AN "INFINITE SPACE OF POSSIBLE EXECUTIONS" TO FIND ANY SCENARIO THAT VIOLATES THE SPECIFIED PROPERTIES. WITHOUT EXPLICIT CONSTRAINTS FROM THE USER, THE SMT SOLVER WILL OPERATE BASED ON THE BROADEST MATHEMATICAL INTERPRETATION OF THE VARIABLES, WHICH NATURALLY INCLUDES STATES THAT ARE THEORETICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE IN THE ACTUAL SYSTEM.

COMPARED TO FUZZING / TRADITIONAL TESTING, WHICH STARTS FROM CONCRETE PROGRAM STATES AND MAY STRUGGLE TO FIND THE COMPLEX, CORRELATED PARAMETER VALUES NEEDED TO REACH DEEP, PROBLEMATIC STATES, CERTORA'S SYMBOLIC APPROACH EXCELS IN THIS REGARD. HOWEVER, THIS ABILITY TO EXHAUSTIVELY EXPLORE THE STATE SPACE INHERENTLY COMES WITH THE CAVEAT THAT IT MAY EXPLORE AND REPORT ON STATES THAT MAY NOT BE PRACTICALLY REACHABLE IN A DEPLOYED ENVIRONMENT.

CERTORA'S OVER-APPROXIMATION IS A DESIGN CHOICE TO ENSURE SOUNDNESS, MEANING IT PRIORITIZES FINDING ANY POSSIBLE VIOLATION, EVEN IF IT OCCURS IN AN UNREACHABLE STATE. THIS CONTRASTS WITH THE USER'S IMPLICIT EXPECTATION THAT THE TOOL SHOULD ONLY FIND VIOLATIONS IN STATES REACHABLE DURING THE ACTUAL EXECUTION OF THE CONTRACT.THE PROBLEM STATEMENT ITSELF(FALSE POSITIVES FROM UNREACHABLE INITIAL STATES) HIGHLIGHTS THIS TENSION.IT SIGNIFIES A FUNDAMENTAL PHILOSOPHICAL DIFFERENCE BETWEEN THE GOALS OF FORMAL VERIFICATION AND TRADITIONAL TESTING.THE QUESTION THE CERTORA PROVER ANSWERS IN ITS DEFAULT MODE IS: "GIVEN ANY MATHEMATICALLY POSSIBLE INITIAL STATE AND EXECUTION PATH, DOES THIS PROPERTY ALWAYS HOLD?" HOWEVER, THE USER IS TYPICALLY MORE INTERESTED IN: "GIVEN ONLY THE INITIAL STATES AND EXECUTION PATHS THAT ARE ACTUALLY REACHABLE IN MY DEPLOYED SYSTEM, DOES THIS PROPERTY HOLD?" "FALSE POSITIVES" ARISE PRECISELY FROM THIS GAP BETWEEN THEORETICAL POSSIBILITY(EXHAUSTIVELY EXPLORED BY HAVOC  AND OVER - APPROXIMATION) AND PRACTICAL REACHABILITY.EFFECTIVELY BRIDGING THIS GAP REQUIRES THE USER TO EXPLICITLY AND PRECISELY DEFINE THE "REACHABLE" STATE SPACE THROUGH A WELL - CRAFTED SPECIFICATION.

### ** 2.5.THE CONFLUENCE: HAVOC AND UNREACHABLE STATES **

                THE HAVOC  MECHANISM DIRECTLY ENABLES THE PROVER TO EXPLORE THESE UNREACHABLE INITIAL STATES.BY ASSIGNING "ARBITRARY, NON-DETERMINISTIC VALUES" TO ALL VARIABLES AT THE START OF A RULE,  HAVOC  CAN POPULATE THE CONTRACT STATE WITH VALUES THAT WOULD NEVER OCCUR IN A REAL - WORLD SCENARIO WITHOUT PROPER CONSTRAINTS.THIS MEANS THE PROVER WILL DILIGENTLY ATTEMPT TO FIND COUNTEREXAMPLES WITHIN THESE UNREALISTIC CONFIGURATIONS.

A COMMON SCENARIO ARISES IN CONJUNCTION WITH SOLIDITY'S  UNCHECKED  ARITHMETIC. ALTHOUGH  UNCHECKED  BLOCKS ARE OFTEN USED FOR GAS OPTIMIZATION AND ARE SAFE WHEN HIGHER-LEVEL INVARIANTS ARE MAINTAINED BY THE CONTRACT'S LOGIC(E.G.,  totalSupply  NOT EXCEEDING type(uint256).max ),  HAVOC  CAN INTRODUCE ARBITRARILY LARGE TOKEN BALANCES, LEADING TO OVERFLOWS IN THESE  UNCHECKED  OPERATIONS.THIS RESULTS IN A REPORTED VIOLATION(A FALSE POSITIVE), EVEN THOUGH SUCH AN OVERFLOW IS IMPOSSIBLE UNDER NORMAL, REACHABLE CONDITIONS.

THE MOCKASSETA EXAMPLE EXPLICITLY ADDRESSES THIS PROBLEM BY MODIFYING THE ERC20 IMPLEMENTATION TO STRICTLY ADHERE TO SAFE ARITHMETIC, THEREBY PREVENTING HAVOC  - INDUCED OVERFLOWS DURING VERIFICATION.

                WHEN  HAVOC  POPULATES AN UNREACHABLE STATE WITH ARBITRARY VALUES, AND A PROPERTY(E.G., AN ASSERT  STATEMENT) IS SUBSEQUENTLY VIOLATED IN ONE OF THESE STATES, THE PROVER GENERATES A "SPURIOUS COUNTEREXAMPLE".THESE COUNTEREXAMPLES ARE MATHEMATICALLY VALID WITHIN THE OVER - APPROXIMATED MODEL BUT DO NOT CORRESPOND TO ACTUAL, EXPLOITABLE VULNERABILITIES IN THE DEPLOYED CONTRACT.THEY ARE "FALSE ALARMS" THAT CONSUME AUDIT RESOURCES.

THE BROAD NON - DETERMINISM OF HAVOC , COMBINED WITH THE PROVER'S OVER-APPROXIMATION, MEANS THAT IF THE INITIAL STATE IS NOT SUFFICIENTLY CONSTRAINED IN THE USER'S SPECIFICATION, THE PROVER WILL BE OPERATING ON "GARBAGE"—I.E., STATES THAT ARE MATHEMATICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE.IT IS EXPLICITLY STATED: "EVEN IF SUCH A STATE IS UNREACHABLE THROUGH ANY PATH OF ACTIONS BY ANY USER, THE TOOL STILL CONSIDERS THIS INITIAL STATE A VALID ONE." THIS UNDERSCORES THE CRITICAL IMPORTANCE OF THE QUALITY AND PRECISION OF THE SPECIFICATION.IF THE USER FAILS TO ACCURATELY MODEL THE CONTRACT'S ACTUAL INITIAL CONDITIONS AND ENVIRONMENTAL CONSTRAINTS, CERTORA'S POWERFUL SYMBOLIC EXECUTION CAPABILITIES WILL FAITHFULLY EXPLORE THESE UNREALISTIC SCENARIOS, LEADING TO FALSE POSITIVES.IN ESSENCE, IT IS THE RESPONSIBILITY OF THE SPECIFICATION WRITER TO ENSURE THAT THE "INPUT" TO THE VERIFICATION(THE DEFINED AND CONSTRAINED STATE SPACE) IS "CLEAN" AND RELEVANT TO THE SMART CONTRACT'S ACTUAL OPERATIONAL CONTEXT.

## ** 3. UNDERSTANDING FALSE POSITIVES FROM UNREACHABLE INITIAL STATES **

                THIS SECTION WILL DELVE INTO THE MECHANISM BY WHICH  HAVOC  LEADS TO SPURIOUS COUNTEREXAMPLES AND PROVIDE GUIDANCE ON INTERPRETING THE CALL TRACE.

### ** 3.1.HOW HAVOC  LEADS TO SPURIOUS COUNTEREXAMPLES **

                THE CERTORA PROVER'S DEFAULT  HAVOC  BEHAVIOR FOR UNASSIGNED VARIABLES AND INITIAL STATES MEANS IT EXPLORES *ALL* LOGICALLY POSSIBLE VALUES AND CONFIGURATIONS, EVEN THOSE THAT ARE IMPOSSIBLE OR IRRELEVANT IN THE REAL-WORLD CONTEXT OF THE CONTRACT'S DEPLOYMENT OR OPERATION.
WHEN THE PROVER IDENTIFIES A COUNTEREXAMPLE, IT PRESENTS A "MODEL"—A SPECIFIC ASSIGNMENT TO ALL CVL VARIABLES AND CONTRACT STORAGE—THAT CAUSES AN  ASSERT  STATEMENT TO FAIL.IF THE INITIAL STATE OF THIS MODEL, OR AN INTERMEDIATE STATE REACHED VIA A HAVOCED EXTERNAL CALL, IS ONE THAT THE ACTUAL CONTRACT COULD NEVER REALISTICALLY BE IN(CONTRADICTORY, NOT MERELY HARD TO REACH), THEN THE REPORTED VIOLATION IS A FALSE POSITIVE.
A FALSE POSITIVE CAUSED BY  HAVOC  IS NOT A FLAW IN THE PROVER'S LOGIC BUT A DIAGNOSTIC SIGNAL OF A MISMATCH BETWEEN THE VERIFICATION'S ABSTRACT MODEL AND THE SMART CONTRACT'S MORE CONSTRAINED, REAL-WORLD ENVIRONMENT. THE PROVER CORRECTLY EXPLORES THE FULL STATE SPACE *AS DEFINED BY THE SPECIFICATION*, BUT IF THAT SPECIFICATION IS TOO LOOSE, IT WILL CONTAIN "UNREACHABLE" STATES THAT LEAD TO SPURIOUS COUNTEREXAMPLES.  HAVOC  EXPLORES "ALL LOGICALLY POSSIBLE VALUES," WHICH LEADS TO COUNTEREXAMPLES FROM "IMPOSSIBLE STATES." THE PROVER IS INHERENTLY *SOUND*; IT WILL FIND *ANY* VIOLATION WITHIN THE *DEFINED* STATE SPACE. IF THE USER'S SPECIFICATION(THE "DEFINED STATE SPACE") IS BROADER THAN THE SYSTEM'S *ACTUAL REACHABLE STATE SPACE* IN PRODUCTION, THEN ANY COUNTEREXAMPLE FOUND IN THE "UNREACHABLE" PART OF THE MODEL IS A FALSE POSITIVE. THE PROBLEM IS NOT  HAVOC  ITSELF, BUT THE *UNDER-CONSTRAINING* OF  HAVOC  IN THE CVL SPECIFICATION. THE PROVER IS SIMPLY HIGHLIGHTING THAT, ACCORDING TO THE CURRENT SPECIFICATION, A VIOLATION *IS* POSSIBLE. THIS SHIFT IN PERSPECTIVE IS CRITICAL: FALSE POSITIVES ARE NOT THE PROVER'S MISTAKE BUT VALUABLE FEEDBACK.THEY INDICATE THAT THE ONUS IS ON THE SPECIFICATION WRITER TO ACCURATELY MODEL THE SYSTEM'S TRUE INVARIANTS, PRECONDITIONS, AND ENVIRONMENTAL ASSUMPTIONS. THIS ITERATIVE PROCESS OF IDENTIFYING AND RESOLVING FALSE POSITIVES IS CORE TO ACHIEVING HIGH-FIDELITY FORMAL VERIFICATION.

                ** FALSE POSITIVE GENERATION MECHANISM:** THE MOST PREVALENT SOURCE OF FALSE POSITIVES IS INSUFFICIENT CONSTRAINTS ON THE INITIAL STATE AT THE BEGINNING OF A CVL RULE.BY DEFAULT, CERTORA'S  HAVOC  MECHANISM ASSIGNS ARBITRARY VALUES TO ALL VARIABLES AND CONTRACT STORAGE AT THE START OF A RULE TO SIMULATE A COMPLETELY UNKNOWN INITIAL CONFIGURATION. IF THE CONTRACT'S ACTUAL INITIAL STATE SPACE IS MORE STRICTLY LIMITED(E.G., DUE TO CONSTRUCTOR LOGIC OR DEPLOYMENT INVARIANTS), AND THESE LIMITATIONS ARE NOT EXPLICITLY CAPTURED IN THE CVL RULE VIA  REQUIRE  STATEMENTS, THE PROVER MAY FIND COUNTEREXAMPLES UNDER THESE UNREALISTIC STARTING CONDITIONS.

A COMMON SCENARIO IS WHEN A RULE ASSERTS AN INVARIANT LIKE totalSupply() == sumOfBalances;  .IF IN THE INITIAL STATE,  totalSupply  IS HAVOCED TO A VALUE, FOR INSTANCE, LESS THAN THE SUM OF INDIVIDUAL USER BALANCES(A STATE IMPOSSIBLE AFTER A CORRECTLY EXECUTED CONSTRUCTOR), THE INVARIANT WILL FAIL IMMEDIATELY.THIS LEADS TO A FALSE POSITIVE BECAUSE THE REPORTED VIOLATION OCCURS IN AN INITIAL STATE THE ACTUAL CONTRACT CAN NEVER ENTER.SIMILARLY, THE INTERACTION OF  HAVOC  WITH SOLIDITY'S  UNCHECKED  ARITHMETIC CAN LEAD TO SPURIOUS OVERFLOWS, AS DEMONSTRATED IN THE MOCKASSETA CASE.

WHEN EXTERNAL FUNCTION CALLS OR COMPLEX INTERNAL LOGIC ARE ABSTRACTED USING  HAVOC_ALL  OR  NONDET  SUMMARIES, THE PROVER ASSUMES THESE CALLS CAN ARBITRARILY MODIFY CONTRACT STORAGE OR RETURN ANY VALUE.IF THE ACTUAL BEHAVIOR OF THE EXTERNAL CONTRACT OR INTERNAL FUNCTION IS MORE CONSTRAINED THAN THIS BROAD ASSUMPTION, THE OVER - APPROXIMATION CAN LEAD TO COUNTEREXAMPLES THAT WOULD NEVER OCCUR IN ACTUAL INTERACTIONS.THIS IS A CLASSIC FORM OF A SPURIOUS COUNTEREXAMPLE CAUSED BY AN OVERLY GENERIC MODEL.

ALTHOUGH NOT DIRECTLY CAUSED BY HAVOC , MISLEADING "PASSES" CAN ALSO BE CONSIDERED A FORM OF FALSE POSITIVE IN TERMS OF WHAT THE USER BELIEVES IS BEING VERIFIED.THIS OCCURS WITH "VACUOUS PRECONDITIONS"(A REQUIRE  STATEMENT SO STRICT THAT NO INPUT CAN SATISFY IT, MAKING THE ASSERTION TRIVIALLY TRUE) OR "TAUTOLOGICAL ASSERTIONS"(AN ASSERTION THAT IS ALWAYS TRUE REGARDLESS OF THE CODE'S BEHAVIOR). FOR EXAMPLE, A RULE CONTAINING  REQUIRE X > 2; REQUIRE X < 1;   WILL ALWAYS PASS BECAUSE NO  X  CAN SATISFY BOTH CONDITIONS, MAKING ANY SUBSEQUENT  ASSERT  VACUOUSLY TRUE. SIMILARLY,  ASSERT X < 2 || X >= 2;   IS A TAUTOLOGY THAT PROVIDES NO MEANINGFUL VERIFICATION. CERTORA'S SANITY CHECKS ARE DESIGNED TO FLAG THESE ISSUES.

FALSE POSITIVES ARE MORE THAN JUST AN INCONVENIENCE; THEY CONSUME VALUABLE DEVELOPER / AUDITOR TIME IN ANALYZING SPURIOUS COUNTEREXAMPLES.IF THESE OCCUR FREQUENTLY, THEY CAN LEAD TO A POTENTIAL EROSION OF TRUST IN THE FORMAL VERIFICATION RESULTS.THE CORE VALUE PROPOSITION OF FORMAL VERIFICATION TOOLS LIKE CERTORA IS THEIR PROMISE OF "MATHEMATICAL CERTAINTY." IF THIS CERTAINTY IS REPEATEDLY UNDERMINED BY NON - ACTIONABLE FINDINGS, THE PERCEIVED VALUE AND CREDIBILITY OF THE TOOL DIMINISH.FOR SYSTEMS WHERE SAFETY AND CORRECTNESS ARE CRITICAL(E.G., DEFI PROTOCOLS, AEROSPACE SOFTWARE, MEDICAL DEVICES), THE PRECISION AND ACTIONABILITY OF FORMAL VERIFICATION RESULTS ARE AS IMPORTANT AS THEIR THEORETICAL SOUNDNESS.FALSE POSITIVES, BY INTRODUCING NOISE AND ERODING TRUST, EFFECTIVELY REDUCE THE * PRACTICAL SOUNDNESS * FROM THE USER'S PERSPECTIVE, EVEN IF THE UNDERLYING MATHEMATICAL ENGINE REMAINS THEORETICALLY SOUND. THIS HIGHLIGHTS THE URGENT NEED FOR USER-FRIENDLY MECHANISMS AND BEST PRACTICES THAT EMPOWER USERS TO MANAGE THE TRADEOFF BETWEEN EXHAUSTIVE STATE EXPLORATION AND THE GENERATION OF PRACTICALLY RELEVANT COUNTEREXAMPLES.

### ** 3.2.INTERPRETING CERTORA'S VERIFICATION REPORT AND CALL TRACE**

WHEN A RULE FAILS VERIFICATION, THE CERTORA PROVER GENERATES A DETAILED VERIFICATION REPORT, INCLUDING A CONCRETE COUNTEREXAMPLE.THIS REPORT IS ACCESSIBLE VIA A WEB LINK PROVIDED IN THE COMMAND - LINE OUTPUT.
TO DIAGNOSE A FALSE POSITIVE, IT IS ESSENTIAL TO DIVE INTO THE VERIFICATION RESULTS OF THE SPECIFIC RULE OR FUNCTION THAT FAILED.THE "CALL TRACE" SUB - WINDOW IN THE REPORT IS AN INDISPENSABLE DIAGNOSTIC TOOL.IT PROVIDES A DETAILED BREAKDOWN OF THE EXECUTION STEPS THAT LED TO THE FAILURE, SHOWING THE SEQUENCE OF OPERATIONS AND STATE CHANGES.THIS TRACE WILL REVEAL THE INITIAL STATE(E.G., "ASSUME INVARIANT IN PRE-STATE" SHOWING ZERO VALUES FOR KEY VARIABLES) AND HOW VARIABLES(INCLUDING GHOST VARIABLES) WERE HAVOCED TO UNEXPECTED VALUES.THE CALL TRACE ALSO HIGHLIGHTS WHERE  HAVOC  IS TRIGGERED, OFTEN BY AN EXTERNAL CALL TO AN UNRESOLVED CALLEE, WHERE THE PROVER CONSERVATIVELY RANDOMIZES VARIABLES TO ACCOUNT FOR POTENTIAL STATE CHANGES.
THE DETAILED COUNTEREXAMPLE AND CALL TRACE ARE THE PRIMARY DIAGNOSTIC TOOLS FOR DISTINGUISHING REAL BUGS FROM FALSE POSITIVES.A FALSE POSITIVE IS DEFINITIVELY IDENTIFIED WHEN THE INITIAL STATE OR AN INTERMEDIATE STATE OF THE COUNTEREXAMPLE(AS SHOWN IN THE TRACE) IS DEMONSTRABLY IMPOSSIBLE OR IRRELEVANT GIVEN THE REAL - WORLD CONSTRAINTS AND INVARIANTS OF THE SYSTEM.CERTORA PROVIDES A COUNTEREXAMPLE AND A CALL TRACE.THESE OUTPUTS SHOW THE INITIAL STATE AND SUBSEQUENT STATE CHANGES.THE CALL TRACE ALLOWS THE USER TO EXAMINE THE * SPECIFIC * INITIAL STATE AND THE * EXACT * SEQUENCE OF  HAVOC  OPERATIONS OR EXTERNAL CALLS THAT LED TO THE ASSERTION FAILURE.IF, UPON REVIEWING THIS TRACE, THE USER CAN CONFIDENTLY STATE, "MY CONTRACT *NEVER* STARTS IN THIS PARTICULAR STATE," OR "THIS EXTERNAL CALL *NEVER* PRODUCES THIS SPECIFIC EFFECT IN PRACTICE," THEN THEY HAVE IDENTIFIED A FALSE POSITIVE.THE TRACE PROVIDES THE CONCRETE, STEP - BY - STEP EVIDENCE TO PINPOINT THE "UNREACHABLE" OR "UNREALISTIC" ASPECT OF THE PROVER'S MODEL. EFFECTIVELY DEBUGGING CERTORA FALSE POSITIVES REQUIRES A STRONG MENTAL MODEL OF THE *ACTUAL* SYSTEM'S INVARIANTS, PRECONDITIONS, AND EXPECTED BEHAVIOR.THIS MENTAL MODEL IS THEN CRITICALLY COMPARED AGAINST THE COUNTEREXAMPLE GENERATED BY THE PROVER.THIS ITERATIVE "FAIL-ANALYZE-REFINE" PROCESS IS AT THE HEART OF FORMAL VERIFICATION, TRANSFORMING RAW PROVER OUTPUT INTO ACTIONABLE SPECIFICATION IMPROVEMENTS.

## ** 4. STRATEGIES TO MITIGATE FALSE POSITIVES FROM HAVOC  **

                THIS SECTION OUTLINES CONCRETE, ACTIONABLE STRATEGIES FOR REFINING CERTORA SPECIFICATIONS TO REDUCE FALSE POSITIVES CAUSED BY HAVOC .
                CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE 

### ** 4.1.REFINING INITIAL STATE CONSTRAINTS **

#### ** 4.1.1.USING  HAVOC ASSUMING  FOR PRECISE STATE INITIALIZATION **

                WHILE UNASSIGNED VARIABLES ARE HAVOCED BY DEFAULT, THE HAVOC  STATEMENT CAN BE ENHANCED WITH AN  ASSUMING CONDITION  CLAUSE.THIS CLAUSE RESTRICTS THE VALUES THAT THE HAVOCED VARIABLE CAN TAKE.THIS IS FUNCTIONALLY EQUIVALENT TO PLACING A  REQUIRE  STATEMENT IMMEDIATELY AFTER A BASIC  HAVOC  DECLARATION.
THIS CONSTRUCT IS PARTICULARLY USEFUL FOR MODELING COMPLEX SCENARIOS THAT MUST SATISFY CERTAIN INHERENT CONSTRAINTS OR INVARIANTS.FOR EXAMPLE,  HAVOC SUMALLBALANCE ASSUMING SUMALLBALANCE @NEW() == SUMALLBALANCE@OLD() + BALANCE - OLD_BALANCE;   DEMONSTRATES ITS UTILITY IN MAINTAINING RELATIONSHIPS BETWEEN STATES.SIMILARLY, FOR A GHOST VARIABLE IN A TWO - STATE CONTEXT,  HAVOC FOO ASSUMING FOO_ADD_EVEN(X);  CAN ENSURE A SPECIFIC PROPERTY IS MAINTAINED ACROSS STATES.
 HAVOC ASSUMING IS THE PRIMARY MECHANISM FOR TRANSFORMING A BROAD, SOUND OVER - APPROXIMATION OF THE INITIAL STATE INTO A MORE PRECISE, YET STILL SOUND, MODEL THAT IS LESS PRONE TO GENERATING SPURIOUS COUNTEREXAMPLES.IT ALLOWS THE SPECIFICATION WRITER TO INJECT REAL - WORLD INVARIANTS OR PRECONDITIONS THAT THE PROVER, UNDER MAXIMAL NON - DETERMINISM, WOULD OTHERWISE NOT KNOW OR CONSIDER.  HAVOC  WITHOUT  ASSUMING  DEFAULTS TO ARBITRARY VALUES FOR THE INITIAL STATE.
HAVOC ASSUMING ALLOWS SPECIFYING CONDITIONS FOR THESE VALUES.WITHOUT ASSUMING , THE PROVER EXPLORES ALL MATHEMATICALLY POSSIBLE INITIAL CONFIGURATIONS FOR A VARIABLE, INCLUDING THOSE THAT VIOLATE REAL - WORLD INVARIANTS(E.G., A NEGATIVE TOTAL_SUPPLY , OR AN OWNER  ADDRESS OF ADDRESS(0)  IF THAT IS AN INVALID STATE IN THE ACTUAL CONTRACT).  HAVOC ASSUMING  PROVIDES A WAY TO INJECT THESE REAL - WORLD INVARIANTS DIRECTLY AS CONSTRAINTS ON THE INITIAL STATE VARIABLES.THIS EFFECTIVELY PRUNES THE SMT SOLVER'S SEARCH SPACE, PREVENTING IT FROM FINDING COUNTEREXAMPLES IN STATES THAT ARE IMPOSSIBLE IN PRACTICE, THEREBY DIRECTLY REDUCING FALSE POSITIVES. THIS FEATURE IS CRITICAL FOR BRIDGING THE GAP BETWEEN THE GENERIC MATHEMATICAL MODEL AND THE SPECIFIC, CONSTRAINED REALITY OF A SMART CONTRACT'S OPERATIONAL ENVIRONMENT.IT ALLOWS THE USER TO MAKE THE VERIFICATION RESULTS MORE RELEVANT AND ACTIONABLE BY FOCUSING THE PROVER'S EFFORTS ON THE TRULY REACHABLE STATE SPACE.
#### ** 4.1.2.THE PERSISTENT KEYWORD FOR GHOST VARIABLES **

                BY DEFAULT, CERTORA'S PROVER WILL HAVOC GHOST VARIABLES, EVEN IF THEY ARE EXPLICITLY INITIALIZED. THIS IS BECAUSE THE PROVER CONSERVATIVELY ASSUMES THAT EXTERNAL INFLUENCES (E.G., CALLS TO UNRESOLVED CALLEES) MIGHT ALTER THESE VARIABLES. THIS CAN LEAD TO SIGNIFICANT INACCURACIES IN ASSERTIONS, AS THE PROVER MAY GENERATE COUNTEREXAMPLES WHERE GHOST VARIABLES ARE SPURIOUSLY CHANGED.
THE DIRECT SOLUTION TO THIS PROBLEM IS TO DECLARE THE RELEVANT GHOST VARIABLES AS PERSISTENT.
                THE PERSISTENT KEYWORD EXPLICITLY INSTRUCTS THE CERTORA PROVER THAT THE VALUE OF THE TAGGED GHOST VARIABLE SHOULD REMAIN STATIC AND * NOT * BE SUBJECT TO RANDOMIZATION OR havoc DURING THE VERIFICATION PROCESS.THIS ENSURES THAT THE PROVER'S ANALYSIS OF INVARIANTS AND PROPERTIES IS BASED ON THE INTENDED, UNCHANGING VALUES OF THESE GHOST VARIABLES, LEADING TO MORE ACCURATE AND RELIABLE FORMAL VERIFICATION RESULTS⁸.
            THE PERSISTENT KEYWORD IS A CRITICAL MECHANISM FOR DECLARING AN * ASSUMPTION OF INVARIANCE * ABOUT A SPECIFIC STATE COMPONENT(PARTICULARLY GHOST VARIABLES) THAT THE PROVER WOULD OTHERWISE CONSERVATIVELY ASSUME IS MUTABLE.THIS DIRECTLY ADDRESSES A COMMON AND OFTEN FRUSTRATING SOURCE OF FALSE POSITIVES RELATED TO THE INTEGRITY OF GHOST VARIABLES, WHICH ARE ESSENTIAL FOR EXPRESSING COMPLEX PROPERTIES.CERTORA PERFORMS A havoc WHEN IT IS UNSURE IF A FUNCTION CAN INTERACT WITH A VARIABLE.
havoc REFERS TO ASSIGNING ARBITRARY, NON - DETERMINISTIC VALUES TO VARIABLES...FOR EXAMPLE, WHEN AN EXTERNAL FUNCTION IS CALLED ON AN UNKNOWN CONTRACT, THE PROVER ASSUMES IT MAY ARBITRARILY AFFECT THE STATE OF A THIRD CONTRACT.BY DESIGN, THE CERTORA PROVER OPERATES ON A PRINCIPLE OF MAXIMAL CONSERVATISM TO ENSURE SOUNDNESS.FOR ANY VARIABLE WHOSE MUTABILITY OR SUSCEPTIBILITY TO EXTERNAL INFLUENCE CANNOT BE EXPLICITLY PROVEN, THE PROVER DEFAULTS TO ASSUMING IT * CAN * BE ARBITRARILY CHANGED.THIS IS A SOUND BUT OFTEN OVERLY BROAD DEFAULT.GHOST VARIABLES, DESPITE BEING PART OF THE SPECIFICATION, ARE SUBJECT TO THIS CONSERVATIVE ASSUMPTION UNLESS EXPLICITLY CONSTRAINED.THE PERSISTENT KEYWORD SERVES AS AN EXPLICIT DECLARATION TO THE PROVER: "ASSUME THE VALUE OF THIS GHOST VARIABLE IS FIXED THROUGHOUT THE EXECUTION OF THE RULE, EVEN IN THE PRESENCE OF EXTERNAL CALLS OR OTHER NON-DETERMINISTIC EVENTS." THIS DIRECTLY ELIMINATES FALSE POSITIVES WHERE THE PROVER MIGHT FABRICATE A SPURIOUS CHANGE IN A GHOST VARIABLE, THEREBY CAUSING A PROPERTY VIOLATION.THIS HIGHLIGHTS THE NECESSITY OF EXPLICITLY DECLARING ASSUMPTIONS ABOUT THE INVARIANCE OR STABILITY OF STATE IN THE SPECIFICATION.IT IS A CONCRETE INSTANCE OF REFINING THE MODEL TO ALIGN WITH REAL - WORLD GUARANTEES, ALLOWING THE PROVER TO FOCUS ON RELEVANT BEHAVIORS.

#### ** 4.1.3.STRATEGIC APPLICATION OF REQUIRE STATEMENTS(AND THEIR CAVEATS) **

THE REQUIRE STATEMENT IN CVL DEFINES A PRECONDITION FOR A RULE.IF A require STATEMENT EVALUATES TO FALSE IN A PARTICULAR EXAMPLE, THE PROVER IGNORES THAT EXAMPLE ENTIRELY DURING VERIFICATION.THIS MECHANISM CAN BE USED TO EXCLUDE COUNTEREXAMPLES THAT START FROM IMPOSSIBLE STATES, THUS REDUCING FALSE POSITIVES.
    THE REQUIREINVARIANT COMMAND IS A SPECIALIZED FORM THAT ALLOWS A PREVIOUSLY VERIFIED INVARIANT TO BE ADDED AS AN ASSUMPTION TO ANOTHER RULE.THIS CAN BE A QUICK AND EFFECTIVE WAY TO EXCLUDE COUNTEREXAMPLES THAT ARISE FROM STATES INCONSISTENT WITH ESTABLISHED SYSTEM INVARIANTS.
** CAVEAT **: THE USE OF require STATEMENTS MUST BE EXTREMELY CAREFUL.USING require TOO AGGRESSIVELY CAN LEAD TO * UNSOUNDNESS *, AS THE PROVER WILL SIMPLY IGNORE ANY MODEL THAT CAUSES THE require EXPRESSION TO EVALUATE TO FALSE, POTENTIALLY MISSING A GENUINE VIOLATION OF THE DESIRED PROPERTY.THE CERTORA PROVER EVEN ISSUES WARNINGS AGAINST require STATEMENTS THAT MIGHT EXCLUDE MEANINGFUL TRACES.FURTHERMORE, ADDING AN ARBITRARY require STATEMENT IN THE preserved BLOCK OF AN INVARIANT CAN INVALIDATE THE INDUCTIVE PROOF IF THE UNDERLYING ASSUMPTION IS NOT INDEPENDENTLY VERIFIED.HOWEVER, USING requireInvariant J(y) IN A preserved BLOCK IS CONSIDERED SOUND AND ENCOURAGED, PROVIDED THE J INVARIANT HAS ITSELF BEEN INDEPENDENTLY VERIFIED.
    WHILE require STATEMENTS ARE POWERFUL FOR PRUNING THE SEARCH SPACE BY ASSERTING PRECONDITIONS, THEY ARE A DOUBLE - EDGED SWORD.THEY CAN EFFECTIVELY REDUCE FALSE POSITIVES, BUT THEY INTRODUCE A SIGNIFICANT RISK OF * UNSOUNDNESS * IF THEY INADVERTENTLY FILTER OUT VALID, VULNERABLE STATES. requireInvariant PROVIDES A SAFER, MORE MODULAR WAY TO LEVERAGE VERIFIED INVARIANTS AS PRECONDITIONS, THEREBY PRESERVING SOUNDNESS. require STATEMENTS CAUSE THE PROVER TO IGNORE THE EXAMPLES WHERE THEY FAIL.THIS CAN REDUCE FALSE POSITIVES BY FILTERING OUT IMPOSSIBLE STATES.HOWEVER, USING require TOO AGGRESSIVELY CAN LEAD TO MISSING REAL VIOLATIONS.
HAVOC Y ASSUMING Y > 10;  IS EQUIVALENT TO UINT256 Y; REQUIRE Y > 10; ⁴.ADDING ASSUMPTIONS IN A preserved BLOCK INVALIDATES THE PROOF IF WE HAVE NO REASON TO BELIEVE IT ACTUALLY HOLDS, WHICH IS WHY WE DO NOT RECOMMEND ADDING require STATEMENTS IN A preserved BLOCK.
* HAVOC ASSUMING * CONSTRAINS THE NON - DETERMINISM OF A VARIABLE'S INITIAL VALUE*. IT INSTRUCTS THE SMT SOLVER: "PICK ANY VALUE FOR X, BUT IT *MUST* SATISFY THIS CONDITION." THE PROVER THEN TRIES TO FIND A COUNTEREXAMPLE WITHIN THAT CONSTRAINED SPACE. THIS APPROACH MAINTAINS SOUNDNESS BECAUSE THE PROVER IS STILL EXPLORING ALL VALID POSSIBILITIES GIVEN THE CONSTRAINT.
* REQUIRE * FILTERS OUT AN ENTIRE EXECUTION PATH * IF A CONDITION DOES NOT HOLD.IT ESSENTIALLY TELLS THE PROVER: "IF THIS CONDITION IS NOT MET AT THIS POINT, SIMPLY DISCARD THIS EXECUTION BRANCH." THIS IS A MORE AGGRESSIVE PRUNING MECHANISM.
* THE KEY RISK WITH REQUIRE IS THAT IF THE CONDITION * COULD * BE FALSE IN A REAL, VULNERABLE SCENARIO, THE PROVER * NEVER CHECKS * THAT SCENARIO.THIS LEADS TO * UNSOUNDNESS * (THE PROVER MAY REPORT "PASS" WHEN A BUG EXISTS). HAVOC ASSUMING IS GENERALLY SAFER FOR INITIAL STATE CONSTRAINTS, AS IT STILL FORCES THE PROVER TO EXPLORE POTENTIAL VIOLATIONS WITHIN THE SPACE OF VALID, CONSTRAINED INITIAL STATES.
* REQUIREINVARIANT IS A PARTICULARLY VALUABLE PATTERN AS IT ALLOWS THE LEVERAGING OF * ALREADY VERIFIED * INVARIANTS AS ASSUMPTIONS, THUS PROMOTING MODULARITY AND PRESERVING SOUNDNESS IN COMPOSITIONAL PROOFS.

THE CHOICE BETWEEN HAVOC ASSUMING AND REQUIRE FOR INITIAL STATE CONSTRAINTS IS NUANCED.IT DEPENDS ON WHETHER THE CONDITION REPRESENTS AN INHERENT, ALWAYS - TRUE PROPERTY OF THE SYSTEM(BEST ADDRESSED WITH HAVOC ASSUMING OR REQUIREINVARIANT), OR IF ITS VIOLATION IMPLIES THE CURRENT EXECUTION PATH IS IRRELEVANT TO THE PROPERTY BEING CHECKED(USE REQUIRE, BUT WITH EXTREME CAUTION AND A CLEAR UNDERSTANDING OF THE POTENTIAL FOR UNSOUNDNESS).
** TABLE 2: CVL CONSTRUCTS FOR INITIAL STATE REFINEMENT **

| CONSTRUCT | SYNTAX EXAMPLE | PRIMARY PURPOSE FOR INITIAL STATE REFINEMENT | EFFECT ON NON - DETERMINISM | SOUNDNESS / CORRECTNESS IMPACT | BEST PRACTICE / KEY CONSIDERATION |
| : --- | : --- | : --- | : --- | : --- | : --- |
| HAVOC ASSUMING | HAVOC X ASSUMING X > 0;  | CONSTRAIN THE INITIAL RANDOMIZED VALUE RANGE OF A VARIABLE. | REDUCES. | MAINTAINS SOUNDNESS, REDUCES FALSE POSITIVES. | USE TO EXPRESS INHERENT PRECONDITIONS OR INVARIANTS OF THE SYSTEM. |
| PERSISTENT(GHOST VAR) | PERSISTENT GHOST | DECLARE THAT A GHOST VARIABLE'S VALUE IS CONSTANT DURING VERIFICATION. | ELIMINATES NON-DETERMINISM FOR THE GHOST VARIABLE. | MAINTAINS SOUNDNESS, ELIMINATES GHOST-RELATED FALSE POSITIVES. | USE ONLY FOR GHOST VARIABLES THAT ARE TRULY INVARIANT. |
    | REQUIRE | REQUIRE BALANCE > 0;  | IGNORE EXECUTION PATHS THAT DO NOT SATISFY THE CONDITION. | REDUCES(BY FILTERING). | CAN LEAD TO UNSOUNDNESS IF IT FILTERS OUT REAL VULNERABILITIES. | USE WITH CAUTION, ENSURING IT DOES NOT EXCLUDE VALID BUT VULNERABLE SCENARIOS. requireInvariant IS SAFER. |

### ** 4.2.OPTIMIZING EXTERNAL CALL SUMMARIES **

#### ** 4.2.1.CHOOSING THE RIGHT FUNCTION SUMMARY FOR EXTERNAL INTERACTIONS **

    AS PREVIOUSLY MENTIONED, HAVOC_ALL IS THE MOST CONSERVATIVE SUMMARY, ASSUMING EXTERNAL CALLS CAN CAUSE ARBITRARY STATE CHANGES.WHILE SOUND, ITS BROADNESS FREQUENTLY LEADS TO A HIGH VOLUME OF FALSE POSITIVES BY EXPLORING UNREALISTIC SCENARIOS.
HAVOC_ECF IS GENERALLY PREFERRED WHEN THE EXTERNAL CALL IS KNOWN TO BE NON - REENTRANT AND IS GUARANTEED NOT TO MODIFY THE CALLING CONTRACT'S STATE OR DECREASE ITS ETH BALANCE (BEYOND ANY EXPLICITLY TRANSFERRED VALUE). THIS SUMMARY SIGNIFICANTLY REDUCES FALSE POSITIVES AND IMPROVES PERFORMANCE BY RESTRICTING THE SCOPE OF havoc TO ONLY EXTERNAL CONTRACTS.
NONDET IS SUITABLE FOR EXTERNAL VIEW FUNCTIONS THAT ARE KNOWN TO HAVE NO SIDE EFFECTS, REPLACING THEIR EXECUTION WITH A NON - DETERMINISTIC RETURN VALUE.
EXPRESSION SUMMARIES PROVIDE THE HIGHEST PRECISION.WHEN THE BEHAVIOR OF AN EXTERNAL CALL CAN BE ACCURATELY MODELED BY A CVL FUNCTION OR GHOST AXIOM, AN EXPRESSION SUMMARY CAN REPLACE THE CALL WITH THIS PRECISE, DETERMINISTIC LOGIC.THIS APPROACH EFFECTIVELY ELIMINATES havoc - RELATED FALSE POSITIVES FOR THESE SPECIFIC EXTERNAL INTERACTIONS.
REPLACING A DISPATCHER SUMMARY WITH AUTO OR A MORE SPECIFIC SUMMARY CAN SIGNIFICANTLY REDUCE THE "PATH COUNT" AND PREVENT TIMEOUTS.
DISPATCHER SUMMARIES, BY CONSIDERING MULTIPLE POTENTIAL CALL TARGETS, CAN LEAD TO A STATE SPACE EXPLOSION, WHICH, WHILE NOT A FALSE POSITIVE IN ITSELF, CAN PREVENT THE PROVER FROM COMPLETING VERIFICATION, THUS HINDERING THE IDENTIFICATION OF REAL BUGS.
THE CHOICE OF EXTERNAL CALL SUMMARY IS A KEY DESIGN DECISION THAT DIRECTLY IMPACTS THE PRECISION OF THE VERIFICATION MODEL AND, CONSEQUENTLY, THE RATE OF FALSE POSITIVES.MORE PRECISE SUMMARIES(E.G., HAVOC_ECF OVER HAVOC_ALL, OR EXPRESSION SUMMARIES) REDUCE THE DEGREE OF OVER - APPROXIMATION, THEREBY REDUCING SPURIOUS COUNTEREXAMPLES.HOWEVER, THIS INCREASED PRECISION COMES AT THE COST OF REQUIRING STRONGER, * VALIDATED * ASSUMPTIONS ABOUT THE EXTERNAL CODE'S BEHAVIOR. DIFFERENT SUMMARY TYPES HAVE DIFFERENT EFFECTS ON STATE AND PERFORMANCE.
HAVOC_ALL "ERASES ALL KNOWLEDGE", IMPLYING MAXIMUM NON - DETERMINISM AND THUS A WIDER RANGE OF POSSIBLE(AND OFTEN UNREALISTIC) STATE CHANGES.
HAVOC_ECF "ASSUMES IT CAN HAVE ARBITRARY EFFECTS ON CONTRACTS *OTHER THAN* THE ONE BEING VERIFIED", WHICH REPRESENTS A * CONSTRAINT * ON NON - DETERMINISM, SPECIFICALLY PREVENTING CHANGES TO THE CALLING CONTRACT'S STATE. EXPRESSION SUMMARIES REPLACE A NON-DETERMINISTIC CALL WITH *DETERMINISTIC* CVL LOGIC, EFFECTIVELY ELIMINATING havoc FOR THAT CALL. havoc SUMMARIES INTRODUCE NON-DETERMINISM FOR EXTERNAL CALLS TO ACCOUNT FOR UNKNOWN BEHAVIOR. THE MORE CONSERVATIVE THE SUMMARY (HAVOC_ALL), THE MORE NON-DETERMINISM IS INTRODUCED. THIS LEADS TO A LARGER SEARCH SPACE FOR THE SMT SOLVER AND A HIGHER LIKELIHOOD OF FINDING SPURIOUS COUNTEREXAMPLES ARISING FROM UNREALISTIC OR IMPOSSIBLE EXTERNAL BEHAVIORS (FALSE POSITIVES). CONVERSELY, MORE PRECISE SUMMARIES (LIKE HAVOC_ECF OR EXPRESSION SUMMARIES) *REDUCE* THIS NON-DETERMINISM BY ENCODING KNOWN OR ASSUMED PROPERTIES OF THE EXTERNAL CALL. THIS NARROWS THE SEARCH SPACE, MAKES VERIFICATION MORE EFFICIENT, AND LEADS TO FEWER FALSE POSITIVES. THIS UNDERSCORES THE IMPORTANCE OF UNDERSTANDING THE BEHAVIOR OF EXTERNAL DEPENDENCIES. IF AN EXTERNAL CONTRACT'S BEHAVIOR IS WELL - UNDERSTOOD, IT SHOULD BE ENCODED AS PRECISELY AS POSSIBLE IN THE SUMMARY.IF IT IS TRULY UNKNOWN, ONE MUST START WITH A CONSERVATIVE SUMMARY(HAVOC_ALL) AND THEN CAREFULLY REFINE IT TO HAVOC_ECF OR AN EXPRESSION SUMMARY AS MORE ASSUMPTIONS ARE VALIDATED.THIS IS A KEY ASPECT OF EFFECTIVE MODULAR VERIFICATION.

#### ** 4.2.2.USING WITH(ENV) AND ENVFREE FOR ENVIRONMENT CONTROL **

    THE CERTORA PROVER MODELS THE CALL CONTEXT VIA THE ENV STRUCT VARIABLE, WHICH CAPTURES GLOBAL SOLIDITY VARIABLES LIKE MSG.SENDER, MSG.VALUE, BLOCK.NUMBER, AND BLOCK.TIMESTAMP.THE PROVER CONSIDERS "ALL POSSIBLE CALLING CONTEXTS" BY DEFAULT.THE WITH(ENV E) CLAUSE, USED IN THE METHODS BLOCK, ALLOWS THE ENVIRONMENT(ENV) USED WHEN A SUMMARIZED METHOD IS CALLED TO BE EXPLICITLY BOUND AND POTENTIALLY CONSTRAINED.THIS ENABLES MORE PRECISE MODELING OF THE ENVIRONMENTAL CONDITIONS UNDER WHICH A SUMMARIZED EXTERNAL CALL OCCURS.THE ENVFREE ANNOTATION CAN BE APPLIED TO FUNCTIONS THAT ARE COMPLETELY INDEPENDENT OF THE ENVIRONMENT, ALLOWING THEM TO BE CALLED WITHOUT AN ENV ARGUMENT.THIS EXPLICITLY ELIMINATES ENVIRONMENTAL NON - DETERMINISM FOR THOSE SPECIFIC FUNCTIONS, THEREBY SIMPLIFYING THE MODEL. WITH(ENV) AND ENVFREE PROVIDE FINE - GRAINED CONTROL OVER THE * ENVIRONMENTAL NON - DETERMINISM * CONSIDERED BY THE CERTORA PROVER.BY EXPLICITLY CONSTRAINING OR ELIMINATING THE INFLUENCE OF ENVIRONMENT VARIABLES ON SPECIFIC CALLS, ONE CAN EFFECTIVELY MITIGATE FALSE POSITIVES ARISING FROM UNREALISTIC OR IRRELEVANT ENVIRONMENTAL CONTEXTS, LEADING TO MORE TARGETED AND ACCURATE VERIFICATION.A COMMAND MAY CONTAIN "UNASSIGNED VARIABLES WITH UNSPECIFIED VALUES".THE STORAGE STATE IS ALSO UNSPECIFIED AT THE START OF A RULE.ENVIRONMENT VARIABLES(MSG.SENDER, BLOCK.TIMESTAMP, ETC.) ARE PART OF THE UNSPECIFIED, NON - DETERMINISTIC INITIAL STATE OF ANY CALL.IF THE PROVER IS ALLOWED TO CHOOSE * ANY * VALUE FOR MSG.SENDER, MSG.VALUE, OR BLOCK.TIMESTAMP FOR AN EXTERNAL CALL, IT MAY FIND COUNTEREXAMPLES IN ENVIRONMENTAL CONTEXTS THAT ARE IMPOSSIBLE OR IRRELEVANT IN THE ACTUAL SYSTEM(E.G., ADDRESS(0) PERFORMING A PRIVILEGED ACTION, OR A TIMESTAMP IN THE DISTANT PAST). WITH(ENV) ALLOWS THE USER TO ADD SPECIFIC CONSTRAINTS TO THESE ENV VARIABLES * SPECIFICALLY FOR THE SUMMARIZED CALL *, EFFECTIVELY PRUNING THE ENVIRONMENTAL STATE SPACE. ENVFREE GOES A STEP FURTHER BY, FOR FUNCTIONS THAT ARE TRULY INDEPENDENT OF ENV VARIABLES, ELIMINATING ENVIRONMENTAL NON - DETERMINISM ENTIRELY, FURTHER SIMPLIFYING THE MODEL AND REDUCING THE POTENTIAL FOR FALSE POSITIVES CAUSED BY ENVIRONMENTAL FACTORS.FORMAL VERIFICATION IS NOT LIMITED TO A CONTRACT'S INTERNAL LOGIC; IT ENCOMPASSES ITS INTERACTION WITH THE ENVIRONMENT. ACCURATELY MODELING THE ENVIRONMENT IS AS IMPORTANT AS MODELING THE CONTRACT ITSELF TO AVOID FALSE POSITIVES AND ENSURE THE RELEVANCE OF THE VERIFICATION RESULTS. THESE CONSTRUCTS PROVIDE THE NECESSARY TOOLS TO ACHIEVE THIS PRECISE ENVIRONMENTAL MODELING.

### ** 4.3.USING FILTERS TO SCOPE THE VERIFICATION **

#### ** 4.3.1.APPLYING FILTERED BLOCKS IN RULES TO EXCLUDE METHODS **

    THE CERTORA PROVER SUPPORTS "PARAMETRIC RULES," WHICH ARE RULES THAT CONTAIN UNDEFINED METHOD VARIABLES.WHEN VERIFYING SUCH A RULE, THE PROVER GENERATES A SEPARATE REPORT FOR EACH METHOD(OR COMBINATION OF METHODS) THAT INSTANTIATES THE PARAMETRIC RULE.A FILTERED BLOCK CAN BE ADDED TO THE RULE DECLARATION, AFTER THE RULE PARAMETERS.THESE BLOCKS ALLOW THE USER TO PREVENT VERIFICATION OF THE PARAMETRIC RULE FOR SPECIFIC METHODS.THIS APPROACH IS OFTEN MORE COMPUTATIONALLY EFFICIENT THAN USING require STATEMENTS IN THE RULE BODY TO IGNORE COUNTEREXAMPLES FOR CERTAIN METHODS.FILTERS CONSIST OF var -> expr PAIRS, WHERE var MUST MATCH ONE OF THE RULE'S METHOD PARAMETERS AND expr IS A BOOLEAN EXPRESSION THAT CAN REFER TO var (E.G., F -> F.ISVIEW, G -> G.SELECTOR != SIG: SOMEMETHOD().SELECTOR).
RULE FILTERS ARE MORE THAN JUST A PERFORMANCE OPTIMIZATION; THEY ARE A KEY MECHANISM FOR * SCOPE MANAGEMENT * THAT DIRECTLY CONTRIBUTES TO REDUCING FALSE POSITIVES.BY EXPLICITLY EXCLUDING VERIFICATION FOR METHODS WHERE A PROPERTY IS NOT EXPECTED TO HOLD, FILTERS ENSURE THE PROVER ONLY SPENDS RESOURCES ON RELEVANT CHECKS, THUS PREVENTING SPURIOUS COUNTEREXAMPLES FROM INAPPLICABLE CONTEXTS.PARAMETRIC RULES CHECK MANY METHODS.FILTERS ALLOW EXCLUDING METHODS.THIS IS "LESS COMPUTATIONALLY EXPENSIVE" THAN require.RULE FILTERS ALLOW PREVENTING VERIFICATION OF A PARAMETRIC RULE FOR CERTAIN METHODS.
    THE require STATEMENT WARNS: "IT IS IMPORTANT TO THINK CAREFULLY ABOUT THE REASON FOR EXCLUDING THESE BEHAVIORS, AS USING require TOO AGGRESSIVELY MAY MISS A VIOLATION OF A DESIRED PROPERTY".IF A PARAMETRIC RULE IS INTENDED TO EXPRESS A PROPERTY THAT APPLIES TO A GENERAL CLASS OF METHODS(E.G., "ALL VIEW FUNCTIONS SHOULD NOT ALTER STATE"), BUT THERE ARE CERTAIN METHODS WITHIN THAT CLASS THAT ARE * NOT EXPECTED TO SATISFY * THE PROPERTY(E.G., A mint FUNCTION OBVIOUSLY ALTERS totalSupply), THEN CHECKING THE PROPERTY ON THE mint FUNCTION WILL INEVITABLY LEAD TO A COUNTEREXAMPLE.THIS COUNTEREXAMPLE, WHILE TECHNICALLY A VIOLATION OF THE RULE * AS WRITTEN *, IS A FALSE POSITIVE IN THE * CONTEXT OF THE INTENDED PROPERTY *.FILTERS ALLOW THE USER TO EXPLICITLY DEFINE THE * DOMAIN OF APPLICABILITY * FOR A RULE, EFFECTIVELY STATING: "THIS RULE ONLY APPLIES TO METHODS THAT SATISFY THIS CONDITION." THIS PREVENTS THE PROVER FROM REPORTING "VIOLATIONS" FOR METHODS THAT ARE NOT EXPECTED TO SATISFY THE PROPERTY, THUS ELIMINATING THESE SPECIFIC FALSE POSITIVES.THE COMPUTATIONAL EFFICIENCY IS A VALUABLE BYPRODUCT OF THIS PRECISE SCOPING.FILTERS ARE A FORM OF "META-SPECIFICATION" THAT DEFINES THE BOUNDARIES OF A PROPERTY'S RELEVANCE. THEY ARE CRITICAL FOR MANAGING THE COMPLEXITY OF LARGE SPECIFICATIONS AND ENSURING THAT VERIFICATION EFFORTS ARE FOCUSED ON MEANINGFUL PROPERTIES, THEREBY IMPROVING THE SIGNAL-TO-NOISE RATIO OF THE VERIFICATION RESULTS.

#### ** 4.3.2.APPLYING FILTERED BLOCKS IN INVARIANTS FOR CONTEXTUAL CHECKS **

    INVARIANTS IN CERTORA ARE PROPERTIES THAT THE SYSTEM SHOULD ALWAYS MAINTAIN.THEY ARE PROVEN BY INDUCTION: FIRST, BY ESTABLISHING A BASE CASE(E.G., THE INVARIANT HOLDS AFTER A CONSTRUCTOR CALL), AND THEN BY PROVING THAT EVERY FUNCTION IN THE CONTRACT PRESERVES THE INVARIANT(THE INDUCTIVE STEP).
        A FILTERED BLOCK CAN ALSO BE ADDED TO AN INVARIANT DECLARATION TO PREVENT THE PROVER FROM CHECKING THE INVARIANT'S PRESERVATION FOR SPECIFIC METHODS. FOR INSTANCE, FILTERED { F -> F.SELECTOR != SIG: DEPOSIT(UINT).SELECTOR }  WOULD PREVENT THE DEPOSIT(UINT) METHOD FROM BEING CHECKED FOR A PARTICULAR INVARIANT.
            ** CAVEAT **: WHILE SEEMINGLY USEFUL FOR REDUCING FALSE POSITIVES, FILTERING METHODS WHEN CHECKING INVARIANTS IS GENERALLY CONSIDERED * UNSOUND *.IF AN INVARIANT FAILS FOR A PARTICULAR METHOD, THE RECOMMENDED APPROACH IS USUALLY TO USE A preserved BLOCK. PRESERVED BLOCKS ALLOW FOR ADDING ASSUMPTIONS IN A MORE FINE - GRAINED MANNER, ALTHOUGH THEY ALSO REQUIRE CAREFUL JUSTIFICATION TO AVOID UNSOUNDNESS.IT IS IMPORTANT TO NOTE THAT IF A preserved BLOCK EXISTS FOR A METHOD, THAT METHOD * WILL STILL * BE VERIFIED, EVEN IF A FILTER WOULD NORMALLY EXCLUDE IT.APPLYING FILTERS TO INVARIANTS, WHILE SUPERFICIALLY REDUCING FALSE POSITIVES, PRESENTS A SEVERE RISK OF UNSOUNDNESS.THIS IS BECAUSE AN INVARIANT IS INTENDED TO HOLD UNDER * ALL * VALID OPERATIONS.EXCLUDING CERTAIN METHODS MEANS THE PROVER FAILS TO VERIFY THAT THOSE METHODS PRESERVE THE INVARIANT.IF THESE EXCLUDED METHODS CAN IN FACT BREAK THE INVARIANT, THE PROOF LOSES ITS SOUNDNESS, POTENTIALLY MISSING A REAL VULNERABILITY.THEREFORE, THIS APPROACH SHOULD BE CONSIDERED A TEMPORARY, HIGH - RISK WORKAROUND RATHER THAN A SOUND PRACTICE.THE PROVER CHECKS IF A METHOD PRESERVES AN INVARIANT BY FIRST requireING THE INVARIANT(pre-state check), EXECUTING THE METHOD, AND THEN assertING THE INVARIANT(post-state check).ADDING A require STATEMENT TO A preserved BLOCK ADDS AN EXTRA ASSUMPTION, WHICH CAN INVALIDATE THE PROOF UNLESS THERE IS A REASON TO BELIEVE THE ASSUMPTION ACTUALLY HOLDS.
THE CORE PROBLEM WITH THIS APPROACH IS THAT AN INVARIANT'S INDUCTIVE PROOF REQUIRES IT TO HOLD UNDER ALL POSSIBLE SYSTEM TRANSITIONS. IF CERTAIN TRANSITIONS ARE EXCLUDED VIA FILTERING, THE INDUCTIVE STEP IS NO LONGER COMPREHENSIVE. THE PROVER CAN NO LONGER GUARANTEE THAT THE INVARIANT STILL HOLDS AFTER THE EXECUTION OF THESE EXCLUDED METHODS. THIS CAN LEAD TO THE PROVER REPORTING "PASS" WHEN, IN FACT, A REAL COUNTEREXAMPLE EXISTS, BUT IT LIES WITHIN THE FILTERED-OUT EXECUTION PATH. THUS, WHEN AN INVARIANT FAILS, THE CORRECT PRACTICE IS TO UNDERSTAND THE REASON FOR THE FAILURE AND MODIFY THE INVARIANT OR THE CODE ACCORDINGLY, RATHER THAN SIMPLY "HIDING" THE PROBLEM THROUGH FILTERING. preserved BLOCKS OFFER AN ALTERNATIVE THAT ALLOWS ADDING ASSUMPTIONS, SUCH AS requireInvariant OF ANOTHER VERIFIED INVARIANT, BEFORE EXECUTING THE METHOD. THIS IS A SAFER APPROACH AS IT RELIES ON VERIFIED PROPERTIES RATHER THAN SIMPLY IGNORING CERTAIN BEHAVIORS. HOWEVER, EVEN ASSUMPTIONS IN preserved BLOCKS REQUIRE CAREFUL VALIDATION TO ENSURE THEY DO NOT INTRODUCE NEW UNSOUNDNESS.

## ** 5. CONCLUSION AND RECOMMENDATIONS **

    THE HAVOC MECHANISM IN THE CERTORA PROVER IS AN INDISPENSABLE COMPONENT OF FORMAL VERIFICATION, ENSURING THE SOUNDNESS OF THE VERIFICATION BY INTRODUCING NON - DETERMINISM FOR A COMPREHENSIVE EXPLORATION OF SMART CONTRACT BEHAVIOR.HOWEVER, THIS INHERENT NON - DETERMINISM, ESPECIALLY IN INITIAL STATE MODELING AND EXTERNAL CALL SUMMARIES, CAN EASILY LEAD TO THE EMERGENCE OF FALSE POSITIVE COUNTEREXAMPLES IF NOT PRECISELY CONSTRAINED.THESE FALSE POSITIVES ARE NOT ERRORS IN THE PROVER BUT ARE DIAGNOSTIC SIGNALS OF A MISMATCH BETWEEN THE VERIFICATION MODEL AND THE SMART CONTRACT'S ACTUAL OPERATIONAL ENVIRONMENT.
THE CORE OF EFFICIENTLY HANDLING havoc - INDUCED FALSE POSITIVES LIES IN * REFINING THE CERTORA VERIFICATION SPECIFICATION * TO MORE ACCURATELY REFLECT THE SYSTEM'S TRUE INVARIANTS, PRECONDITIONS, AND ENVIRONMENTAL ASSUMPTIONS. BASED ON AN IN-DEPTH ANALYSIS OF THE havoc MECHANISM AND ITS EFFECTS, THE FOLLOWING RECOMMENDATIONS ARE PROPOSED:

1. ** PRECISELY CONSTRAIN INITIAL STATES **:
    *   ** UTILIZE HAVOC ASSUMING **: FOR VARIABLES IN RULES, THE HAVOC ASSUMING CLAUSE SHOULD BE USED TO PRECISELY LIMIT THEIR INITIAL VALUE RANGE, MAKING IT CONFORM TO THE CONTRACT'S ACTUAL DEPLOYMENT OR OPERATIONAL PRECONDITIONS. THIS EFFECTIVELY INJECTS REAL-WORLD INVARIANTS INTO THE PROVER'S INITIAL STATE MODEL, THEREBY PRUNING IRRELEVANT SEARCH SPACE AND SIGNIFICANTLY REDUCING FALSE POSITIVES.
    *   ** APPLY THE PERSISTENT KEYWORD **: FOR GHOST VARIABLES THAT SHOULD REMAIN UNCHANGED DURING VERIFICATION, BE SURE TO DECLARE THEM AS PERSISTENT IN THE .CONF FILE.THIS ELIMINATES THE PROVER'S CONSERVATIVE ASSUMPTION THAT GHOST VARIABLES MIGHT BE ARBITRARILY CHANGED BY EXTERNAL INFLUENCES, AVOIDING ASSERTION FAILURES DUE TO SPURIOUS GHOST VARIABLE CHANGES.
    *   ** STRATEGICALLY USE REQUIRE STATEMENTS **: REQUIRE STATEMENTS CAN BE USED TO DEFINE PRECONDITIONS FOR RULES, THEREBY IGNORING IRRELEVANT EXECUTION PATHS.HOWEVER, THEY MUST BE USED WITH EXTREME CAUTION TO AVOID INADVERTENTLY FILTERING OUT REAL VULNERABILITIES, LEADING TO UNSOUNDNESS.FOR PRECONDITIONS BASED ON VERIFIED INVARIANTS, requireInvariant IS RECOMMENDED AS A SAFER, MORE MODULAR APPROACH.
2. ** OPTIMIZE EXTERNAL CALL SUMMARIES **:
    *   ** CHOOSE THE APPROPRIATE SUMMARY TYPE **: BASED ON THE LEVEL OF KNOWLEDGE ABOUT AN EXTERNAL CONTRACT'S BEHAVIOR, SELECT THE SUMMARY TYPE THAT BEST REFLECTS ITS SIDE EFFECTS.
    * WHEN THE EXTERNAL CONTRACT'S BEHAVIOR IS COMPLETELY UNKNOWN, ONE CAN START WITH HAVOC_ALL, BUT SHOULD ATTEMPT TO REFINE IT AS SOON AS POSSIBLE.
        * WHEN AN EXTERNAL CALL IS KNOWN TO BE NON - REENTRANT AND WILL NOT MODIFY THE CALLING CONTRACT'S STATE, PRIORITIZE USING HAVOC_ECF. IT OFFERS A BETTER BALANCE BETWEEN SOUNDNESS AND PRECISION.
            * FOR PURE VIEW FUNCTIONS, USE NONDET SUMMARIES.
        * WHEN EXTERNAL BEHAVIOR CAN BE PRECISELY MODELED, EXPRESSION SUMMARIES SHOULD BE USED TO REPLACE THE NON - DETERMINISTIC CALL.
    *   ** CONTROL ENVIRONMENTAL NON - DETERMINISM **: UTILIZE THE WITH(ENV) CLAUSE IN THE METHODS BLOCK TO PRECISELY MODEL AND CONSTRAIN THE ENVIRONMENT OF CALLS TO SUMMARIZED METHODS.FOR FUNCTIONS THAT ARE TRULY INDEPENDENT OF THE ENVIRONMENT, USE THE ENVFREE ANNOTATION TO ELIMINATE UNNECESSARY ENVIRONMENTAL NON - DETERMINISM.
3. ** TARGETEDLY SCOPE THE VERIFICATION **:
    *   ** USE FILTERED BLOCKS IN RULES **: FOR PARAMETRIC RULES, EXPLICITLY SPECIFY THE SCOPE OF APPLICABLE METHODS USING FILTERED BLOCKS.THIS NOT ONLY IMPROVES VERIFICATION EFFICIENCY BUT, MORE IMPORTANTLY, PREVENTS THE PROVER FROM REPORTING SPURIOUS COUNTEREXAMPLES ON METHODS WHERE THE PROPERTY IS NOT EXPECTED TO HOLD, THEREBY INCREASING THE SIGNAL - TO - NOISE RATIO OF THE VERIFICATION RESULTS.
    *   ** BE CAUTIOUS WITH FILTERS IN INVARIANTS **: ALTHOUGH FILTERED BLOCKS CAN ALSO BE USED IN INVARIANTS, THIS PRACTICE SHOULD BE AVOIDED AS IT CAN LEAD TO UNSOUNDNESS.AN INVARIANT SHOULD HOLD UNDER ALL VALID OPERATIONS.IF A METHOD BREAKS AN INVARIANT, THE ISSUE SHOULD BE ADDRESSED BY ADDING VERIFIED ASSUMPTIONS IN A preserved BLOCK OR BY MODIFYING THE INVARIANT / CODE ITSELF, RATHER THAN SIMPLY EXCLUDING THE METHOD.
\`\`\`

CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
According to the workflow guide above, analyze the following verification counterexample:
${content}`;
        } else if (type === 'SANITY_FAILED') {
            promptText = `分析以下汇总的CVL sanity failed规则信息，找出失败原因和修复建议：

${content}`;
        }

        // 清理提示文本中的null字节
        const cleanPromptText = promptText.replace(/\0/g, '');

        sendProgress('开始分析...', 'info');
        if (projectPath && projectPath.trim()) {
            sendProgress(`设置工作目录: ${projectPath.trim()}`, 'info');
        }

        // 分析阶段使用只读模式 + 高级推理 + 详细推理总结
        const codexArgs = [
            'exec',
            '--sandbox', 'read-only',
            '-c', 'model_reasoning_effort=high',
            '-c', 'model_reasoning_summary=detailed'
        ];
        if (projectPath && projectPath.trim()) {
            codexArgs.push('-C', projectPath.trim());
        }
        codexArgs.push(cleanPromptText);

        const codexProcess = spawn('codex', codexArgs, {
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env }
        });

        let fullOutput = '';
        let hasError = false;
        // 缓冲并在检测到 "User instructions:" 时一次性输出其之前的系统信息区块
        let preambleBuffer = '';
        let seenUserInstructions = false;
        let emittedSystemHeader = false;
        // 不再流式输出助理内容：仅输出系统头，其余等待最终结果
        let headerEmitted = false;

        codexProcess.stdout.on('data', (data) => {
            const chunk = data.toString();
            fullOutput += chunk;

            // 1) 系统头：缓冲直到出现 User instructions
            if (!seenUserInstructions) {
                preambleBuffer += chunk;
                const idx = preambleBuffer.indexOf('User instructions:');
                if (idx !== -1 && !emittedSystemHeader) {
                    // 截断到包含 "User instructions:" 的整行之前（不包含该行的时间戳等）
                    const lineStart = preambleBuffer.lastIndexOf('\n', idx);
                    const cutoff = lineStart >= 0 ? lineStart : idx;
                    const before = preambleBuffer.slice(0, cutoff).trimEnd();
                    if (before) {
                        sendProgress(before, 'output');
                    }
                    emittedSystemHeader = true;
                    seenUserInstructions = true;
                }
                return;
            }

            // 2) 已过 User instructions: 不再发送任何流式输出，等待进程结束后发送 final
            headerEmitted = true;
        });

        codexProcess.stderr.on('data', (data) => {
            const errorOutput = data.toString();
            sendProgress(errorOutput, 'error');
        });

        codexProcess.on('error', (error) => {
            hasError = true;
            if (error.code === 'ENOENT') {
                console.error('Codex CLI 未找到，请确保已安装');
                sendProgress('Codex CLI 未找到，请安装 Codex CLI', 'error');
            } else if (error.code === 'EPIPE') {
                console.log('进程管道关闭 (EPIPE) - 这通常是正常的');
            } else {
                console.error('Codex 进程错误:', error);
                sendProgress(`进程错误: ${error.message}`, 'error');
            }
        });

        codexProcess.on('close', (code) => {
            console.log(`Codex 进程结束，退出码: ${code}`);
            if (code === 0 && !hasError) {
                // 提取最终分析结果，仅在结束时输出
                const finalResult = extractCodexAnswer(fullOutput);
                sendProgress(finalResult, 'final');
                sendProgress('分析完成', 'success');
            } else {
                const errorMsg = `进程异常退出，码: ${code}`;
                console.error('Codex 执行错误:', errorMsg);
                sendProgress(errorMsg, 'error');
            }
            res.write(`data: ${JSON.stringify({ type: 'complete' })}\n\n`);
            res.end();
        });

    } catch (error) {
        console.error('分析错误:', error);
        sendProgress(`分析错误: ${error.message}`, 'error');
        res.write(`data: ${JSON.stringify({ type: 'complete' })}\n\n`);
        res.end();
    }
});


// 新增 /generate-fix-prompt 端点用于生成修复 prompt
app.post('/generate-fix-prompt', async (req, res) => {
    const { analyses } = req.body;

    if (!analyses || !Array.isArray(analyses) || analyses.length === 0) {
        return res.status(400).json({
            success: false,
            error: '缺少分析结果'
        });
    }

    console.log(`生成修复 prompt，共 ${analyses.length} 个分析结果`);

    try {
        // 标准化输入：支持字符串数组或对象数组 { text, ruleName }
        const items = analyses.map((a) => {
            if (a && typeof a === 'object') {
                // 兼容不同字段名
                const text = a.text ?? a.analysis ?? '';
                const ruleName = a.ruleName ?? a.name ?? a.rule ?? '';
                return { text: String(text || ''), ruleName: String(ruleName || '') };
            }
            return { text: String(a || ''), ruleName: '' };
        });

        // 分离和格式化分析结果（在结论头部加入规则名）
        const formattedAnalyses = items.map((item, index) => {
            const headerTitle = item.ruleName
                ? `分析结论 ${index + 1} · 规则：${item.ruleName}`
                : `分析结论 ${index + 1}`;
            return `╔═══════════════════════════════════════════════════════════════════════════════════╗
║ ${headerTitle}


${item.text}

║                                 分析结论 ${index + 1} 结束                                ║
╚═══════════════════════════════════════════════════════════════════════════════════╝`;
        });

        const promptText = `Your task is to fix the issues discovered in the ${analyses.length} analysis results below. Please address them in order. Each result is clearly separated in a block, identified by its rule name in the header.

Before you start, carefully read the working guidelines in the YAML file:
\`\`\`yaml 
# ** STRATEGIES FOR HANDLING UNREACHABLE INITIAL STATE PROBLEMS AND FALSE POSITIVES CAUSED BY HAVOC IN CERTORA FORMAL VERIFICATION **

## ** 1. OVERVIEW **

                IN FORMAL VERIFICATION, THE CERTORA PROVER'S DEFAULT NON-DETERMINISTIC MODELING OF INITIAL STATES AND EXTERNAL INTERACTIONS (THROUGH THE HAVOC MECHANISM) CAN LEAD TO THE EMERGENCE OF SPURIOUS COUNTEREXAMPLES (FALSE POSITIVES). THESE FALSE POSITIVES ARISE BECAUSE THE VERIFICATION TOOL EXPLORES STATES AND BEHAVIORS THAT ARE UNREACHABLE OR IRRELEVANT IN THE ACTUAL SYSTEM. THIS GUIDE WILL DELVE INTO THE PRINCIPLES OF THE HAVOC MECHANISM AND ITS APPLICATION IN THE CERTORA PROVER, ANALYZING HOW IT LEADS TO FALSE POSITIVES ORIGINATING FROM UNREACHABLE INITIAL STATE PROBLEMS. THE GUIDE WILL DETAIL KEY STRATEGIES FOR MITIGATING THESE ISSUES, INCLUDING PRECISELY CONSTRAINING INITIAL STATES, OPTIMIZING EXTERNAL CALL SUMMARIES, AND TARGETEDLY SCOPING THE VERIFICATION. THE GOAL IS TO ENHANCE THE ACCURACY AND EFFICIENCY OF VERIFICATION RESULTS, THEREBY BOOSTING CONFIDENCE IN THE SECURITY OF SMART CONTRACTS.

## ** 2. INTRODUCTION TO NON - DETERMINISM AND THE HAVOC MECHANISM IN CERTORA PROVER **

                THIS SECTION WILL ESTABLISH A FUNDAMENTAL UNDERSTANDING OF NON - DETERMINISM IN THE CERTORA PROVER AND CLARIFY THE CRITICAL ROLE OF THE HAVOC MECHANISM.

### ** 2.1.THE ROLE OF HAVOC IN FORMAL VERIFICATION **

                THE CERTORA PROVER, AS AN ADVANCED FORMAL VERIFICATION TOOL, CAN TRANSFORM SMART CONTRACT BYTECODE AND USER - DEFINED PROPERTIES INTO MATHEMATICAL FORMULAS FOR ANALYSIS BY AN SMT SOLVER.THIS PROCESS ALGORITHMICALLY EXPLORES THE SYSTEM'S STATE SPACE TO VERIFY EXPECTED BEHAVIORAL PROPERTIES.
            THE HAVOC KEYWORD IN THE CERTORA VERIFICATION LANGUAGE(CVL) PLAYS A CENTRAL ROLE IN MODELING UNCERTAINTY AND NON - DETERMINISM.IT ALLOWS VARIABLES TO ASSUME ARBITRARY, NON - DETERMINISTIC VALUES, WHICH IS CRUCIAL FOR ACHIEVING COMPREHENSIVE COVERAGE OF THE INPUT SPACE AND CONSIDERING ALL POSSIBLE CALL CONTEXTS.
THIS INHERENT NON - DETERMINISM OF THE HAVOC MECHANISM IS NOT A FLAW IN THE CERTORA PROVER BUT AN INTENTIONAL DESIGN CHOICE TO ENSURE THE * SOUNDNESS * OF THE FORMAL VERIFICATION.BY EXPLORING ALL LOGICALLY POSSIBLE BEHAVIORS, INCLUDING THOSE NOT EXPLICITLY MODELED OR CONSTRAINED, THE PROVER AIMS TO AVOID MISSING GENUINE VULNERABILITIES.THEREFORE, THE CHALLENGE FOR THE USER IS TO * CONSTRAIN * THIS BROAD NON - DETERMINISM TO ONLY * RELEVANT * AND * REACHABLE * BEHAVIORS TO AVOID GENERATING SPURIOUS(FALSE POSITIVE) COUNTEREXAMPLES.
HAVOC IS DESCRIBED AS ASSIGNING ARBITRARY VALUES AND MODELING UNCERTAINTY, WHICH IS KEY TO "COMPLETE COVERAGE".THIS MECHANISM, WHILE POWERFUL, IS A DIRECT CAUSE OF "UNREACHABLE INITIAL STATES" AND "FALSE POSITIVES." THE CERTORA PROVER AIMS TO AUTOMATICALLY LOCATE CRITICAL VULNERABILITIES THAT EVEN THE BEST AUDITORS MIGHT MISS AND "NEVER MAKES A REASONING ERROR".
THE PURPOSE OF HAVOC IS TO CREATE AN * OVER - APPROXIMATION * OF THE SYSTEM'S BEHAVIOR. AN OVER-APPROXIMATION IS *SOUND* BECAUSE IT ENCOMPASSES ALL POSSIBLE REAL BEHAVIORS, GUARANTEEING THAT IF A BUG EXISTS, THE PROVER WILL FIND IT. HOWEVER, THIS OVER-APPROXIMATION MAY ALSO CONTAIN BEHAVIORS THAT ARE *LOGICALLY POSSIBLE BUT PRACTICALLY IMPOSSIBLE* WITHIN THE OPERATIONAL CONTEXT OF THE ACTUAL SYSTEM. WHEN THESE IMPOSSIBLE BEHAVIORS LEAD TO A PROPERTY VIOLATION, THEY MANIFEST AS *SPURIOUS COUNTEREXAMPLES* (FALSE POSITIVES). THIS TRADEOFF IS FUNDAMENTAL: SOUNDNESS (NOT MISSING BUGS) OFTEN COMES WITH THE RISK OF FALSE POSITIVES IF THE MODEL IS NOT PRECISE ENOUGH. THUS, A "FALSE POSITIVE" IS NOT AN ERROR IN THE PROVER'S LOGIC BUT A VALUABLE SIGNAL THAT THE USER'S *SPECIFICATION* OF THE SYSTEM'S ENVIRONMENT OR UNVERIFIED COMPONENTS IS TOO LOOSE.THE SOLUTION IS NOT TO DISABLE HAVOC, BUT TO REFINE ITS SCOPE BY ADDING MORE PRECISE CONSTRAINTS.

### ** 2.2.INITIAL STATE MODELING AND UNSPECIFIED VARIABLES **

                A KEY ASPECT OF CERTORA'S NON-DETERMINISM LIES IN ITS MODELING OF THE INITIAL STATE. AT THE START OF A VERIFICATION, THE STORAGE STATE IS UNSPECIFIED, AND ALL VARIABLES ARE HAVOCED BY DEFAULT. THIS MEANS THE PROVER CONSIDERS ALL POSSIBLE INITIAL VALUES FOR VARIABLES UNLESS EXPLICITLY CONSTRAINED IN THE SPECIFICATION.
THIS DEFAULT HAVOC BEHAVIOR IS A PRIMARY CAUSE OF FALSE POSITIVES.THE PROVER MAY GENERATE COUNTEREXAMPLES FROM STATES THAT ARE LOGICALLY POSSIBLE BUT DEMONSTRABLY IMPOSSIBLE OR IRRELEVANT IN THE CONTEXT OF THE ACTUAL CONTRACT'S DEPLOYMENT OR OPERATION.
THE "UNREACHABLE INITIAL STATE" PROBLEM IS A DIRECT CONSEQUENCE OF THE CERTORA PROVER'S "MAXIMAL NON-DETERMINISM" APPROACH TO INITIAL CONDITIONS. THIS CONSERVATIVE DEFAULT ENSURES SOUNDNESS BY CONSIDERING THE WIDEST POSSIBLE RANGE OF STARTING POINTS, BUT IT PLACES THE ONUS ON THE USER TO EXPLICITLY INTERVENE AND NARROW THE VERIFICATION SCOPE TO THE SYSTEM'S * VALID * INITIAL STATES.THE INITIAL STATE IS UNSPECIFIED, AND VARIABLES ARE HAVOCED BY DEFAULT.IF AN INITIAL STATE LEADS TO A COUNTEREXAMPLE, IT DOES NOT NECESSARILY INDICATE A VULNERABILITY UNLESS IT CAN BE PROVEN THAT THE INITIAL STATE WAS NOT OVER - APPROXIMATED.
HAVOC IS EXPLICITLY DEFINED AS "ASSIGNING ARBITRARY, NON-DETERMINISTIC VALUES TO VARIABLES... AT THE START OF A VERIFICATION, ALL VARIABLES ARE HAVOCED TO SIMULATE AN UNKNOWN INITIAL STATE".THIS IS A "PESSIMISTIC" APPROACH.THE DEFAULT SETTING IS DESIGNED FOR MAXIMUM COVERAGE AND SOUNDNESS, ASSUMING * ANY * POSSIBLE INITIAL STATE TO ENSURE NO GENUINE VULNERABILITIES ARE MISSED DUE TO UNCONSIDERED STARTING POINTS.WHILE SOUND, THIS OFTEN GENERATES COUNTEREXAMPLES FROM STATES THAT ARE * LOGICALLY POSSIBLE * IN A GENERIC MATHEMATICAL MODEL BUT * IMPOSSIBLE * IN THE ACTUAL OPERATION OF THE SPECIFIC CONTRACT OR PROTOCOL BEING VERIFIED.THIS HIGHLIGHTS A CRITICAL GAP: THE DISCREPANCY BETWEEN THE PROVER'S GENERIC MODEL AND THE REAL-WORLD INVARIANTS AND DEPLOYMENT CONDITIONS OF A SPECIFIC SYSTEM. TO MAKE THE VERIFICATION RESULTS MEANINGFUL, THE USER MUST EXPLICITLY ENCODE THEIR ASSUMPTIONS ABOUT *VALID* INITIAL STATES INTO THE SPECIFICATION. THIS IS WHERE SPECIFIC CVL CONSTRUCTS LIKE REQUIRE INVARIANT AND HAVOC ASSUMING BECOME INDISPENSABLE FOR PRUNING THE SEARCH SPACE AND ELIMINATING SPURIOUS COUNTEREXAMPLES.

                ** SUMMARY DECLARATIONS ** ARE USED TO REPLACE CALLS TO CERTAIN CONTRACT METHODS, ESPECIALLY WHEN THE PRECISE CODE OF AN EXTERNAL CONTRACT IS UNAVAILABLE, OR TO SIMPLIFY COMPLEX CODE TO PREVENT TIMEOUTS.

*   ** HAVOC_ALL **: THIS IS THE MOST CONSERVATIVE SUMMARY TYPE.WHEN APPLIED, THE PROVER ASSUMES THE CALLED FUNCTION CAN HAVE ARBITRARY SIDE EFFECTS ON THE STORAGE OF * ANY * CONTRACT(INCLUDING THE CALLING CONTRACT) AND CAN RETURN AN ARBITRARY VALUE.WHILE ALWAYS SOUND, IT IS OFTEN TOO PESSIMISTIC IN PRACTICE AS IT "ERASES ALL THE KNOWLEDGE THE PROVER HAD ABOUT THE STATE OF THE CONTRACT BEFORE THE CALL"¹⁰. THIS MAXIMAL NON - DETERMINISM CAN LEAD TO A LARGE NUMBER OF FALSE POSITIVES.
*   ** HAVOC_ECF **: THIS SUMMARY TYPE PROVIDES A MORE REFINED APPROXIMATION THAN HAVOC_ALL.IT ASSUMES THE CALLED METHOD IS * NON - REENTRANT * AND CAN HAVE ARBITRARY EFFECTS ON CONTRACTS * OTHER THAN * THE ONE BEING VERIFIED.IMPORTANTLY, IT ASSUMES THE STATE AND ETH BALANCE OF THE CURRENT(CALLING) CONTRACT(APART FROM ANY VALUE TRANSFERRED BY THE METHOD CALL ITSELF) * DO NOT * CHANGE¹⁰. THIS PROVIDES A USEFUL MIDDLE GROUND, REDUCING FALSE POSITIVES COMPARED TO HAVOC_ALL WHILE MAINTAINING A HIGH DEGREE OF NON - DETERMINISM FOR EXTERNAL INTERACTIONS.
*   ** NONDET(VIEW SUMMARY) **: THESE ARE USED FOR VIEW FUNCTIONS, ASSUMING THEY HAVE NO SIDE EFFECTS AND SIMPLY REPLACE THE CALL WITH A NON - DETERMINISTIC VALUE.THEY ARE SOUND FOR VIEW FUNCTIONS¹⁰.
*   ** EXPRESSION SUMMARIES **: THESE REPLACE A CALL TO A SUMMARIZED METHOD WITH A CVL EXPRESSION, TYPICALLY A CALL TO A CVL FUNCTION OR GHOST AXIOM.THEY REQUIRE AN EXPECT CLAUSE TO ACCOUNT FOR THE RETURN VALUE¹⁰. THIS ALLOWS FOR PRECISE, DETERMINISTIC MODELING OF AN EXTERNAL CALL WHEN ITS BEHAVIOR IS WELL UNDERSTOOD.
*   ** AUTO SUMMARIES **: THESE ARE THE DEFAULT SUMMARIES FOR UNRESOLVED CALLS¹⁰.
*   ** DISPATCHER SUMMARIES **: THESE ASSUME THE RECEIVER OF A METHOD CALL CAN BE ANY CONTRACT THAT IMPLEMENTS THE METHOD.THEY CAN SIGNIFICANTLY CONTRIBUTE TO THE "PATH EXPLOSION PROBLEM" DUE TO THE LARGE NUMBER OF POTENTIAL CALL TARGETS, ESPECIALLY IN SEQUENTIAL CONTROL FLOW¹⁰. REPLACING A DISPATCHER SUMMARY WITH AN AUTO SUMMARY CAN SIGNIFICANTLY REDUCE THE PATH COUNT AND PREVENT TIMEOUTS¹¹.

THE CHOICE OF HAVOC SUMMARY TYPE REPRESENTS A CRITICAL TRADEOFF BETWEEN SOUNDNESS, PRECISION, AND VERIFICATION PERFORMANCE.HAVOC_ALL GUARANTEES SOUNDNESS BUT MAY INTRODUCE NUMEROUS FALSE POSITIVES AND EXACERBATE STATE EXPLOSION.MORE PRECISE SUMMARIES LIKE HAVOC_ECF AND NONDET OFFER HIGHER PRECISION BY MAKING STRONGER ASSUMPTIONS(E.G., NON - REENTRANCY, NO SIDE EFFECTS), WHICH CAN SIGNIFICANTLY REDUCE FALSE POSITIVES AND IMPROVE PERFORMANCE.HOWEVER, THESE MORE PRECISE SUMMARIES REQUIRE CAREFUL CONSIDERATION AND VALIDATION TO ENSURE THEIR UNDERLYING ASSUMPTIONS ACCURATELY REFLECT THE BEHAVIOR OF THE EXTERNAL CODE, AS AN UNSOUND ASSUMPTION COULD LEAD TO MISSED VULNERABILITIES.
HAVOC SUMMARY TYPES HAVE DIFFERENT EFFECTS ON STATE AND RETURN VALUES¹⁰.
HAVOC_ALL IS "ALWAYS SOUND" BUT "OVERLY PESSIMISTIC" AND "ERASES ALL KNOWLEDGE"¹⁰. THIS INDICATES MAXIMUM NON - DETERMINISM.
HAVOC_ECF IS A "USEFUL MIDDLE GROUND"¹⁰, IMPLYING REDUCED NON - DETERMINISM.
DISPATCHER CAN LEAD TO "PATH EXPLOSION"¹¹, INDICATING A PERFORMANCE COST.SUMMARIES ARE OFTEN HELPFUL TO "SIMPLIFY THE VERIFIED CODE TO AVOID TIMEOUTS"¹⁰. A PROOF ON AN OVER - APPROXIMATED PROGRAM IS SOUND, BUT SPURIOUS COUNTEREXAMPLES MAY ARISE FROM BEHAVIORS NOT EXHIBITED BY THE ORIGINAL CODE⁷.

*   ** HAVOC_ALL(MOST OVER - APPROXIMATED) **: INTRODUCES THE HIGHEST DEGREE OF NON - DETERMINISM FOR EXTERNAL CALLS.WHILE IT MAXIMIZES SOUNDNESS(BY NOT MISSING ANY POTENTIAL SIDE EFFECTS), THIS BROADNESS MEANS IT WILL FIND COUNTEREXAMPLES IN SCENARIOS THAT ARE IMPRACTICAL OR IMPOSSIBLE, LEADING TO A HIGH RATE OF FALSE POSITIVES.THE LARGER NON - DETERMINISTIC STATE SPACE ALSO NEGATIVELY IMPACTS PERFORMANCE.
*   ** HAVOC_ECF(LESS OVER - APPROXIMATED) **: REDUCES NON - DETERMINISM BY ASSUMING NON - REENTRANCY AND LIMITED IMPACT ON THE CALLING CONTRACT'S STATE. THIS *CONSTRAINS* THE POSSIBLE SIDE EFFECTS, THEREBY REDUCING FALSE POSITIVES AND IMPROVING PERFORMANCE. HOWEVER, THIS INTRODUCES AN *ASSUMPTION* ABOUT THE EXTERNAL CODE'S BEHAVIOR(NON - REENTRANT, LIMITED SELF - MODIFICATION) THAT * MUST BE VALID *.IF THIS ASSUMPTION IS VIOLATED IN THE ACTUAL SYSTEM, THE PROOF BECOMES * UNSOUND *.
*   ** NONDET(EVEN LESS OVER - APPROXIMATION FOR VIEW FUNCTIONS) **: ASSUMES NO SIDE EFFECTS AT ALL.THIS FURTHER REDUCES NON - DETERMINISM, LEADING TO FEWER FALSE POSITIVES AND BETTER PERFORMANCE, BUT RELIES ON A STRONGER ASSUMPTION ABOUT THE EXTERNAL FUNCTION'S PURITY.
                *   ** DISPATCHER(COMPLEX, HIGH PATH COUNT) **: WHILE USEFUL FOR MODELING DYNAMIC DISPATCH, ITS INHERENT COMPLEXITY AND THE NEED TO EXPLORE MULTIPLE POTENTIAL CALL TARGETS CAN LEAD TO STATE EXPLOSION AND TIMEOUTS.THESE PERFORMANCE ISSUES CAN INDIRECTLY CONTRIBUTE TO "FALSE POSITIVES" IF THE PROVER FAILS TO COMPLETE VERIFICATION OR SIMPLY HINDER EFFECTIVE VERIFICATION.

                    THEREFORE, SELECTING THE APPROPRIATE SUMMARY IS A CRITICAL DESIGN DECISION IN CVL.IT REQUIRES A DEEP UNDERSTANDING OF THE EXTERNAL SYSTEM'S BEHAVIOR AND A CAREFUL EVALUATION OF THE TRADEOFF BETWEEN DESIRED PRECISION (TO REDUCE FALSE POSITIVES) AND THE RISK OF INTRODUCING UNSOUND ASSUMPTIONS. OVER-SUMMARIZING (E.G., USING HAVOC_ALL WHEN HAVOC_ECF IS SUFFICIENT) LEADS TO UNNECESSARY FALSE POSITIVES, WHILE UNDER-SUMMARIZING (E.G., NOT SUMMARIZING COMPLEX EXTERNAL CALLS) LEADS TO PERFORMANCE BOTTLENECKS.
                        ** TABLE 1: COMPARISON OF CERTORA HAVOC SUMMARY TYPES **

| SUMMARY TYPE | DESCRIPTION | KEY ASSUMPTIONS | EFFECT ON CALLING CONTRACT STATE | EFFECT ON OTHER CONTRACT STATES | EFFECT ON ETH BALANCE | RETURN VALUE HANDLING | SOUNDNESS IMPACT | TYPICAL USE CASE | FALSE POSITIVE / PERFORMANCE POTENTIAL |
| : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- | : --- |
| HAVOC_ALL | MOST CONSERVATIVE SUMMARY, ALLOWS ARBITRARY SIDE EFFECTS. | NO SPECIFIC ASSUMPTIONS. | ARBITRARILY CHANGED. | ARBITRARILY CHANGED. | ARBITRARILY CHANGED. | ARBITRARY VALUE. | ALWAYS SOUND. | EXTERNAL CODE IS UNKNOWN OR HIGHLY COMPLEX. | HIGH FALSE POSITIVES, POOR PERFORMANCE. |
| HAVOC_ECF | ASSUMES NON - REENTRANCY, LIMITS IMPACT ON THE CALLING CONTRACT. | NON - REENTRANT. | UNCHANGED(EXCEPT FOR EXPLICIT TRANSFERS). | ARBITRARILY CHANGED. | NOT DECREASED(EXCEPT FOR EXPLICIT TRANSFERS). | ARBITRARY VALUE. | SOUND(IF ASSUMPTION HOLDS). | EXTERNAL CODE IS KNOWN TO BE NON - REENTRANT. | MEDIUM FALSE POSITIVES, MEDIUM PERFORMANCE. |
| NONDET | USED FOR VIEW FUNCTIONS, ASSUMES NO SIDE EFFECTS. | NO SIDE EFFECTS. | NO CHANGE. | NO CHANGE. | NO CHANGE. | NON - DETERMINISTIC VALUE. | SOUND(IF VIEW FUNCTION IS PURE). | EXTERNAL VIEW FUNCTIONS. | LOW FALSE POSITIVES, GOOD PERFORMANCE. |
| AUTO | DEFAULT SUMMARY FOR UNRESOLVED CALLS. | PROVER INFERS AUTOMATICALLY. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON INFERENCE. | DEPENDS ON ACCURACY OF INFERENCE. | DEFAULT BEHAVIOR, OR AS DISPATCHER ALTERNATIVE. | VARIABLE FALSE POSITIVES / PERFORMANCE. |
| DISPATCHER | RECEIVER CAN BE ANY CONTRACT IMPLEMENTING THE METHOD. | DYNAMIC DISPATCH. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | DEPENDS ON ACTUAL CALL. | SOUND(IF ALL TARGETS ARE EXPLORED). | INTERFACE CALLS, POLYMORPHISM. | HIGH PATH COUNT, PRONE TO TIMEOUTS. |
| EXPRESSION SUMMARY | REPLACES CALL WITH CVL EXPRESSION(FUNCTION / GHOST AXIOM). | EXTERNAL BEHAVIOR CAN BE PRECISELY MODELED. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | DEFINED BY EXPRESSION. | SOUND(IF EXPRESSION IS ACCURATE). | EXTERNAL BEHAVIOR IS KNOWN AND DETERMINISTIC. | LOW FALSE POSITIVES, GOOD PERFORMANCE. |

### ** 2.3.WHAT CONSTITUTES AN UNREACHABLE STATE IN FORMAL VERIFICATION **

                IN THE CONTEXT OF FORMAL VERIFICATION, AN UNREACHABLE STATE REFERS TO A SYSTEM CONFIGURATION THAT, WHILE MATHEMATICALLY POSSIBLE GIVEN THE DATA TYPES AND VARIABLE RANGES, CANNOT BE REACHED THROUGH ANY VALID SEQUENCE OF OPERATIONS OR INPUTS STARTING FROM A LEGITIMATE, PRACTICAL INITIAL STATE.THESE STATES ARE "NEITHER VALID NOR INVALID, BUT ONE THE DESIGN CAN NEVER REACH".

IT IS CRUCIAL TO DISTINGUISH UNREACHABLE STATES FROM "INVALID STATES." AN INVALID STATE REPRESENTS AN ERRONEOUS OR UNDESIRABLE CONFIGURATION THAT THE SYSTEM SHOULD NEVER ENTER.THE CORE PROBLEM DISCUSSED IN THIS REPORT ARISES WHEN A FORMAL VERIFIER, DUE TO ITS COMPREHENSIVE EXPLORATION, TREATS THESE PRACTICALLY UNREACHABLE STATES AS VALID STARTING POINTS FOR VERIFICATION, THEREBY LEADING TO SPURIOUS FINDINGS.

IN SMART CONTRACTS, THE FOLLOWING ARE TYPICAL EXAMPLES OF UNREACHABLE STATES:

ASSUME A TOKEN CONTRACT WHERE totalSupply IS ALWAYS EQUAL TO THE SUM OF ALL INDIVIDUAL USER BALANCES.AN INITIAL STATE WHERE, FOR EXAMPLE, totalSupply IS A NEGATIVE NUMBER OR IS LESS THAN THE PRE - MINTED USER BALANCES(IF THE CONSTRUCTOR ENFORCES CORRECTNESS) IS MATHEMATICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE.

IN AN ERC20 IMPLEMENTATION,  unchecked  ARITHMETIC MIGHT BE USED FOR INTERNAL BALANCE UPDATES, RELYING ON HIGHER - LEVEL LOGIC(LIKE totalSupply  LIMITS) TO PREVENT OVERFLOWS.HOWEVER, IF HAVOC  INTRODUCES AN ARBITRARILY LARGE BALANCE FOR A USER, AN OVERFLOW MIGHT OCCUR IN THESE unchecked OPERATIONS, EVEN THOUGH SUCH A LARGE BALANCE IS IMPOSSIBLE IN THE ACTUAL USE OF THE CONTRACT.

A VARIABLE IS GUARANTEED BY THE CONTRACT'S CONSTRUCTOR OR DEPLOYMENT SCRIPT TO BE INITIALIZED TO A SPECIFIC VALUE BUT IS HAVOCED BY THE PROVER TO AN ARBITRARY, UNINITIALIZED VALUE.

A SIGNIFICANT CHALLENGE IS EXPLICITLY STATED: "THE CHALLENGE FOR THE DESIGNER IN THE INDUCTIVE STEP IS THAT YOU HAVE TO DECLARE EVERY UNREACHABLE STATE AS INVALID, OR IT MIGHT START PROCESSING FROM AN UNREACHABLE STATE YOU DIDN'T ANTICIPATE." IT REITERATES THIS POINT: "ANY STATE THAT IS NOT DECLARED AS INVALID CAN BE A STARTING POINT FOR THE INDUCTION—EVEN IF THAT STATE IS UNREACHABLE." THIS REVEALS THE "DESIGNER'S BURDEN" SPECIFIC TO FORMAL VERIFICATION.UNLIKE TRADITIONAL TESTING, WHICH IMPLICITLY FOCUSES ON REACHABLE STATES, FORMAL VERIFICATION BY DEFAULT EXPLORES THE ENTIRE MATHEMATICALLY DEFINED STATE SPACE.IF THE SPECIFICATION DOES NOT EXPLICITLY AND EXHAUSTIVELY CONSTRAIN THE INITIAL STATE OR DECLARE CERTAIN STATES INVALID, THE PROVER WILL CONSIDER THEM.THIS SHIFTS THE TASK FROM MERELY "FINDING BUGS IN REACHABLE STATES" TO THE MORE CHALLENGING "PRECISELY DEFINING THE SET OF ALL REACHABLE AND VALID STATES." THIS CONCEPTUAL SHIFT IS OFTEN A SIGNIFICANT HURDLE FOR DEVELOPERS ACCUSTOMED TO EMPIRICAL TESTING METHODOLOGIES.

### ** 2.4.CERTORA'S OVER-APPROXIMATION PRINCIPLE: WHY UNREACHABLE STATES ARE CONSIDERED**

THE DESIGN OF THE CERTORA PROVER INHERENTLY ADOPTS THE PRINCIPLE OF "OVER-APPROXIMATION." IT "ASSUMES ALL POSSIBLE INPUT VALUES AS A STARTING STATE, EVEN THOSE THAT CAN NEVER BE REACHED".THIS STRATEGY IS A DELIBERATE CHOICE TO ENSURE SOUNDNESS—GUARANTEEING THAT THE PROVER "WILL NOT ALLOW AN UNTRUE RULE TO PASS VERIFICATION" AND "GUARANTEES TO REPORT ANY VIOLATION OF THE RULE".THIS APPROACH PRIORITIZES AVOIDING "FALSE NEGATIVES"(MISSING ACTUAL BUGS) OVER THE STRICT PRECISION OF ALL REPORTED COUNTEREXAMPLES.

                CERTORA'S CORE MECHANISM INVOLVES TRANSLATING THE CONTRACT CODE AND CVL RULES INTO LOGICAL FORMULAS, WHICH ARE THEN FED TO AN SMT SOLVER. THESE SOLVERS ARE DESIGNED TO EXPLORE AN "INFINITE SPACE OF POSSIBLE EXECUTIONS" TO FIND ANY SCENARIO THAT VIOLATES THE SPECIFIED PROPERTIES. WITHOUT EXPLICIT CONSTRAINTS FROM THE USER, THE SMT SOLVER WILL OPERATE BASED ON THE BROADEST MATHEMATICAL INTERPRETATION OF THE VARIABLES, WHICH NATURALLY INCLUDES STATES THAT ARE THEORETICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE IN THE ACTUAL SYSTEM.

COMPARED TO FUZZING / TRADITIONAL TESTING, WHICH STARTS FROM CONCRETE PROGRAM STATES AND MAY STRUGGLE TO FIND THE COMPLEX, CORRELATED PARAMETER VALUES NEEDED TO REACH DEEP, PROBLEMATIC STATES, CERTORA'S SYMBOLIC APPROACH EXCELS IN THIS REGARD. HOWEVER, THIS ABILITY TO EXHAUSTIVELY EXPLORE THE STATE SPACE INHERENTLY COMES WITH THE CAVEAT THAT IT MAY EXPLORE AND REPORT ON STATES THAT MAY NOT BE PRACTICALLY REACHABLE IN A DEPLOYED ENVIRONMENT.

CERTORA'S OVER-APPROXIMATION IS A DESIGN CHOICE TO ENSURE SOUNDNESS, MEANING IT PRIORITIZES FINDING ANY POSSIBLE VIOLATION, EVEN IF IT OCCURS IN AN UNREACHABLE STATE. THIS CONTRASTS WITH THE USER'S IMPLICIT EXPECTATION THAT THE TOOL SHOULD ONLY FIND VIOLATIONS IN STATES REACHABLE DURING THE ACTUAL EXECUTION OF THE CONTRACT.THE PROBLEM STATEMENT ITSELF(FALSE POSITIVES FROM UNREACHABLE INITIAL STATES) HIGHLIGHTS THIS TENSION.IT SIGNIFIES A FUNDAMENTAL PHILOSOPHICAL DIFFERENCE BETWEEN THE GOALS OF FORMAL VERIFICATION AND TRADITIONAL TESTING.THE QUESTION THE CERTORA PROVER ANSWERS IN ITS DEFAULT MODE IS: "GIVEN ANY MATHEMATICALLY POSSIBLE INITIAL STATE AND EXECUTION PATH, DOES THIS PROPERTY ALWAYS HOLD?" HOWEVER, THE USER IS TYPICALLY MORE INTERESTED IN: "GIVEN ONLY THE INITIAL STATES AND EXECUTION PATHS THAT ARE ACTUALLY REACHABLE IN MY DEPLOYED SYSTEM, DOES THIS PROPERTY HOLD?" "FALSE POSITIVES" ARISE PRECISELY FROM THIS GAP BETWEEN THEORETICAL POSSIBILITY(EXHAUSTIVELY EXPLORED BY HAVOC  AND OVER - APPROXIMATION) AND PRACTICAL REACHABILITY.EFFECTIVELY BRIDGING THIS GAP REQUIRES THE USER TO EXPLICITLY AND PRECISELY DEFINE THE "REACHABLE" STATE SPACE THROUGH A WELL - CRAFTED SPECIFICATION.

### ** 2.5.THE CONFLUENCE: HAVOC AND UNREACHABLE STATES **

                THE HAVOC  MECHANISM DIRECTLY ENABLES THE PROVER TO EXPLORE THESE UNREACHABLE INITIAL STATES.BY ASSIGNING "ARBITRARY, NON-DETERMINISTIC VALUES" TO ALL VARIABLES AT THE START OF A RULE,  HAVOC  CAN POPULATE THE CONTRACT STATE WITH VALUES THAT WOULD NEVER OCCUR IN A REAL - WORLD SCENARIO WITHOUT PROPER CONSTRAINTS.THIS MEANS THE PROVER WILL DILIGENTLY ATTEMPT TO FIND COUNTEREXAMPLES WITHIN THESE UNREALISTIC CONFIGURATIONS.

A COMMON SCENARIO ARISES IN CONJUNCTION WITH SOLIDITY'S  UNCHECKED  ARITHMETIC. ALTHOUGH  UNCHECKED  BLOCKS ARE OFTEN USED FOR GAS OPTIMIZATION AND ARE SAFE WHEN HIGHER-LEVEL INVARIANTS ARE MAINTAINED BY THE CONTRACT'S LOGIC(E.G.,  totalSupply  NOT EXCEEDING type(uint256).max ),  HAVOC  CAN INTRODUCE ARBITRARILY LARGE TOKEN BALANCES, LEADING TO OVERFLOWS IN THESE  UNCHECKED  OPERATIONS.THIS RESULTS IN A REPORTED VIOLATION(A FALSE POSITIVE), EVEN THOUGH SUCH AN OVERFLOW IS IMPOSSIBLE UNDER NORMAL, REACHABLE CONDITIONS.

THE MOCKASSETA EXAMPLE EXPLICITLY ADDRESSES THIS PROBLEM BY MODIFYING THE ERC20 IMPLEMENTATION TO STRICTLY ADHERE TO SAFE ARITHMETIC, THEREBY PREVENTING HAVOC  - INDUCED OVERFLOWS DURING VERIFICATION.

                WHEN  HAVOC  POPULATES AN UNREACHABLE STATE WITH ARBITRARY VALUES, AND A PROPERTY(E.G., AN ASSERT  STATEMENT) IS SUBSEQUENTLY VIOLATED IN ONE OF THESE STATES, THE PROVER GENERATES A "SPURIOUS COUNTEREXAMPLE".THESE COUNTEREXAMPLES ARE MATHEMATICALLY VALID WITHIN THE OVER - APPROXIMATED MODEL BUT DO NOT CORRESPOND TO ACTUAL, EXPLOITABLE VULNERABILITIES IN THE DEPLOYED CONTRACT.THEY ARE "FALSE ALARMS" THAT CONSUME AUDIT RESOURCES.

THE BROAD NON - DETERMINISM OF HAVOC , COMBINED WITH THE PROVER'S OVER-APPROXIMATION, MEANS THAT IF THE INITIAL STATE IS NOT SUFFICIENTLY CONSTRAINED IN THE USER'S SPECIFICATION, THE PROVER WILL BE OPERATING ON "GARBAGE"—I.E., STATES THAT ARE MATHEMATICALLY POSSIBLE BUT PRACTICALLY UNREACHABLE.IT IS EXPLICITLY STATED: "EVEN IF SUCH A STATE IS UNREACHABLE THROUGH ANY PATH OF ACTIONS BY ANY USER, THE TOOL STILL CONSIDERS THIS INITIAL STATE A VALID ONE." THIS UNDERSCORES THE CRITICAL IMPORTANCE OF THE QUALITY AND PRECISION OF THE SPECIFICATION.IF THE USER FAILS TO ACCURATELY MODEL THE CONTRACT'S ACTUAL INITIAL CONDITIONS AND ENVIRONMENTAL CONSTRAINTS, CERTORA'S POWERFUL SYMBOLIC EXECUTION CAPABILITIES WILL FAITHFULLY EXPLORE THESE UNREALISTIC SCENARIOS, LEADING TO FALSE POSITIVES.IN ESSENCE, IT IS THE RESPONSIBILITY OF THE SPECIFICATION WRITER TO ENSURE THAT THE "INPUT" TO THE VERIFICATION(THE DEFINED AND CONSTRAINED STATE SPACE) IS "CLEAN" AND RELEVANT TO THE SMART CONTRACT'S ACTUAL OPERATIONAL CONTEXT.

## ** 3. UNDERSTANDING FALSE POSITIVES FROM UNREACHABLE INITIAL STATES **

                THIS SECTION WILL DELVE INTO THE MECHANISM BY WHICH  HAVOC  LEADS TO SPURIOUS COUNTEREXAMPLES AND PROVIDE GUIDANCE ON INTERPRETING THE CALL TRACE.

### ** 3.1.HOW HAVOC  LEADS TO SPURIOUS COUNTEREXAMPLES **

                THE CERTORA PROVER'S DEFAULT  HAVOC  BEHAVIOR FOR UNASSIGNED VARIABLES AND INITIAL STATES MEANS IT EXPLORES *ALL* LOGICALLY POSSIBLE VALUES AND CONFIGURATIONS, EVEN THOSE THAT ARE IMPOSSIBLE OR IRRELEVANT IN THE REAL-WORLD CONTEXT OF THE CONTRACT'S DEPLOYMENT OR OPERATION.
WHEN THE PROVER IDENTIFIES A COUNTEREXAMPLE, IT PRESENTS A "MODEL"—A SPECIFIC ASSIGNMENT TO ALL CVL VARIABLES AND CONTRACT STORAGE—THAT CAUSES AN  ASSERT  STATEMENT TO FAIL.IF THE INITIAL STATE OF THIS MODEL, OR AN INTERMEDIATE STATE REACHED VIA A HAVOCED EXTERNAL CALL, IS ONE THAT THE ACTUAL CONTRACT COULD NEVER REALISTICALLY BE IN(CONTRADICTORY, NOT MERELY HARD TO REACH), THEN THE REPORTED VIOLATION IS A FALSE POSITIVE.
A FALSE POSITIVE CAUSED BY  HAVOC  IS NOT A FLAW IN THE PROVER'S LOGIC BUT A DIAGNOSTIC SIGNAL OF A MISMATCH BETWEEN THE VERIFICATION'S ABSTRACT MODEL AND THE SMART CONTRACT'S MORE CONSTRAINED, REAL-WORLD ENVIRONMENT. THE PROVER CORRECTLY EXPLORES THE FULL STATE SPACE *AS DEFINED BY THE SPECIFICATION*, BUT IF THAT SPECIFICATION IS TOO LOOSE, IT WILL CONTAIN "UNREACHABLE" STATES THAT LEAD TO SPURIOUS COUNTEREXAMPLES.  HAVOC  EXPLORES "ALL LOGICALLY POSSIBLE VALUES," WHICH LEADS TO COUNTEREXAMPLES FROM "IMPOSSIBLE STATES." THE PROVER IS INHERENTLY *SOUND*; IT WILL FIND *ANY* VIOLATION WITHIN THE *DEFINED* STATE SPACE. IF THE USER'S SPECIFICATION(THE "DEFINED STATE SPACE") IS BROADER THAN THE SYSTEM'S *ACTUAL REACHABLE STATE SPACE* IN PRODUCTION, THEN ANY COUNTEREXAMPLE FOUND IN THE "UNREACHABLE" PART OF THE MODEL IS A FALSE POSITIVE. THE PROBLEM IS NOT  HAVOC  ITSELF, BUT THE *UNDER-CONSTRAINING* OF  HAVOC  IN THE CVL SPECIFICATION. THE PROVER IS SIMPLY HIGHLIGHTING THAT, ACCORDING TO THE CURRENT SPECIFICATION, A VIOLATION *IS* POSSIBLE. THIS SHIFT IN PERSPECTIVE IS CRITICAL: FALSE POSITIVES ARE NOT THE PROVER'S MISTAKE BUT VALUABLE FEEDBACK.THEY INDICATE THAT THE ONUS IS ON THE SPECIFICATION WRITER TO ACCURATELY MODEL THE SYSTEM'S TRUE INVARIANTS, PRECONDITIONS, AND ENVIRONMENTAL ASSUMPTIONS. THIS ITERATIVE PROCESS OF IDENTIFYING AND RESOLVING FALSE POSITIVES IS CORE TO ACHIEVING HIGH-FIDELITY FORMAL VERIFICATION.

                ** FALSE POSITIVE GENERATION MECHANISM:** THE MOST PREVALENT SOURCE OF FALSE POSITIVES IS INSUFFICIENT CONSTRAINTS ON THE INITIAL STATE AT THE BEGINNING OF A CVL RULE.BY DEFAULT, CERTORA'S  HAVOC  MECHANISM ASSIGNS ARBITRARY VALUES TO ALL VARIABLES AND CONTRACT STORAGE AT THE START OF A RULE TO SIMULATE A COMPLETELY UNKNOWN INITIAL CONFIGURATION. IF THE CONTRACT'S ACTUAL INITIAL STATE SPACE IS MORE STRICTLY LIMITED(E.G., DUE TO CONSTRUCTOR LOGIC OR DEPLOYMENT INVARIANTS), AND THESE LIMITATIONS ARE NOT EXPLICITLY CAPTURED IN THE CVL RULE VIA  REQUIRE  STATEMENTS, THE PROVER MAY FIND COUNTEREXAMPLES UNDER THESE UNREALISTIC STARTING CONDITIONS.

A COMMON SCENARIO IS WHEN A RULE ASSERTS AN INVARIANT LIKE totalSupply() == sumOfBalances;  .IF IN THE INITIAL STATE,  totalSupply  IS HAVOCED TO A VALUE, FOR INSTANCE, LESS THAN THE SUM OF INDIVIDUAL USER BALANCES(A STATE IMPOSSIBLE AFTER A CORRECTLY EXECUTED CONSTRUCTOR), THE INVARIANT WILL FAIL IMMEDIATELY.THIS LEADS TO A FALSE POSITIVE BECAUSE THE REPORTED VIOLATION OCCURS IN AN INITIAL STATE THE ACTUAL CONTRACT CAN NEVER ENTER.SIMILARLY, THE INTERACTION OF  HAVOC  WITH SOLIDITY'S  UNCHECKED  ARITHMETIC CAN LEAD TO SPURIOUS OVERFLOWS, AS DEMONSTRATED IN THE MOCKASSETA CASE.

WHEN EXTERNAL FUNCTION CALLS OR COMPLEX INTERNAL LOGIC ARE ABSTRACTED USING  HAVOC_ALL  OR  NONDET  SUMMARIES, THE PROVER ASSUMES THESE CALLS CAN ARBITRARILY MODIFY CONTRACT STORAGE OR RETURN ANY VALUE.IF THE ACTUAL BEHAVIOR OF THE EXTERNAL CONTRACT OR INTERNAL FUNCTION IS MORE CONSTRAINED THAN THIS BROAD ASSUMPTION, THE OVER - APPROXIMATION CAN LEAD TO COUNTEREXAMPLES THAT WOULD NEVER OCCUR IN ACTUAL INTERACTIONS.THIS IS A CLASSIC FORM OF A SPURIOUS COUNTEREXAMPLE CAUSED BY AN OVERLY GENERIC MODEL.

ALTHOUGH NOT DIRECTLY CAUSED BY HAVOC , MISLEADING "PASSES" CAN ALSO BE CONSIDERED A FORM OF FALSE POSITIVE IN TERMS OF WHAT THE USER BELIEVES IS BEING VERIFIED.THIS OCCURS WITH "VACUOUS PRECONDITIONS"(A REQUIRE  STATEMENT SO STRICT THAT NO INPUT CAN SATISFY IT, MAKING THE ASSERTION TRIVIALLY TRUE) OR "TAUTOLOGICAL ASSERTIONS"(AN ASSERTION THAT IS ALWAYS TRUE REGARDLESS OF THE CODE'S BEHAVIOR). FOR EXAMPLE, A RULE CONTAINING  REQUIRE X > 2; REQUIRE X < 1;   WILL ALWAYS PASS BECAUSE NO  X  CAN SATISFY BOTH CONDITIONS, MAKING ANY SUBSEQUENT  ASSERT  VACUOUSLY TRUE. SIMILARLY,  ASSERT X < 2 || X >= 2;   IS A TAUTOLOGY THAT PROVIDES NO MEANINGFUL VERIFICATION. CERTORA'S SANITY CHECKS ARE DESIGNED TO FLAG THESE ISSUES.

FALSE POSITIVES ARE MORE THAN JUST AN INCONVENIENCE; THEY CONSUME VALUABLE DEVELOPER / AUDITOR TIME IN ANALYZING SPURIOUS COUNTEREXAMPLES.IF THESE OCCUR FREQUENTLY, THEY CAN LEAD TO A POTENTIAL EROSION OF TRUST IN THE FORMAL VERIFICATION RESULTS.THE CORE VALUE PROPOSITION OF FORMAL VERIFICATION TOOLS LIKE CERTORA IS THEIR PROMISE OF "MATHEMATICAL CERTAINTY." IF THIS CERTAINTY IS REPEATEDLY UNDERMINED BY NON - ACTIONABLE FINDINGS, THE PERCEIVED VALUE AND CREDIBILITY OF THE TOOL DIMINISH.FOR SYSTEMS WHERE SAFETY AND CORRECTNESS ARE CRITICAL(E.G., DEFI PROTOCOLS, AEROSPACE SOFTWARE, MEDICAL DEVICES), THE PRECISION AND ACTIONABILITY OF FORMAL VERIFICATION RESULTS ARE AS IMPORTANT AS THEIR THEORETICAL SOUNDNESS.FALSE POSITIVES, BY INTRODUCING NOISE AND ERODING TRUST, EFFECTIVELY REDUCE THE * PRACTICAL SOUNDNESS * FROM THE USER'S PERSPECTIVE, EVEN IF THE UNDERLYING MATHEMATICAL ENGINE REMAINS THEORETICALLY SOUND. THIS HIGHLIGHTS THE URGENT NEED FOR USER-FRIENDLY MECHANISMS AND BEST PRACTICES THAT EMPOWER USERS TO MANAGE THE TRADEOFF BETWEEN EXHAUSTIVE STATE EXPLORATION AND THE GENERATION OF PRACTICALLY RELEVANT COUNTEREXAMPLES.

### ** 3.2.INTERPRETING CERTORA'S VERIFICATION REPORT AND CALL TRACE**

WHEN A RULE FAILS VERIFICATION, THE CERTORA PROVER GENERATES A DETAILED VERIFICATION REPORT, INCLUDING A CONCRETE COUNTEREXAMPLE.THIS REPORT IS ACCESSIBLE VIA A WEB LINK PROVIDED IN THE COMMAND - LINE OUTPUT.
TO DIAGNOSE A FALSE POSITIVE, IT IS ESSENTIAL TO DIVE INTO THE VERIFICATION RESULTS OF THE SPECIFIC RULE OR FUNCTION THAT FAILED.THE "CALL TRACE" SUB - WINDOW IN THE REPORT IS AN INDISPENSABLE DIAGNOSTIC TOOL.IT PROVIDES A DETAILED BREAKDOWN OF THE EXECUTION STEPS THAT LED TO THE FAILURE, SHOWING THE SEQUENCE OF OPERATIONS AND STATE CHANGES.THIS TRACE WILL REVEAL THE INITIAL STATE(E.G., "ASSUME INVARIANT IN PRE-STATE" SHOWING ZERO VALUES FOR KEY VARIABLES) AND HOW VARIABLES(INCLUDING GHOST VARIABLES) WERE HAVOCED TO UNEXPECTED VALUES.THE CALL TRACE ALSO HIGHLIGHTS WHERE  HAVOC  IS TRIGGERED, OFTEN BY AN EXTERNAL CALL TO AN UNRESOLVED CALLEE, WHERE THE PROVER CONSERVATIVELY RANDOMIZES VARIABLES TO ACCOUNT FOR POTENTIAL STATE CHANGES.
THE DETAILED COUNTEREXAMPLE AND CALL TRACE ARE THE PRIMARY DIAGNOSTIC TOOLS FOR DISTINGUISHING REAL BUGS FROM FALSE POSITIVES.A FALSE POSITIVE IS DEFINITIVELY IDENTIFIED WHEN THE INITIAL STATE OR AN INTERMEDIATE STATE OF THE COUNTEREXAMPLE(AS SHOWN IN THE TRACE) IS DEMONSTRABLY IMPOSSIBLE OR IRRELEVANT GIVEN THE REAL - WORLD CONSTRAINTS AND INVARIANTS OF THE SYSTEM.CERTORA PROVIDES A COUNTEREXAMPLE AND A CALL TRACE.THESE OUTPUTS SHOW THE INITIAL STATE AND SUBSEQUENT STATE CHANGES.THE CALL TRACE ALLOWS THE USER TO EXAMINE THE * SPECIFIC * INITIAL STATE AND THE * EXACT * SEQUENCE OF  HAVOC  OPERATIONS OR EXTERNAL CALLS THAT LED TO THE ASSERTION FAILURE.IF, UPON REVIEWING THIS TRACE, THE USER CAN CONFIDENTLY STATE, "MY CONTRACT *NEVER* STARTS IN THIS PARTICULAR STATE," OR "THIS EXTERNAL CALL *NEVER* PRODUCES THIS SPECIFIC EFFECT IN PRACTICE," THEN THEY HAVE IDENTIFIED A FALSE POSITIVE.THE TRACE PROVIDES THE CONCRETE, STEP - BY - STEP EVIDENCE TO PINPOINT THE "UNREACHABLE" OR "UNREALISTIC" ASPECT OF THE PROVER'S MODEL. EFFECTIVELY DEBUGGING CERTORA FALSE POSITIVES REQUIRES A STRONG MENTAL MODEL OF THE *ACTUAL* SYSTEM'S INVARIANTS, PRECONDITIONS, AND EXPECTED BEHAVIOR.THIS MENTAL MODEL IS THEN CRITICALLY COMPARED AGAINST THE COUNTEREXAMPLE GENERATED BY THE PROVER.THIS ITERATIVE "FAIL-ANALYZE-REFINE" PROCESS IS AT THE HEART OF FORMAL VERIFICATION, TRANSFORMING RAW PROVER OUTPUT INTO ACTIONABLE SPECIFICATION IMPROVEMENTS.

## ** 4. STRATEGIES TO MITIGATE FALSE POSITIVES FROM HAVOC  **

                THIS SECTION OUTLINES CONCRETE, ACTIONABLE STRATEGIES FOR REFINING CERTORA SPECIFICATIONS TO REDUCE FALSE POSITIVES CAUSED BY HAVOC .
                CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE 

### ** 4.1.REFINING INITIAL STATE CONSTRAINTS **

#### ** 4.1.1.USING  HAVOC ASSUMING  FOR PRECISE STATE INITIALIZATION **

                WHILE UNASSIGNED VARIABLES ARE HAVOCED BY DEFAULT, THE HAVOC  STATEMENT CAN BE ENHANCED WITH AN  ASSUMING CONDITION  CLAUSE.THIS CLAUSE RESTRICTS THE VALUES THAT THE HAVOCED VARIABLE CAN TAKE.THIS IS FUNCTIONALLY EQUIVALENT TO PLACING A  REQUIRE  STATEMENT IMMEDIATELY AFTER A BASIC  HAVOC  DECLARATION.
THIS CONSTRUCT IS PARTICULARLY USEFUL FOR MODELING COMPLEX SCENARIOS THAT MUST SATISFY CERTAIN INHERENT CONSTRAINTS OR INVARIANTS.FOR EXAMPLE,  HAVOC SUMALLBALANCE ASSUMING SUMALLBALANCE @NEW() == SUMALLBALANCE@OLD() + BALANCE - OLD_BALANCE;   DEMONSTRATES ITS UTILITY IN MAINTAINING RELATIONSHIPS BETWEEN STATES.SIMILARLY, FOR A GHOST VARIABLE IN A TWO - STATE CONTEXT,  HAVOC FOO ASSUMING FOO_ADD_EVEN(X);  CAN ENSURE A SPECIFIC PROPERTY IS MAINTAINED ACROSS STATES.
 HAVOC ASSUMING IS THE PRIMARY MECHANISM FOR TRANSFORMING A BROAD, SOUND OVER - APPROXIMATION OF THE INITIAL STATE INTO A MORE PRECISE, YET STILL SOUND, MODEL THAT IS LESS PRONE TO GENERATING SPURIOUS COUNTEREXAMPLES.IT ALLOWS THE SPECIFICATION WRITER TO INJECT REAL - WORLD INVARIANTS OR PRECONDITIONS THAT THE PROVER, UNDER MAXIMAL NON - DETERMINISM, WOULD OTHERWISE NOT KNOW OR CONSIDER.  HAVOC  WITHOUT  ASSUMING  DEFAULTS TO ARBITRARY VALUES FOR THE INITIAL STATE.
HAVOC ASSUMING ALLOWS SPECIFYING CONDITIONS FOR THESE VALUES.WITHOUT ASSUMING , THE PROVER EXPLORES ALL MATHEMATICALLY POSSIBLE INITIAL CONFIGURATIONS FOR A VARIABLE, INCLUDING THOSE THAT VIOLATE REAL - WORLD INVARIANTS(E.G., A NEGATIVE TOTAL_SUPPLY , OR AN OWNER  ADDRESS OF ADDRESS(0)  IF THAT IS AN INVALID STATE IN THE ACTUAL CONTRACT).  HAVOC ASSUMING  PROVIDES A WAY TO INJECT THESE REAL - WORLD INVARIANTS DIRECTLY AS CONSTRAINTS ON THE INITIAL STATE VARIABLES.THIS EFFECTIVELY PRUNES THE SMT SOLVER'S SEARCH SPACE, PREVENTING IT FROM FINDING COUNTEREXAMPLES IN STATES THAT ARE IMPOSSIBLE IN PRACTICE, THEREBY DIRECTLY REDUCING FALSE POSITIVES. THIS FEATURE IS CRITICAL FOR BRIDGING THE GAP BETWEEN THE GENERIC MATHEMATICAL MODEL AND THE SPECIFIC, CONSTRAINED REALITY OF A SMART CONTRACT'S OPERATIONAL ENVIRONMENT.IT ALLOWS THE USER TO MAKE THE VERIFICATION RESULTS MORE RELEVANT AND ACTIONABLE BY FOCUSING THE PROVER'S EFFORTS ON THE TRULY REACHABLE STATE SPACE.
#### ** 4.1.2.THE PERSISTENT KEYWORD FOR GHOST VARIABLES **

                BY DEFAULT, CERTORA'S PROVER WILL HAVOC GHOST VARIABLES, EVEN IF THEY ARE EXPLICITLY INITIALIZED. THIS IS BECAUSE THE PROVER CONSERVATIVELY ASSUMES THAT EXTERNAL INFLUENCES (E.G., CALLS TO UNRESOLVED CALLEES) MIGHT ALTER THESE VARIABLES. THIS CAN LEAD TO SIGNIFICANT INACCURACIES IN ASSERTIONS, AS THE PROVER MAY GENERATE COUNTEREXAMPLES WHERE GHOST VARIABLES ARE SPURIOUSLY CHANGED.
THE DIRECT SOLUTION TO THIS PROBLEM IS TO DECLARE THE RELEVANT GHOST VARIABLES AS PERSISTENT.
                THE PERSISTENT KEYWORD EXPLICITLY INSTRUCTS THE CERTORA PROVER THAT THE VALUE OF THE TAGGED GHOST VARIABLE SHOULD REMAIN STATIC AND * NOT * BE SUBJECT TO RANDOMIZATION OR havoc DURING THE VERIFICATION PROCESS.THIS ENSURES THAT THE PROVER'S ANALYSIS OF INVARIANTS AND PROPERTIES IS BASED ON THE INTENDED, UNCHANGING VALUES OF THESE GHOST VARIABLES, LEADING TO MORE ACCURATE AND RELIABLE FORMAL VERIFICATION RESULTS⁸.
            THE PERSISTENT KEYWORD IS A CRITICAL MECHANISM FOR DECLARING AN * ASSUMPTION OF INVARIANCE * ABOUT A SPECIFIC STATE COMPONENT(PARTICULARLY GHOST VARIABLES) THAT THE PROVER WOULD OTHERWISE CONSERVATIVELY ASSUME IS MUTABLE.THIS DIRECTLY ADDRESSES A COMMON AND OFTEN FRUSTRATING SOURCE OF FALSE POSITIVES RELATED TO THE INTEGRITY OF GHOST VARIABLES, WHICH ARE ESSENTIAL FOR EXPRESSING COMPLEX PROPERTIES.CERTORA PERFORMS A havoc WHEN IT IS UNSURE IF A FUNCTION CAN INTERACT WITH A VARIABLE.
havoc REFERS TO ASSIGNING ARBITRARY, NON - DETERMINISTIC VALUES TO VARIABLES...FOR EXAMPLE, WHEN AN EXTERNAL FUNCTION IS CALLED ON AN UNKNOWN CONTRACT, THE PROVER ASSUMES IT MAY ARBITRARILY AFFECT THE STATE OF A THIRD CONTRACT.BY DESIGN, THE CERTORA PROVER OPERATES ON A PRINCIPLE OF MAXIMAL CONSERVATISM TO ENSURE SOUNDNESS.FOR ANY VARIABLE WHOSE MUTABILITY OR SUSCEPTIBILITY TO EXTERNAL INFLUENCE CANNOT BE EXPLICITLY PROVEN, THE PROVER DEFAULTS TO ASSUMING IT * CAN * BE ARBITRARILY CHANGED.THIS IS A SOUND BUT OFTEN OVERLY BROAD DEFAULT.GHOST VARIABLES, DESPITE BEING PART OF THE SPECIFICATION, ARE SUBJECT TO THIS CONSERVATIVE ASSUMPTION UNLESS EXPLICITLY CONSTRAINED.THE PERSISTENT KEYWORD SERVES AS AN EXPLICIT DECLARATION TO THE PROVER: "ASSUME THE VALUE OF THIS GHOST VARIABLE IS FIXED THROUGHOUT THE EXECUTION OF THE RULE, EVEN IN THE PRESENCE OF EXTERNAL CALLS OR OTHER NON-DETERMINISTIC EVENTS." THIS DIRECTLY ELIMINATES FALSE POSITIVES WHERE THE PROVER MIGHT FABRICATE A SPURIOUS CHANGE IN A GHOST VARIABLE, THEREBY CAUSING A PROPERTY VIOLATION.THIS HIGHLIGHTS THE NECESSITY OF EXPLICITLY DECLARING ASSUMPTIONS ABOUT THE INVARIANCE OR STABILITY OF STATE IN THE SPECIFICATION.IT IS A CONCRETE INSTANCE OF REFINING THE MODEL TO ALIGN WITH REAL - WORLD GUARANTEES, ALLOWING THE PROVER TO FOCUS ON RELEVANT BEHAVIORS.

#### ** 4.1.3.STRATEGIC APPLICATION OF REQUIRE STATEMENTS(AND THEIR CAVEATS) **

THE REQUIRE STATEMENT IN CVL DEFINES A PRECONDITION FOR A RULE.IF A require STATEMENT EVALUATES TO FALSE IN A PARTICULAR EXAMPLE, THE PROVER IGNORES THAT EXAMPLE ENTIRELY DURING VERIFICATION.THIS MECHANISM CAN BE USED TO EXCLUDE COUNTEREXAMPLES THAT START FROM IMPOSSIBLE STATES, THUS REDUCING FALSE POSITIVES.
    THE REQUIREINVARIANT COMMAND IS A SPECIALIZED FORM THAT ALLOWS A PREVIOUSLY VERIFIED INVARIANT TO BE ADDED AS AN ASSUMPTION TO ANOTHER RULE.THIS CAN BE A QUICK AND EFFECTIVE WAY TO EXCLUDE COUNTEREXAMPLES THAT ARISE FROM STATES INCONSISTENT WITH ESTABLISHED SYSTEM INVARIANTS.
** CAVEAT **: THE USE OF require STATEMENTS MUST BE EXTREMELY CAREFUL.USING require TOO AGGRESSIVELY CAN LEAD TO * UNSOUNDNESS *, AS THE PROVER WILL SIMPLY IGNORE ANY MODEL THAT CAUSES THE require EXPRESSION TO EVALUATE TO FALSE, POTENTIALLY MISSING A GENUINE VIOLATION OF THE DESIRED PROPERTY.THE CERTORA PROVER EVEN ISSUES WARNINGS AGAINST require STATEMENTS THAT MIGHT EXCLUDE MEANINGFUL TRACES.FURTHERMORE, ADDING AN ARBITRARY require STATEMENT IN THE preserved BLOCK OF AN INVARIANT CAN INVALIDATE THE INDUCTIVE PROOF IF THE UNDERLYING ASSUMPTION IS NOT INDEPENDENTLY VERIFIED.HOWEVER, USING requireInvariant J(y) IN A preserved BLOCK IS CONSIDERED SOUND AND ENCOURAGED, PROVIDED THE J INVARIANT HAS ITSELF BEEN INDEPENDENTLY VERIFIED.
    WHILE require STATEMENTS ARE POWERFUL FOR PRUNING THE SEARCH SPACE BY ASSERTING PRECONDITIONS, THEY ARE A DOUBLE - EDGED SWORD.THEY CAN EFFECTIVELY REDUCE FALSE POSITIVES, BUT THEY INTRODUCE A SIGNIFICANT RISK OF * UNSOUNDNESS * IF THEY INADVERTENTLY FILTER OUT VALID, VULNERABLE STATES. requireInvariant PROVIDES A SAFER, MORE MODULAR WAY TO LEVERAGE VERIFIED INVARIANTS AS PRECONDITIONS, THEREBY PRESERVING SOUNDNESS. require STATEMENTS CAUSE THE PROVER TO IGNORE THE EXAMPLES WHERE THEY FAIL.THIS CAN REDUCE FALSE POSITIVES BY FILTERING OUT IMPOSSIBLE STATES.HOWEVER, USING require TOO AGGRESSIVELY CAN LEAD TO MISSING REAL VIOLATIONS.
HAVOC Y ASSUMING Y > 10;  IS EQUIVALENT TO UINT256 Y; REQUIRE Y > 10; ⁴.ADDING ASSUMPTIONS IN A preserved BLOCK INVALIDATES THE PROOF IF WE HAVE NO REASON TO BELIEVE IT ACTUALLY HOLDS, WHICH IS WHY WE DO NOT RECOMMEND ADDING require STATEMENTS IN A preserved BLOCK.
* HAVOC ASSUMING * CONSTRAINS THE NON - DETERMINISM OF A VARIABLE'S INITIAL VALUE*. IT INSTRUCTS THE SMT SOLVER: "PICK ANY VALUE FOR X, BUT IT *MUST* SATISFY THIS CONDITION." THE PROVER THEN TRIES TO FIND A COUNTEREXAMPLE WITHIN THAT CONSTRAINED SPACE. THIS APPROACH MAINTAINS SOUNDNESS BECAUSE THE PROVER IS STILL EXPLORING ALL VALID POSSIBILITIES GIVEN THE CONSTRAINT.
* REQUIRE * FILTERS OUT AN ENTIRE EXECUTION PATH * IF A CONDITION DOES NOT HOLD.IT ESSENTIALLY TELLS THE PROVER: "IF THIS CONDITION IS NOT MET AT THIS POINT, SIMPLY DISCARD THIS EXECUTION BRANCH." THIS IS A MORE AGGRESSIVE PRUNING MECHANISM.
* THE KEY RISK WITH REQUIRE IS THAT IF THE CONDITION * COULD * BE FALSE IN A REAL, VULNERABLE SCENARIO, THE PROVER * NEVER CHECKS * THAT SCENARIO.THIS LEADS TO * UNSOUNDNESS * (THE PROVER MAY REPORT "PASS" WHEN A BUG EXISTS). HAVOC ASSUMING IS GENERALLY SAFER FOR INITIAL STATE CONSTRAINTS, AS IT STILL FORCES THE PROVER TO EXPLORE POTENTIAL VIOLATIONS WITHIN THE SPACE OF VALID, CONSTRAINED INITIAL STATES.
* REQUIREINVARIANT IS A PARTICULARLY VALUABLE PATTERN AS IT ALLOWS THE LEVERAGING OF * ALREADY VERIFIED * INVARIANTS AS ASSUMPTIONS, THUS PROMOTING MODULARITY AND PRESERVING SOUNDNESS IN COMPOSITIONAL PROOFS.

THE CHOICE BETWEEN HAVOC ASSUMING AND REQUIRE FOR INITIAL STATE CONSTRAINTS IS NUANCED.IT DEPENDS ON WHETHER THE CONDITION REPRESENTS AN INHERENT, ALWAYS - TRUE PROPERTY OF THE SYSTEM(BEST ADDRESSED WITH HAVOC ASSUMING OR REQUIREINVARIANT), OR IF ITS VIOLATION IMPLIES THE CURRENT EXECUTION PATH IS IRRELEVANT TO THE PROPERTY BEING CHECKED(USE REQUIRE, BUT WITH EXTREME CAUTION AND A CLEAR UNDERSTANDING OF THE POTENTIAL FOR UNSOUNDNESS).
** TABLE 2: CVL CONSTRUCTS FOR INITIAL STATE REFINEMENT **

| CONSTRUCT | SYNTAX EXAMPLE | PRIMARY PURPOSE FOR INITIAL STATE REFINEMENT | EFFECT ON NON - DETERMINISM | SOUNDNESS / CORRECTNESS IMPACT | BEST PRACTICE / KEY CONSIDERATION |
| : --- | : --- | : --- | : --- | : --- | : --- |
| HAVOC ASSUMING | HAVOC X ASSUMING X > 0;  | CONSTRAIN THE INITIAL RANDOMIZED VALUE RANGE OF A VARIABLE. | REDUCES. | MAINTAINS SOUNDNESS, REDUCES FALSE POSITIVES. | USE TO EXPRESS INHERENT PRECONDITIONS OR INVARIANTS OF THE SYSTEM. |
| PERSISTENT(GHOST VAR) | PERSISTENT GHOST | DECLARE THAT A GHOST VARIABLE'S VALUE IS CONSTANT DURING VERIFICATION. | ELIMINATES NON-DETERMINISM FOR THE GHOST VARIABLE. | MAINTAINS SOUNDNESS, ELIMINATES GHOST-RELATED FALSE POSITIVES. | USE ONLY FOR GHOST VARIABLES THAT ARE TRULY INVARIANT. |
    | REQUIRE | REQUIRE BALANCE > 0;  | IGNORE EXECUTION PATHS THAT DO NOT SATISFY THE CONDITION. | REDUCES(BY FILTERING). | CAN LEAD TO UNSOUNDNESS IF IT FILTERS OUT REAL VULNERABILITIES. | USE WITH CAUTION, ENSURING IT DOES NOT EXCLUDE VALID BUT VULNERABLE SCENARIOS. requireInvariant IS SAFER. |

### ** 4.2.OPTIMIZING EXTERNAL CALL SUMMARIES **

#### ** 4.2.1.CHOOSING THE RIGHT FUNCTION SUMMARY FOR EXTERNAL INTERACTIONS **

    AS PREVIOUSLY MENTIONED, HAVOC_ALL IS THE MOST CONSERVATIVE SUMMARY, ASSUMING EXTERNAL CALLS CAN CAUSE ARBITRARY STATE CHANGES.WHILE SOUND, ITS BROADNESS FREQUENTLY LEADS TO A HIGH VOLUME OF FALSE POSITIVES BY EXPLORING UNREALISTIC SCENARIOS.
HAVOC_ECF IS GENERALLY PREFERRED WHEN THE EXTERNAL CALL IS KNOWN TO BE NON - REENTRANT AND IS GUARANTEED NOT TO MODIFY THE CALLING CONTRACT'S STATE OR DECREASE ITS ETH BALANCE (BEYOND ANY EXPLICITLY TRANSFERRED VALUE). THIS SUMMARY SIGNIFICANTLY REDUCES FALSE POSITIVES AND IMPROVES PERFORMANCE BY RESTRICTING THE SCOPE OF havoc TO ONLY EXTERNAL CONTRACTS.
NONDET IS SUITABLE FOR EXTERNAL VIEW FUNCTIONS THAT ARE KNOWN TO HAVE NO SIDE EFFECTS, REPLACING THEIR EXECUTION WITH A NON - DETERMINISTIC RETURN VALUE.
EXPRESSION SUMMARIES PROVIDE THE HIGHEST PRECISION.WHEN THE BEHAVIOR OF AN EXTERNAL CALL CAN BE ACCURATELY MODELED BY A CVL FUNCTION OR GHOST AXIOM, AN EXPRESSION SUMMARY CAN REPLACE THE CALL WITH THIS PRECISE, DETERMINISTIC LOGIC.THIS APPROACH EFFECTIVELY ELIMINATES havoc - RELATED FALSE POSITIVES FOR THESE SPECIFIC EXTERNAL INTERACTIONS.
REPLACING A DISPATCHER SUMMARY WITH AUTO OR A MORE SPECIFIC SUMMARY CAN SIGNIFICANTLY REDUCE THE "PATH COUNT" AND PREVENT TIMEOUTS.
DISPATCHER SUMMARIES, BY CONSIDERING MULTIPLE POTENTIAL CALL TARGETS, CAN LEAD TO A STATE SPACE EXPLOSION, WHICH, WHILE NOT A FALSE POSITIVE IN ITSELF, CAN PREVENT THE PROVER FROM COMPLETING VERIFICATION, THUS HINDERING THE IDENTIFICATION OF REAL BUGS.
THE CHOICE OF EXTERNAL CALL SUMMARY IS A KEY DESIGN DECISION THAT DIRECTLY IMPACTS THE PRECISION OF THE VERIFICATION MODEL AND, CONSEQUENTLY, THE RATE OF FALSE POSITIVES.MORE PRECISE SUMMARIES(E.G., HAVOC_ECF OVER HAVOC_ALL, OR EXPRESSION SUMMARIES) REDUCE THE DEGREE OF OVER - APPROXIMATION, THEREBY REDUCING SPURIOUS COUNTEREXAMPLES.HOWEVER, THIS INCREASED PRECISION COMES AT THE COST OF REQUIRING STRONGER, * VALIDATED * ASSUMPTIONS ABOUT THE EXTERNAL CODE'S BEHAVIOR. DIFFERENT SUMMARY TYPES HAVE DIFFERENT EFFECTS ON STATE AND PERFORMANCE.
HAVOC_ALL "ERASES ALL KNOWLEDGE", IMPLYING MAXIMUM NON - DETERMINISM AND THUS A WIDER RANGE OF POSSIBLE(AND OFTEN UNREALISTIC) STATE CHANGES.
HAVOC_ECF "ASSUMES IT CAN HAVE ARBITRARY EFFECTS ON CONTRACTS *OTHER THAN* THE ONE BEING VERIFIED", WHICH REPRESENTS A * CONSTRAINT * ON NON - DETERMINISM, SPECIFICALLY PREVENTING CHANGES TO THE CALLING CONTRACT'S STATE. EXPRESSION SUMMARIES REPLACE A NON-DETERMINISTIC CALL WITH *DETERMINISTIC* CVL LOGIC, EFFECTIVELY ELIMINATING havoc FOR THAT CALL. havoc SUMMARIES INTRODUCE NON-DETERMINISM FOR EXTERNAL CALLS TO ACCOUNT FOR UNKNOWN BEHAVIOR. THE MORE CONSERVATIVE THE SUMMARY (HAVOC_ALL), THE MORE NON-DETERMINISM IS INTRODUCED. THIS LEADS TO A LARGER SEARCH SPACE FOR THE SMT SOLVER AND A HIGHER LIKELIHOOD OF FINDING SPURIOUS COUNTEREXAMPLES ARISING FROM UNREALISTIC OR IMPOSSIBLE EXTERNAL BEHAVIORS (FALSE POSITIVES). CONVERSELY, MORE PRECISE SUMMARIES (LIKE HAVOC_ECF OR EXPRESSION SUMMARIES) *REDUCE* THIS NON-DETERMINISM BY ENCODING KNOWN OR ASSUMED PROPERTIES OF THE EXTERNAL CALL. THIS NARROWS THE SEARCH SPACE, MAKES VERIFICATION MORE EFFICIENT, AND LEADS TO FEWER FALSE POSITIVES. THIS UNDERSCORES THE IMPORTANCE OF UNDERSTANDING THE BEHAVIOR OF EXTERNAL DEPENDENCIES. IF AN EXTERNAL CONTRACT'S BEHAVIOR IS WELL - UNDERSTOOD, IT SHOULD BE ENCODED AS PRECISELY AS POSSIBLE IN THE SUMMARY.IF IT IS TRULY UNKNOWN, ONE MUST START WITH A CONSERVATIVE SUMMARY(HAVOC_ALL) AND THEN CAREFULLY REFINE IT TO HAVOC_ECF OR AN EXPRESSION SUMMARY AS MORE ASSUMPTIONS ARE VALIDATED.THIS IS A KEY ASPECT OF EFFECTIVE MODULAR VERIFICATION.

#### ** 4.2.2.USING WITH(ENV) AND ENVFREE FOR ENVIRONMENT CONTROL **

 THE CERTORA PROVER MODELS THE CALL CONTEXT VIA THE ENV STRUCT VARIABLE, WHICH CAPTURES GLOBAL SOLIDITY VARIABLES LIKE MSG.SENDER, MSG.VALUE, BLOCK.NUMBER, AND BLOCK.TIMESTAMP.THE PROVER CONSIDERS "ALL POSSIBLE CALLING CONTEXTS" BY DEFAULT.THE WITH(ENV E) CLAUSE, USED IN THE METHODS BLOCK, ALLOWS THE ENVIRONMENT(ENV) USED WHEN A SUMMARIZED METHOD IS CALLED TO BE EXPLICITLY BOUND AND POTENTIALLY CONSTRAINED.THIS ENABLES MORE PRECISE MODELING OF THE ENVIRONMENTAL CONDITIONS UNDER WHICH A SUMMARIZED EXTERNAL CALL OCCURS.THE ENVFREE ANNOTATION CAN BE APPLIED TO FUNCTIONS THAT ARE COMPLETELY INDEPENDENT OF THE ENVIRONMENT, ALLOWING THEM TO BE CALLED WITHOUT AN ENV ARGUMENT.THIS EXPLICITLY ELIMINATES ENVIRONMENTAL NON - DETERMINISM FOR THOSE SPECIFIC FUNCTIONS, THEREBY SIMPLIFYING THE MODEL. WITH(ENV) AND ENVFREE PROVIDE FINE - GRAINED CONTROL OVER THE * ENVIRONMENTAL NON - DETERMINISM * CONSIDERED BY THE CERTORA PROVER.BY EXPLICITLY CONSTRAINING OR ELIMINATING THE INFLUENCE OF ENVIRONMENT VARIABLES ON SPECIFIC CALLS, ONE CAN EFFECTIVELY MITIGATE FALSE POSITIVES ARISING FROM UNREALISTIC OR IRRELEVANT ENVIRONMENTAL CONTEXTS, LEADING TO MORE TARGETED AND ACCURATE VERIFICATION.A COMMAND MAY CONTAIN "UNASSIGNED VARIABLES WITH UNSPECIFIED VALUES".THE STORAGE STATE IS ALSO UNSPECIFIED AT THE START OF A RULE.ENVIRONMENT VARIABLES(MSG.SENDER, BLOCK.TIMESTAMP, ETC.) ARE PART OF THE UNSPECIFIED, NON - DETERMINISTIC INITIAL STATE OF ANY CALL.IF THE PROVER IS ALLOWED TO CHOOSE * ANY * VALUE FOR MSG.SENDER, MSG.VALUE, OR BLOCK.TIMESTAMP FOR AN EXTERNAL CALL, IT MAY FIND COUNTEREXAMPLES IN ENVIRONMENTAL CONTEXTS THAT ARE IMPOSSIBLE OR IRRELEVANT IN THE ACTUAL SYSTEM(E.G., ADDRESS(0) PERFORMING A PRIVILEGED ACTION, OR A TIMESTAMP IN THE DISTANT PAST). WITH(ENV) ALLOWS THE USER TO ADD SPECIFIC CONSTRAINTS TO THESE ENV VARIABLES * SPECIFICALLY FOR THE SUMMARIZED CALL *, EFFECTIVELY PRUNING THE ENVIRONMENTAL STATE SPACE. ENVFREE GOES A STEP FURTHER BY, FOR FUNCTIONS THAT ARE TRULY INDEPENDENT OF ENV VARIABLES, ELIMINATING ENVIRONMENTAL NON - DETERMINISM ENTIRELY, FURTHER SIMPLIFYING THE MODEL AND REDUCING THE POTENTIAL FOR FALSE POSITIVES CAUSED BY ENVIRONMENTAL FACTORS.FORMAL VERIFICATION IS NOT LIMITED TO A CONTRACT'S INTERNAL LOGIC; IT ENCOMPASSES ITS INTERACTION WITH THE ENVIRONMENT. ACCURATELY MODELING THE ENVIRONMENT IS AS IMPORTANT AS MODELING THE CONTRACT ITSELF TO AVOID FALSE POSITIVES AND ENSURE THE RELEVANCE OF THE VERIFICATION RESULTS. THESE CONSTRUCTS PROVIDE THE NECESSARY TOOLS TO ACHIEVE THIS PRECISE ENVIRONMENTAL MODELING.

### ** 4.3.USING FILTERS TO SCOPE THE VERIFICATION **

#### ** 4.3.1.APPLYING FILTERED BLOCKS IN RULES TO EXCLUDE METHODS **

    THE CERTORA PROVER SUPPORTS "PARAMETRIC RULES," WHICH ARE RULES THAT CONTAIN UNDEFINED METHOD VARIABLES.WHEN VERIFYING SUCH A RULE, THE PROVER GENERATES A SEPARATE REPORT FOR EACH METHOD(OR COMBINATION OF METHODS) THAT INSTANTIATES THE PARAMETRIC RULE.A FILTERED BLOCK CAN BE ADDED TO THE RULE DECLARATION, AFTER THE RULE PARAMETERS.THESE BLOCKS ALLOW THE USER TO PREVENT VERIFICATION OF THE PARAMETRIC RULE FOR SPECIFIC METHODS.THIS APPROACH IS OFTEN MORE COMPUTATIONALLY EFFICIENT THAN USING require STATEMENTS IN THE RULE BODY TO IGNORE COUNTEREXAMPLES FOR CERTAIN METHODS.FILTERS CONSIST OF var -> expr PAIRS, WHERE var MUST MATCH ONE OF THE RULE'S METHOD PARAMETERS AND expr IS A BOOLEAN EXPRESSION THAT CAN REFER TO var (E.G., F -> F.ISVIEW, G -> G.SELECTOR != SIG: SOMEMETHOD().SELECTOR).
RULE FILTERS ARE MORE THAN JUST A PERFORMANCE OPTIMIZATION; THEY ARE A KEY MECHANISM FOR * SCOPE MANAGEMENT * THAT DIRECTLY CONTRIBUTES TO REDUCING FALSE POSITIVES.BY EXPLICITLY EXCLUDING VERIFICATION FOR METHODS WHERE A PROPERTY IS NOT EXPECTED TO HOLD, FILTERS ENSURE THE PROVER ONLY SPENDS RESOURCES ON RELEVANT CHECKS, THUS PREVENTING SPURIOUS COUNTEREXAMPLES FROM INAPPLICABLE CONTEXTS.PARAMETRIC RULES CHECK MANY METHODS.FILTERS ALLOW EXCLUDING METHODS.THIS IS "LESS COMPUTATIONALLY EXPENSIVE" THAN require.RULE FILTERS ALLOW PREVENTING VERIFICATION OF A PARAMETRIC RULE FOR CERTAIN METHODS.
    THE require STATEMENT WARNS: "IT IS IMPORTANT TO THINK CAREFULLY ABOUT THE REASON FOR EXCLUDING THESE BEHAVIORS, AS USING require TOO AGGRESSIVELY MAY MISS A VIOLATION OF A DESIRED PROPERTY".IF A PARAMETRIC RULE IS INTENDED TO EXPRESS A PROPERTY THAT APPLIES TO A GENERAL CLASS OF METHODS(E.G., "ALL VIEW FUNCTIONS SHOULD NOT ALTER STATE"), BUT THERE ARE CERTAIN METHODS WITHIN THAT CLASS THAT ARE * NOT EXPECTED TO SATISFY * THE PROPERTY(E.G., A mint FUNCTION OBVIOUSLY ALTERS totalSupply), THEN CHECKING THE PROPERTY ON THE mint FUNCTION WILL INEVITABLY LEAD TO A COUNTEREXAMPLE.THIS COUNTEREXAMPLE, WHILE TECHNICALLY A VIOLATION OF THE RULE * AS WRITTEN *, IS A FALSE POSITIVE IN THE * CONTEXT OF THE INTENDED PROPERTY *.FILTERS ALLOW THE USER TO EXPLICITLY DEFINE THE * DOMAIN OF APPLICABILITY * FOR A RULE, EFFECTIVELY STATING: "THIS RULE ONLY APPLIES TO METHODS THAT SATISFY THIS CONDITION." THIS PREVENTS THE PROVER FROM REPORTING "VIOLATIONS" FOR METHODS THAT ARE NOT EXPECTED TO SATISFY THE PROPERTY, THUS ELIMINATING THESE SPECIFIC FALSE POSITIVES.THE COMPUTATIONAL EFFICIENCY IS A VALUABLE BYPRODUCT OF THIS PRECISE SCOPING.FILTERS ARE A FORM OF "META-SPECIFICATION" THAT DEFINES THE BOUNDARIES OF A PROPERTY'S RELEVANCE. THEY ARE CRITICAL FOR MANAGING THE COMPLEXITY OF LARGE SPECIFICATIONS AND ENSURING THAT VERIFICATION EFFORTS ARE FOCUSED ON MEANINGFUL PROPERTIES, THEREBY IMPROVING THE SIGNAL-TO-NOISE RATIO OF THE VERIFICATION RESULTS.

#### ** 4.3.2.APPLYING FILTERED BLOCKS IN INVARIANTS FOR CONTEXTUAL CHECKS **

    INVARIANTS IN CERTORA ARE PROPERTIES THAT THE SYSTEM SHOULD ALWAYS MAINTAIN.THEY ARE PROVEN BY INDUCTION: FIRST, BY ESTABLISHING A BASE CASE(E.G., THE INVARIANT HOLDS AFTER A CONSTRUCTOR CALL), AND THEN BY PROVING THAT EVERY FUNCTION IN THE CONTRACT PRESERVES THE INVARIANT(THE INDUCTIVE STEP).
        A FILTERED BLOCK CAN ALSO BE ADDED TO AN INVARIANT DECLARATION TO PREVENT THE PROVER FROM CHECKING THE INVARIANT'S PRESERVATION FOR SPECIFIC METHODS. FOR INSTANCE, FILTERED { F -> F.SELECTOR != SIG: DEPOSIT(UINT).SELECTOR }  WOULD PREVENT THE DEPOSIT(UINT) METHOD FROM BEING CHECKED FOR A PARTICULAR INVARIANT.
            ** CAVEAT **: WHILE SEEMINGLY USEFUL FOR REDUCING FALSE POSITIVES, FILTERING METHODS WHEN CHECKING INVARIANTS IS GENERALLY CONSIDERED * UNSOUND *.IF AN INVARIANT FAILS FOR A PARTICULAR METHOD, THE RECOMMENDED APPROACH IS USUALLY TO USE A preserved BLOCK. PRESERVED BLOCKS ALLOW FOR ADDING ASSUMPTIONS IN A MORE FINE - GRAINED MANNER, ALTHOUGH THEY ALSO REQUIRE CAREFUL JUSTIFICATION TO AVOID UNSOUNDNESS.IT IS IMPORTANT TO NOTE THAT IF A preserved BLOCK EXISTS FOR A METHOD, THAT METHOD * WILL STILL * BE VERIFIED, EVEN IF A FILTER WOULD NORMALLY EXCLUDE IT.APPLYING FILTERS TO INVARIANTS, WHILE SUPERFICIALLY REDUCING FALSE POSITIVES, PRESENTS A SEVERE RISK OF UNSOUNDNESS.THIS IS BECAUSE AN INVARIANT IS INTENDED TO HOLD UNDER * ALL * VALID OPERATIONS.EXCLUDING CERTAIN METHODS MEANS THE PROVER FAILS TO VERIFY THAT THOSE METHODS PRESERVE THE INVARIANT.IF THESE EXCLUDED METHODS CAN IN FACT BREAK THE INVARIANT, THE PROOF LOSES ITS SOUNDNESS, POTENTIALLY MISSING A REAL VULNERABILITY.THEREFORE, THIS APPROACH SHOULD BE CONSIDERED A TEMPORARY, HIGH - RISK WORKAROUND RATHER THAN A SOUND PRACTICE.THE PROVER CHECKS IF A METHOD PRESERVES AN INVARIANT BY FIRST requireING THE INVARIANT(pre-state check), EXECUTING THE METHOD, AND THEN assertING THE INVARIANT(post-state check).ADDING A require STATEMENT TO A preserved BLOCK ADDS AN EXTRA ASSUMPTION, WHICH CAN INVALIDATE THE PROOF UNLESS THERE IS A REASON TO BELIEVE THE ASSUMPTION ACTUALLY HOLDS.
THE CORE PROBLEM WITH THIS APPROACH IS THAT AN INVARIANT'S INDUCTIVE PROOF REQUIRES IT TO HOLD UNDER ALL POSSIBLE SYSTEM TRANSITIONS. IF CERTAIN TRANSITIONS ARE EXCLUDED VIA FILTERING, THE INDUCTIVE STEP IS NO LONGER COMPREHENSIVE. THE PROVER CAN NO LONGER GUARANTEE THAT THE INVARIANT STILL HOLDS AFTER THE EXECUTION OF THESE EXCLUDED METHODS. THIS CAN LEAD TO THE PROVER REPORTING "PASS" WHEN, IN FACT, A REAL COUNTEREXAMPLE EXISTS, BUT IT LIES WITHIN THE FILTERED-OUT EXECUTION PATH. THUS, WHEN AN INVARIANT FAILS, THE CORRECT PRACTICE IS TO UNDERSTAND THE REASON FOR THE FAILURE AND MODIFY THE INVARIANT OR THE CODE ACCORDINGLY, RATHER THAN SIMPLY "HIDING" THE PROBLEM THROUGH FILTERING. preserved BLOCKS OFFER AN ALTERNATIVE THAT ALLOWS ADDING ASSUMPTIONS, SUCH AS requireInvariant OF ANOTHER VERIFIED INVARIANT, BEFORE EXECUTING THE METHOD. THIS IS A SAFER APPROACH AS IT RELIES ON VERIFIED PROPERTIES RATHER THAN SIMPLY IGNORING CERTAIN BEHAVIORS. HOWEVER, EVEN ASSUMPTIONS IN preserved BLOCKS REQUIRE CAREFUL VALIDATION TO ENSURE THEY DO NOT INTRODUCE NEW UNSOUNDNESS.

## ** 5. CONCLUSION AND RECOMMENDATIONS **

    THE HAVOC MECHANISM IN THE CERTORA PROVER IS AN INDISPENSABLE COMPONENT OF FORMAL VERIFICATION, ENSURING THE SOUNDNESS OF THE VERIFICATION BY INTRODUCING NON - DETERMINISM FOR A COMPREHENSIVE EXPLORATION OF SMART CONTRACT BEHAVIOR.HOWEVER, THIS INHERENT NON - DETERMINISM, ESPECIALLY IN INITIAL STATE MODELING AND EXTERNAL CALL SUMMARIES, CAN EASILY LEAD TO THE EMERGENCE OF FALSE POSITIVE COUNTEREXAMPLES IF NOT PRECISELY CONSTRAINED.THESE FALSE POSITIVES ARE NOT ERRORS IN THE PROVER BUT ARE DIAGNOSTIC SIGNALS OF A MISMATCH BETWEEN THE VERIFICATION MODEL AND THE SMART CONTRACT'S ACTUAL OPERATIONAL ENVIRONMENT.
THE CORE OF EFFICIENTLY HANDLING havoc - INDUCED FALSE POSITIVES LIES IN * REFINING THE CERTORA VERIFICATION SPECIFICATION * TO MORE ACCURATELY REFLECT THE SYSTEM'S TRUE INVARIANTS, PRECONDITIONS, AND ENVIRONMENTAL ASSUMPTIONS. BASED ON AN IN-DEPTH ANALYSIS OF THE havoc MECHANISM AND ITS EFFECTS, THE FOLLOWING RECOMMENDATIONS ARE PROPOSED:

1. ** PRECISELY CONSTRAIN INITIAL STATES **:
    *   ** UTILIZE HAVOC ASSUMING **: FOR VARIABLES IN RULES, THE HAVOC ASSUMING CLAUSE SHOULD BE USED TO PRECISELY LIMIT THEIR INITIAL VALUE RANGE, MAKING IT CONFORM TO THE CONTRACT'S ACTUAL DEPLOYMENT OR OPERATIONAL PRECONDITIONS. THIS EFFECTIVELY INJECTS REAL-WORLD INVARIANTS INTO THE PROVER'S INITIAL STATE MODEL, THEREBY PRUNING IRRELEVANT SEARCH SPACE AND SIGNIFICANTLY REDUCING FALSE POSITIVES.
    *   ** APPLY THE PERSISTENT KEYWORD **: FOR GHOST VARIABLES THAT SHOULD REMAIN UNCHANGED DURING VERIFICATION, BE SURE TO DECLARE THEM AS PERSISTENT IN THE .CONF FILE.THIS ELIMINATES THE PROVER'S CONSERVATIVE ASSUMPTION THAT GHOST VARIABLES MIGHT BE ARBITRARILY CHANGED BY EXTERNAL INFLUENCES, AVOIDING ASSERTION FAILURES DUE TO SPURIOUS GHOST VARIABLE CHANGES.
    *   ** STRATEGICALLY USE REQUIRE STATEMENTS **: REQUIRE STATEMENTS CAN BE USED TO DEFINE PRECONDITIONS FOR RULES, THEREBY IGNORING IRRELEVANT EXECUTION PATHS.HOWEVER, THEY MUST BE USED WITH EXTREME CAUTION TO AVOID INADVERTENTLY FILTERING OUT REAL VULNERABILITIES, LEADING TO UNSOUNDNESS.FOR PRECONDITIONS BASED ON VERIFIED INVARIANTS, requireInvariant IS RECOMMENDED AS A SAFER, MORE MODULAR APPROACH.
2. ** OPTIMIZE EXTERNAL CALL SUMMARIES **:
    *   ** CHOOSE THE APPROPRIATE SUMMARY TYPE **: BASED ON THE LEVEL OF KNOWLEDGE ABOUT AN EXTERNAL CONTRACT'S BEHAVIOR, SELECT THE SUMMARY TYPE THAT BEST REFLECTS ITS SIDE EFFECTS.
    * WHEN THE EXTERNAL CONTRACT'S BEHAVIOR IS COMPLETELY UNKNOWN, ONE CAN START WITH HAVOC_ALL, BUT SHOULD ATTEMPT TO REFINE IT AS SOON AS POSSIBLE.
        * WHEN AN EXTERNAL CALL IS KNOWN TO BE NON - REENTRANT AND WILL NOT MODIFY THE CALLING CONTRACT'S STATE, PRIORITIZE USING HAVOC_ECF. IT OFFERS A BETTER BALANCE BETWEEN SOUNDNESS AND PRECISION.
            * FOR PURE VIEW FUNCTIONS, USE NONDET SUMMARIES.
        * WHEN EXTERNAL BEHAVIOR CAN BE PRECISELY MODELED, EXPRESSION SUMMARIES SHOULD BE USED TO REPLACE THE NON - DETERMINISTIC CALL.
    *   ** CONTROL ENVIRONMENTAL NON - DETERMINISM **: UTILIZE THE WITH(ENV) CLAUSE IN THE METHODS BLOCK TO PRECISELY MODEL AND CONSTRAIN THE ENVIRONMENT OF CALLS TO SUMMARIZED METHODS.FOR FUNCTIONS THAT ARE TRULY INDEPENDENT OF THE ENVIRONMENT, USE THE ENVFREE ANNOTATION TO ELIMINATE UNNECESSARY ENVIRONMENTAL NON - DETERMINISM.
3. ** TARGETEDLY SCOPE THE VERIFICATION **:
    *   ** USE FILTERED BLOCKS IN RULES **: FOR PARAMETRIC RULES, EXPLICITLY SPECIFY THE SCOPE OF APPLICABLE METHODS USING FILTERED BLOCKS.THIS NOT ONLY IMPROVES VERIFICATION EFFICIENCY BUT, MORE IMPORTANTLY, PREVENTS THE PROVER FROM REPORTING SPURIOUS COUNTEREXAMPLES ON METHODS WHERE THE PROPERTY IS NOT EXPECTED TO HOLD, THEREBY INCREASING THE SIGNAL - TO - NOISE RATIO OF THE VERIFICATION RESULTS.
    *   ** BE CAUTIOUS WITH FILTERS IN INVARIANTS **: ALTHOUGH FILTERED BLOCKS CAN ALSO BE USED IN INVARIANTS, THIS PRACTICE SHOULD BE AVOIDED AS IT CAN LEAD TO UNSOUNDNESS.AN INVARIANT SHOULD HOLD UNDER ALL VALID OPERATIONS.IF A METHOD BREAKS AN INVARIANT, THE ISSUE SHOULD BE ADDRESSED BY ADDING VERIFIED ASSUMPTIONS IN A preserved BLOCK OR BY MODIFYING THE INVARIANT / CODE ITSELF, RATHER THAN SIMPLY EXCLUDING THE METHOD.
\`\`\`

## conclusion
${formattedAnalyses.join('\n\n')}

## REMEDIATION STEPS

CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
CRITICAL:THE OVERRIDING PRINCIPLE FOR ALL RECOMMENDATIONS IS TO PRESERVE SOUNDNESS. THIS IS NON-NEGOTIABLE.BASED ON THIS, THE HIERARCHY OF PREFERENCE FOR FIXES IS:REQUIREINVARIANT >> HAVOC ASSUMING>FILTERED = REQUIRE
### STEP 1: ANALYZE FINDINGS INDIVIDUALLY
            - CAREFULLY REVIEW THE ${analyses.length} FINDINGS LISTED ABOVE.
- IDENTIFY THE SPECIFIC ISSUE MENTIONED IN EACH FINDING.

### STEP 2: CREATE A REMEDIATION PLAN
            - BASED ON THE WORKFLOW GUIDE, CREATE A CHECKLIST OF SPECIFIC ISSUES TO BE FIXED.
- DETERMINE THE PRIORITY AND SEQUENCE FOR THE REMEDIATION.
- IDENTIFY THE RELEVANT SPEC FILES AND CVL CODE LOCATIONS.

### STEP 3: EXECUTE REMEDIATION
            - ** DIRECTLY MODIFY THE ACTUAL.SPEC AND / OR.CONF FILES.**
                - REMEDIATE THE ISSUES SEQUENTIALLY BASED ON THE ANALYSIS FINDINGS:
        - CORRECT LOGICAL ERRORS IN THE CVL SPECIFICATIONS.
  - ADJUST CONTRADICTORY INITIAL CONDITIONS OR ASSUMPTIONS.
  - IMPROVE SPECIFICATION COVERAGE AND THE HANDLING OF BOUNDARY CONDITIONS.

            CRITICAL: PRIORITIZE THE USE OF INVARIANTS TO STRENGTHEN THE SPECIFICATION AND ELIMINATE CONTRADICTORY INITIAL STATES.AVOID USING require  OR  assume  UNLESS ABSOLUTELY NECESSARY, AS THEY CAN MASK CERTAIN SCENARIOS.

### STEP 4: SYNTAX CHECK & ITERATIVE FIXING
            - UPON COMPLETION OF FIXES, IMMEDIATELY RUN THE  certoraRun *.conf  COMMAND TO CHECK THE SPEC SYNTAX.
- IF SYNTAX ERRORS ARE FOUND, AUTOMATICALLY REPAIR THEM.
- REPEATEDLY RUN  certoraRun *.conf  UNTIL NO SYNTAX ERRORS REMAIN.
- ENSURE ALL MODIFIED SPEC FILES ARE SYNTACTICALLY CORRECT.

### STEP 5: FINAL VERIFICATION
            - EXECUTE A FULL VERIFICATION BY RUNNING certoraRun *.conf .
- MONITOR THE VERIFICATION PROGRESS AND WAIT FOR COMPLETION.THE CERTORA CLI WILL PROVIDE A COMPLETE URL.
- ** IMPORTANT: IF VERIFICATION SUCCEEDS, YOU MUST PROVIDE THE RESULT URL.**

            PLEASE BEGIN THE REMEDIATION TASK, STRICTLY ADHERING TO THE STEPS OUTLINED ABOVE: `;

        res.json({
            success: true,
            prompt: promptText
        });

    } catch (error) {
        console.error('生成 prompt 错误:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// 修改后的 /fix-all-stream 端点用于流式批量修复
app.post('/fix-all-stream', async (req, res) => {
    const { prompt, projectPath } = req.body;

    if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({
            success: false,
            error: '缺少修复 prompt'
        });
    }

    console.log(`开始流式批量修复，prompt 长度: ${prompt.length} `);
    if (projectPath) {
        console.log(`指定项目路径: ${projectPath} `);
    } else {
        console.log('使用自动项目搜索');
    }

    // 设置SSE响应头
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
    });

    const sendProgress = (message, type = 'output') => {
        res.write(`data: ${JSON.stringify({ type, message })} \n\n`);
    };

    try {
        const { spawn } = await import('child_process');

        // 清理提示文本中的null字节
        const cleanPromptText = prompt.replace(/\0/g, '');

        // 构建 Codex 命令参数 + 高级推理 + 详细推理总结
        const codexArgs = [
            'exec',
            '--dangerously-bypass-approvals-and-sandbox',
            '-c', 'model_reasoning_effort=high',
            '-c', 'model_reasoning_summary=detailed'
        ];

        // 如果用户指定了项目路径，添加 -C 参数
        if (projectPath && projectPath.trim()) {
            codexArgs.push('-C', projectPath.trim());
            sendProgress(`设置工作目录: ${projectPath.trim()} `, 'info');
        } else {
            sendProgress('开始执行修复（使用自动项目搜索）...', 'info');
        }

        codexArgs.push(cleanPromptText);

        console.log('Codex 命令参数:', codexArgs.slice(0, -1)); // 不打印完整 prompt

        // 修复阶段使用危险模式（允许完全访问和执行命令）+ 高级推理
        const codexProcess = spawn('codex', codexArgs, {
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env }
        });

        let hasError = false;

        codexProcess.stdout.on('data', (data) => {
            const output = data.toString();
            sendProgress(output, 'output');

            // 检查是否包含验证URL
            const urlMatch = output.match(/https:\/\/prover\.certora\.com\/output\/[^\s]+/);
            if (urlMatch) {
                sendProgress(urlMatch[0], 'url');
            }
        });

        codexProcess.stderr.on('data', (data) => {
            const errorOutput = data.toString();
            sendProgress(errorOutput, 'error');
        });

        codexProcess.on('error', (error) => {
            hasError = true;
            if (error.code === 'EPIPE') {
                console.log('修复进程管道关闭 (EPIPE) - 这通常是正常的');
            } else {
                console.error('修复进程错误:', error);
                sendProgress(`进程错误: ${error.message} `, 'error');
            }
        });

        codexProcess.on('close', (code) => {
            console.log(`修复进程结束，退出码: ${code} `);
            if (code === 0 && !hasError) {
                sendProgress('修复任务完成', 'success');
            } else {
                sendProgress(`修复进程异常退出，退出码: ${code} `, 'error');
            }
            res.write(`data: ${JSON.stringify({ type: 'complete' })} \n\n`);
            res.end();
        });

    } catch (error) {
        console.error('修复错误:', error);
        sendProgress(`修复错误: ${error.message} `, 'error');
        res.write(`data: ${JSON.stringify({ type: 'complete' })} \n\n`);
        res.end();
    }
});

// 保留原有的 /fix-all 端点以保持兼容性
app.post('/fix-all', async (req, res) => {
    const { analyses } = req.body;

    if (!analyses || !Array.isArray(analyses) || analyses.length === 0) {
        return res.status(400).json({
            success: false,
            error: '缺少分析结果'
        });
    }

    console.log(`开始批量修复，共 ${analyses.length} 个任务`);

    try {
        const { spawn } = await import('child_process');
        const combinedAnalysis = analyses.join('\n\n---\n\n');

        const promptText = `基于以下CVL分析结果，生成修复建议和代码改进：

${combinedAnalysis}

        请提供具体的修复步骤和代码建议。`;

        // 清理提示文本中的null字节
        const cleanPromptText = promptText.replace(/\0/g, '');

        // 修复阶段使用危险模式（允许完全访问和执行命令）+ 高级推理
        const codexProcess = spawn('codex', [
            'exec',
            '--dangerously-bypass-approvals-and-sandbox',
            '-c', 'model_reasoning_effort=high',
            '-c', 'model_reasoning_summary=detailed',
            cleanPromptText
        ], {
            stdio: ['pipe', 'pipe', 'pipe'],
            env: { ...process.env }
        });

        let output = '';
        let errorOutput = '';

        codexProcess.stdout.on('data', (data) => {
            output += data.toString();
        });

        codexProcess.stderr.on('data', (data) => {
            errorOutput += data.toString();
        });

        codexProcess.on('error', (error) => {
            if (error.code === 'EPIPE') {
                console.log('修复进程管道关闭 (EPIPE) - 这通常是正常的');
            } else {
                console.error('修复进程错误:', error);
                res.json({
                    success: false,
                    error: `进程错误: ${error.message} `
                });
            }
        });

        codexProcess.on('close', (code) => {
            console.log(`修复进程结束，退出码: ${code} `);
            if (code === 0) {
                res.json({
                    success: true,
                    message: '修复建议已生成',
                    analysis: output
                });
            } else {
                const errorMsg = errorOutput || `修复进程异常退出，码: ${code} `;
                console.error('修复执行错误:', errorMsg);
                res.json({
                    success: false,
                    error: errorMsg
                });
            }
        });

    } catch (error) {
        console.error('修复错误:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

const PORT = 3002;
app.listen(PORT, () => {
    console.log(`
╔════════════════════════════════════════════╗
║     Certora Auto Analyzer                 ║
║     服务运行在: http://localhost:${PORT}    ║
╚════════════════════════════════════════════╝
        `);
});
