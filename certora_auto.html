<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora Auto Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .url-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            transition: border-color 0.3s;
            margin-bottom: 20px;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .status-error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .result-section {
            display: none;
        }

        .result-header {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .result-title {
            font-size: 24px;
            font-weight: 700;
            color: #212529;
            margin-bottom: 10px;
        }

        .rule-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .rule-card:hover {
            border-color: #667eea;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .rule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .rule-name {
            font-weight: 600;
            color: #212529;
            font-size: 16px;
        }

        .rule-status {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-violated {
            background: #dc3545;
            color: white;
        }

        .status-timeout {
            background: #ffc107;
            color: #212529;
        }

        .json-preview {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .json-preview pre {
            margin: 0;
            white-space: pre-wrap;
        }

        .markdown-output {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .markdown-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
        }

        .markdown-title {
            font-size: 18px;
            font-weight: 600;
            color: #212529;
        }

        .markdown-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }

        .markdown-content pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .copy-btn {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .rule-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .rule-btn {
            padding: 8px 16px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rule-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .action-bar {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Certora Auto Analyzer</h1>
            <p>è‡ªåŠ¨åˆ†æå¹¶è·å–æ‰€æœ‰éverifiedè§„åˆ™çš„JSONå†…å®¹</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3 style="margin-bottom: 20px; color: #212529;">è¾“å…¥ Certora URL</h3>
                <input type="text" 
                       class="url-input" 
                       id="certora-url" 
                       placeholder="https://prover.certora.com/output/..."
                       value="">
                
                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeUrl()">
                    ğŸ” åˆ†æå¹¶è·å–æ‰€æœ‰JSON
                </button>

                <div id="status-message"></div>
            </div>

            <div id="result-section" class="result-section"></div>
        </div>
    </div>

    <script>
        let allRulesData = null;
        let jsonContents = {};

        async function analyzeUrl() {
            const url = document.getElementById('certora-url').value.trim();
            if (!url) {
                showStatus('è¯·è¾“å…¥URL', 'error');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = 'â³ åˆ†æä¸­...';
            
            showStatus('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', 'info');

            try {
                // è°ƒç”¨æœ¬åœ°æœåŠ¡
                const response = await fetch('http://localhost:3002/analyze-and-fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `æœåŠ¡å™¨é”™è¯¯: ${response.status}`);
                }

                const data = await response.json();
                allRulesData = data;
                
                // ä¿å­˜æ‰€æœ‰JSONå†…å®¹
                data.rules.forEach(rule => {
                    if (rule.content) {
                        jsonContents[rule.outputFile] = rule.content;
                    }
                });

                displayResults(data);
                showStatus(`âœ… æˆåŠŸè·å– ${data.rules.length} ä¸ªè§„åˆ™çš„æ•°æ®`, 'success');
                
            } catch (error) {
                console.error('Error:', error);
                showStatus(`é”™è¯¯: ${error.message}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†: node scripts/certora_auto_server.mjs`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ” åˆ†æå¹¶è·å–æ‰€æœ‰JSON';
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        function displayResults(data) {
            const resultSection = document.getElementById('result-section');
            
            let html = `
                <div class="result-header">
                    <div class="result-title">åˆ†æç»“æœ</div>
                    <div style="color: #6c757d; font-size: 14px;">
                        æ‰¾åˆ° ${data.rules.length} ä¸ªéverifiedè§„åˆ™<br>
                        æˆåŠŸè·å– ${data.rules.filter(r => r.content).length} ä¸ªJSONæ–‡ä»¶å†…å®¹
                    </div>
                </div>
                
                <div class="action-bar">
                    <!-- ç§»é™¤äº†ç”Ÿæˆæ‰€æœ‰Markdownæ–‡æ¡£ã€ä¸‹è½½æ‰€æœ‰JSONæ–‡ä»¶ã€å¯¼å‡ºæ±‡æ€»æŠ¥å‘ŠåŠŸèƒ½ -->
                </div>
            `;

            data.rules.forEach((rule, index) => {
                const statusClass = rule.status === 'TIMEOUT' ? 'status-timeout' : 'status-violated';
                const hasContent = rule.content !== null;
                
                html += `
                    <div class="rule-card">
                        <div class="rule-header">
                            <div class="rule-name">${formatRuleName(rule.ruleName)}</div>
                            <span class="rule-status ${statusClass}">${rule.status}</span>
                        </div>
                        
                        ${hasContent ? `
                            <div class="markdown-content" id="rule-content-${index}" style="display: none;">
                                <pre>ç”Ÿæˆä¸­...</pre>
                            </div>
                        ` : `
                            <div style="color: #dc3545; padding: 10px; background: #f8d7da; border-radius: 6px;">
                                è·å–å¤±è´¥: ${rule.error || 'æœªçŸ¥é”™è¯¯'}
                            </div>
                        `}
                        
                        <div class="rule-actions">
                            ${hasContent ? `
                                <button class="rule-btn" onclick="toggleMarkdown(${index})">
                                    ğŸ“ æ˜¾ç¤º/éšè— MD
                                </button>
                                <button class="rule-btn" onclick="copyRuleMarkdown(${index})">
                                    ğŸ“‹ å¤åˆ¶ MD
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            });

            resultSection.innerHTML = html;
            resultSection.style.display = 'block';
        }

        function generateMarkdown(index) {
            const rule = allRulesData.rules[index];
            if (!rule.content) return;

            const md = convertToMarkdown(rule);
            displayMarkdown(md, rule.ruleName); // ä½¿ç”¨è§„åˆ™åä½œä¸ºæ–‡ä»¶å
        }

        function generateAllMarkdown() {
            if (!allRulesData) return;

            // æ¸…ç©ºä¹‹å‰çš„è¾“å‡º
            const existingOutputs = document.querySelectorAll('.markdown-output');
            existingOutputs.forEach(el => el.remove());

            allRulesData.rules.forEach((rule, index) => {
                if (rule.content) {
                    const md = convertToMarkdown(rule);
                    displayMarkdown(md, rule.ruleName);
                }
            });
            
            showStatus(`âœ… å·²ç”Ÿæˆ ${allRulesData.rules.filter(r => r.content).length} ä¸ªMarkdownæ–‡æ¡£`, 'success');
            
            // æ»šåŠ¨åˆ°ç¬¬ä¸€ä¸ªç”Ÿæˆçš„æ–‡æ¡£
            setTimeout(() => {
                const firstOutput = document.querySelector('.markdown-output');
                if (firstOutput) {
                    firstOutput.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }

        // ä½¿ç”¨certora_har_to_markdown.htmlçš„å®Œæ•´è§£æé€»è¾‘
        function convertToMarkdown(rule) {
            const traceData = rule.content;
            // ç®€åŒ–è§„åˆ™åç§°ï¼Œåªä¿ç•™è¿åçš„é‚£ä¸ªruleï¼Œå»æ‰â†³åŠåé¢çš„å†…å®¹
            const simplifiedRuleName = rule.ruleName.split('â†³')[0].trim();
            let md = `# Certora Call Trace\n\n`;
            md += `**Rule:** ${simplifiedRuleName}\n`;
            md += `**Status:** ${rule.status}\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## ğŸŒ³ Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second position) - ç›´æ¥ä»variablesæ•°ç»„ä¸­æå–
            md += `\n## ğŸ“Š Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                md += renderVariablesFromArray(traceData.variables);
            } else {
                md += `æš‚æ— å˜é‡æ•°æ®\n\n`;
            }

            // 3. Global State Diff (third position) - ä»Call Traceä¸­çš„Global StateèŠ‚ç‚¹è®¡ç®—å˜åŒ–
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## ğŸ”„ Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                md += `## ğŸš¨ Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            }

            return md;
        }

        // ä»certora_har_to_markdown.htmlå¤åˆ¶çš„è¾…åŠ©å‡½æ•°
        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const value = arg.value || (arg.values && arg.values[0]) || '?';
                    messageText = messageText.replace(`{${index}}`, value);
                });
            }

            // ä¸º Global State æ·»åŠ ç¼–å·
            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // ä»variablesæ•°ç»„ä¸­æ¸²æŸ“å±‚æ¬¡ç»“æ„
        function renderVariablesFromArray(variables) {
            let md = '';
            
            variables.forEach((variable, index) => {
                // åªå¤„ç†æœ‰variableNameå­—æ®µçš„å¯¹è±¡
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // å¤„ç†æœ‰childrenListçš„å˜é‡ï¼ˆå¦‚ eï¼‰
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                    } else {
                        // ç®€å•å˜é‡ï¼Œç›´æ¥è¾“å‡ºå˜é‡åå’Œå€¼
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `${name}: \`${value}\`\n\n`;
                    }
                }
            });
            
            return md;
        }

        // å¤„ç†åµŒå¥—å˜é‡ï¼ˆå¦‚ e å˜é‡çš„å­å˜é‡ï¼‰
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];
            
            // å¦‚æœæœ‰å­å˜é‡ï¼Œé€’å½’å¤„ç†
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // ç¡®ä¿childæ˜¯æœ‰æ•ˆçš„å¯¹è±¡ä¸”æœ‰variableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // å¶èŠ‚ç‚¹ï¼Œè¾“å‡ºå®Œæ•´è·¯å¾„å’Œå€¼
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `${fullPath}: \`${value}\`\n\n`;
            }
            
            return md;
        }

        // è®¡ç®—Global Stateå·®å¼‚
        function calculateGlobalStateDiff(callTrace) {
            if (!callTrace) return {};
            
            const globalStateNodes = [];
            
            // æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
            collectGlobalStateNodes(callTrace, globalStateNodes);
            
            if (globalStateNodes.length === 0) {
                return {};
            }
            
            // æå–ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªGlobal Stateçš„çŠ¶æ€
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);
            
            // è®¡ç®—å·®å¼‚
            const diff = {};
            
            // æ”¶é›†æ‰€æœ‰çŠ¶æ€é”®
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);
            
            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];
                
                // åªæœ‰å½“å€¼ç¡®å®å‘ç”Ÿå˜åŒ–æ—¶æ‰è®°å½•
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                } else if (firstValue && lastValue) {
                    // å€¼æ²¡æœ‰å˜åŒ–ï¼Œä½†å­˜åœ¨äºä¸¤ä¸ªçŠ¶æ€ä¸­
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                }
            });
            
            return diff;
        }

        // é€’å½’æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }
            
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // ä»Global StateèŠ‚ç‚¹ä¸­æå–çŠ¶æ€ä¿¡æ¯
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};
            
            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
            
            return state;
        }

        // é€’å½’æå–çŠ¶æ€ä¿¡æ¯
        function extractStateRecursively(node, state) {
            // å¦‚æœèŠ‚ç‚¹æœ‰argumentsï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªçŠ¶æ€è®°å½•
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // æ›¿æ¢å ä½ç¬¦å¾—åˆ°å®Œæ•´çš„çŠ¶æ€è·¯å¾„
                let fullPath = node.message.text;
                let stateValue = null;
                
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // ä½¿ç”¨æœ€æ˜“è¯»çš„å€¼è¡¨ç¤º
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // å¦‚æœæœ‰åè¿›åˆ¶è¡¨ç¤ºï¼Œä¼˜å…ˆä½¿ç”¨
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);
                            
                            // æœ€åä¸€ä¸ªå‚æ•°é€šå¸¸æ˜¯å€¼
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });
                
                // è§£æè·¯å¾„å’Œå€¼
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }
            
            // é€’å½’å¤„ç†å­èŠ‚ç‚¹
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // è§£æçŠ¶æ€è·¯å¾„
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }
            
            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();
            
            // å¦‚æœæœ‰ä»argumentsä¸­æå–çš„å€¼ï¼Œä¼˜å…ˆä½¿ç”¨
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }
            
            // æ¸…ç†å¼•å·
            value = value.replace(/^['"]|['"]$/g, '');
            
            return { path, value };
        }

        // æ¸²æŸ“Global Stateå·®å¼‚
        function renderGlobalStateDiff(diff) {
            let md = '';
            
            // æŒ‰è·¯å¾„ç±»å‹åˆ†ç»„
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] }
            };
            
            Object.entries(diff).forEach(([path, change]) => {
                let groupType = 'storage'; // é»˜è®¤åˆ†ç±»ä¸ºstorage
                
                if (path.includes('.balance:') || path.endsWith('.balance')) {
                    groupType = 'balance';
                } else if (path.includes('isInPlotIndexes') || path.includes('sumOfHarvestedBeans')) {
                    groupType = 'ghost';
                } else if (path.startsWith('s.') || path.includes('s.accts') || path.includes('s.sys')) {
                    groupType = 'storage';
                }
                
                groups[groupType].items.push({ path, change });
            });
            
            // æ¸²æŸ“å„ç»„
            Object.entries(groups).forEach(([groupKey, group]) => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    
                    group.items.forEach(({ path, change }) => {
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` â†’ \`${change.to}\`\n\n`;
                        } else {
                            md += `- **${path}**: \`${change.to}\` *(unchanged)*\n\n`;
                        }
                    });
                    
                    md += `\n`;
                }
            });
            
            return md;
        }

        // æ ¼å¼åŒ–è§„åˆ™åç§°ï¼Œæ˜¾ç¤ºå±‚çº§ç»“æ„
        function formatRuleName(ruleName) {
            const parts = ruleName.split(' > ');
            if (parts.length === 1) {
                return `<strong>${parts[0]}</strong>`;
            }
            
            // ä¸»è§„åˆ™å
            let formatted = `<strong>${parts[0]}</strong>`;
            
            // å¦‚æœæœ‰å­çº§ï¼Œæ˜¾ç¤ºæœ€åä¸€çº§å’Œå±‚çº§æ•°
            if (parts.length > 1) {
                const lastPart = parts[parts.length - 1];
                formatted += `<br><span style="color: #6c757d; font-size: 13px; margin-left: 20px;">
                    â†³ ${lastPart} <em>(å±‚çº§: ${parts.length})</em>
                </span>`;
            }
            
            return formatted;
        }

        // è·å–ç®€åŒ–çš„æ–‡ä»¶å
        function getSimpleFileName(ruleName) {
            const parts = ruleName.split(' > ');
            // å–ä¸»è§„åˆ™åå’Œæœ€åä¸€éƒ¨åˆ†
            if (parts.length === 1) {
                return parts[0];
            }
            // å¦‚æœæœ‰å¤šå±‚ï¼Œä½¿ç”¨ä¸»è§„åˆ™å_æœ€åä¸€å±‚
            const mainRule = parts[0];
            const lastPart = parts[parts.length - 1]
                .replace(/[\(\)]/g, '')
                .replace(/[,\s]+/g, '_')
                .substring(0, 30); // é™åˆ¶é•¿åº¦
            return `${mainRule}_${lastPart}`;
        }

        function displayMarkdown(content, ruleName) {
            // ä½¿ç”¨ç®€åŒ–çš„æ–‡ä»¶å
            const fileName = getSimpleFileName(ruleName);
            const cleanName = fileName.replace(/[^a-zA-Z0-9_-]/g, '_').replace(/__+/g, '_');
            
            // åˆ›å»ºæ˜¾ç¤ºå®¹å™¨
            const outputDiv = document.createElement('div');
            outputDiv.className = 'markdown-output';
            outputDiv.innerHTML = `
                <div class="markdown-header">
                    <div class="markdown-title">
                        ğŸ“ ${cleanName}.md
                    </div>
                    <button class="copy-btn" onclick="copyMarkdown(this)">
                        ğŸ“‹ å¤åˆ¶ Markdown
                    </button>
                </div>
                <div class="markdown-content">
                    <pre>${escapeHtml(content)}</pre>
                </div>
            `;
            
            // å°†è¾“å‡ºæ·»åŠ åˆ°ç»“æœåŒºåŸŸ
            const resultSection = document.getElementById('result-section');
            resultSection.appendChild(outputDiv);
        }

        function copyMarkdown(button) {
            const markdownContent = button.closest('.markdown-output').querySelector('pre').textContent;
            
            navigator.clipboard.writeText(markdownContent).then(() => {
                const originalText = button.textContent;
                button.textContent = 'ğŸ‰ å·²å¤åˆ¶ï¼';
                button.style.background = '#28a745';
                button.style.color = 'white';
                
                showStatus('ğŸ‰ Markdownå·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                showCopySuccess();
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                    button.style.color = '';
                }, 3000);
            }).catch(err => {
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = markdownContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                button.textContent = 'ğŸ‰ å·²å¤åˆ¶ï¼';
                showStatus('ğŸ‰ Markdownå·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                showCopySuccess();
                setTimeout(() => {
                    button.textContent = 'ğŸ“‹ å¤åˆ¶ Markdown';
                }, 3000);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸçš„åŠ¨ç”»æç¤º
        function showCopySuccess() {
            // åˆ›å»ºä¸´æ—¶æç¤ºå…ƒç´ 
            const notification = document.createElement('div');
            notification.innerHTML = 'ğŸ‰ å¤åˆ¶æˆåŠŸï¼';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #28a745;
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 10000;
                animation: copySuccessAnimation 0.6s ease-out;
            `;
            
            // æ·»åŠ CSSåŠ¨ç”»
            if (!document.querySelector('#copySuccessStyle')) {
                const style = document.createElement('style');
                style.id = 'copySuccessStyle';
                style.textContent = `
                    @keyframes copySuccessAnimation {
                        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // 2ç§’åç§»é™¤
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        // åˆ‡æ¢å•ä¸ªè§„åˆ™çš„Markdownæ˜¾ç¤º
        function toggleMarkdown(index) {
            const rule = allRulesData.rules[index];
            if (!rule.content) return;
            
            const contentDiv = document.getElementById(`rule-content-${index}`);
            
            if (contentDiv.style.display === 'none') {
                // ç”Ÿæˆå¹¶æ˜¾ç¤ºMarkdown
                const md = convertToMarkdown(rule);
                contentDiv.innerHTML = `<pre>${escapeHtml(md)}</pre>`;
                contentDiv.style.display = 'block';
            } else {
                // éšè—Markdown
                contentDiv.style.display = 'none';
            }
        }

        // å¤åˆ¶å•ä¸ªè§„åˆ™çš„Markdown
        function copyRuleMarkdown(index) {
            const rule = allRulesData.rules[index];
            if (!rule.content) return;
            
            const md = convertToMarkdown(rule);
            
            navigator.clipboard.writeText(md).then(() => {
                showStatus('ğŸ‰ Markdownå·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                // æ·»åŠ ä¸´æ—¶é«˜äº®æç¤º
                showCopySuccess();
            }).catch(() => {
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = md;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('ğŸ‰ Markdownå·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                showCopySuccess();
            });
        }

        function downloadJson(index) {
            const rule = allRulesData.rules[index];
            if (!rule.content) return;

            const blob = new Blob([JSON.stringify(rule.content, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = rule.outputFile;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadAllJsons() {
            if (!allRulesData) return;

            allRulesData.rules.forEach(rule => {
                if (rule.content) {
                    const blob = new Blob([JSON.stringify(rule.content, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = rule.outputFile;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            });
        }

        function exportSummary() {
            if (!allRulesData) return;

            let summary = `# Certora Analysis Summary\n\n`;
            summary += `**URL:** ${allRulesData.url}\n`;
            summary += `**Time:** ${new Date(allRulesData.timestamp).toLocaleString('zh-CN')}\n`;
            summary += `**Total Rules:** ${allRulesData.totalRules}\n\n`;
            
            summary += `## Failed Rules\n\n`;
            allRulesData.rules.forEach((rule, i) => {
                summary += `${i + 1}. **${rule.ruleName}**\n`;
                summary += `   - Status: ${rule.status}\n`;
                summary += `   - File: ${rule.outputFile}\n`;
                summary += `   - Content: ${rule.content ? 'âœ… Retrieved' : 'âŒ Failed'}\n\n`;
            });
            
            downloadMarkdown(summary, 'certora_summary.md');
            showStatus('âœ… æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        // å¯åŠ¨æç¤º
        window.addEventListener('DOMContentLoaded', () => {
            showStatus('è¯·å…ˆè¿è¡Œ: node scripts/certora_auto_server.mjs', 'info');
        });
    </script>
</body>
</html>