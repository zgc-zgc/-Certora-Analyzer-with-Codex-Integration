<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora HAR to Markdown Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 16px;
            opacity: 0.9;
        }

        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .file-upload-area {
            border: 3px dashed #6c757d;
            border-radius: 12px;
            padding: 60px 20px;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .file-upload-area:hover,
        .file-upload-area.dragover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
        }

        .upload-subtext {
            color: #6c757d;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .upload-btn:hover {
            background: #5a67d8;
        }

        .result-section {
            padding: 40px;
            display: none;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .result-title {
            font-size: 24px;
            font-weight: 700;
            color: #212529;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #28a745;
            color: white;
        }

        .btn-primary:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .markdown-preview {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 600px;
            overflow-y: auto;
            color: #212529;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .loading::before {
            content: '‚ü≥';
            font-size: 24px;
            animation: spin 1s linear infinite;
            display: block;
            margin-bottom: 10px;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-weight: 600;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Certora HAR to Markdown</h1>
            <p>Â∞Ü Certora Prover ÁöÑ HAR Êñá‰ª∂ËΩ¨Êç¢‰∏∫ AI ÂèãÂ•ΩÁöÑ Markdown Ê†ºÂºè</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="file-upload-area" id="uploadArea">
                <div class="upload-icon">üìÇ</div>
                <div class="upload-text">ÈÄâÊã© HAR Êñá‰ª∂</div>
                <div class="upload-subtext">ÊàñÂ∞ÜÊñá‰ª∂ÊãñÊîæÂà∞Ê≠§Â§Ñ</div>
                <input type="file" id="fileInput" class="file-input" accept=".har" />
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    ÈÄâÊã©Êñá‰ª∂
                </button>
            </div>
        </div>

        <!-- Result Section -->
        <div class="result-section" id="resultSection">
            <div class="result-header">
                <div class="result-title">Markdown ËæìÂá∫</div>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="copyMarkdown()">
                        üìã Â§çÂà∂ Markdown
                    </button>
                    <button class="btn btn-secondary" onclick="resetUpload()">
                        üîÑ ÈáçÊñ∞‰∏ä‰º†
                    </button>
                </div>
            </div>
            <div class="markdown-preview" id="markdownContent"></div>
        </div>
    </div>

    <script>
        let markdownContent = '';
        
        // Êó•ÂøóËÆ∞ÂΩïÁ≥ªÁªü
        const CertoraLogger = {
            logs: [],
            
            log(level, category, message, data = null) {
                const timestamp = new Date().toISOString();
                const logEntry = {
                    timestamp,
                    level,
                    category,
                    message,
                    data
                };
                
                this.logs.push(logEntry);
                
                // Ê†πÊçÆÁ∫ßÂà´ÂÜ≥ÂÆöÊòØÂê¶Âú®ÊéßÂà∂Âè∞ËæìÂá∫
                if (level === 'ERROR') {
                    console.error(`[Certora ${category}] ${message}`, data);
                } else if (level === 'WARN') {
                    console.warn(`[Certora ${category}] ${message}`, data);
                } else if (level === 'INFO') {
                    console.log(`[Certora ${category}] ${message}`, data);
                }
            },
            
            info(category, message, data = null) {
                this.log('INFO', category, message, data);
            },
            
            warn(category, message, data = null) {
                this.log('WARN', category, message, data);
            },
            
            error(category, message, data = null) {
                this.log('ERROR', category, message, data);
            },
            
            // Ëé∑ÂèñËß£ÊûêÁªüËÆ°
            getStats() {
                const stats = {
                    total: this.logs.length,
                    errors: this.logs.filter(log => log.level === 'ERROR').length,
                    warnings: this.logs.filter(log => log.level === 'WARN').length,
                    categories: {}
                };
                
                this.logs.forEach(log => {
                    if (!stats.categories[log.category]) {
                        stats.categories[log.category] = { info: 0, warn: 0, error: 0 };
                    }
                    stats.categories[log.category][log.level.toLowerCase()]++;
                });
                
                return stats;
            },
            
            // ÂØºÂá∫Êó•Âøó
            exportLogs() {
                return JSON.stringify(this.logs, null, 2);
            }
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeFileUpload();
        });

        function initializeFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // Click to upload - ÈÅøÂÖçÁÇπÂáªÊåâÈíÆÊó∂Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
            uploadArea.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') {
                    fileInput.click();
                }
            });

            // File input change
            fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, unhighlight, false);
            });

            uploadArea.addEventListener('drop', handleDrop, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function unhighlight(e) {
            document.getElementById('uploadArea').classList.remove('dragover');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                handleFileSelect({ target: { files: files } });
            }
        }

        function handleFileSelect(event) {
            console.log('handleFileSelect called', event);
            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('File selected:', file.name, file.type, file.size);

            const fileName = file.name.toLowerCase();
            if (!fileName.endsWith('.har')) {
                console.log('Invalid file type:', fileName);
                showNotification('ËØ∑ÈÄâÊã© HAR Êñá‰ª∂', 'error');
                return;
            }

            console.log('Starting to process HAR file...');
            showLoading();

            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('File read complete, content length:', e.target.result.length);
                try {
                    const fileContent = JSON.parse(e.target.result);
                    console.log('JSON parsed successfully');
                    const jsonData = extractJsonFromHar(fileContent);
                    
                    if (!jsonData) {
                        throw new Error('HAR Êñá‰ª∂‰∏≠Êú™ÊâæÂà∞ÊúâÊïàÁöÑ trace Êï∞ÊçÆ');
                    }
                    
                    console.log('JSON data extracted, converting to markdown...');
                    markdownContent = convertToMarkdown(jsonData, file.name);
                    console.log('Markdown generated, length:', markdownContent.length);
                    showResult();
                    
                } catch (error) {
                    console.error('Error parsing file:', error);
                    showNotification('Êñá‰ª∂Ëß£ÊûêÈîôËØØÔºö' + error.message, 'error');
                    hideLoading();
                }
            };
            
            reader.onerror = function(e) {
                console.error('FileReader error:', e);
                showNotification('Êñá‰ª∂ËØªÂèñÂ§±Ë¥•', 'error');
                hideLoading();
            };
            
            reader.readAsText(file);
        }

        function extractJsonFromHar(harData) {
            CertoraLogger.info('HAR_PARSING', 'Starting HAR file extraction');
            
            try {
                if (harData.log && harData.log.entries) {
                    CertoraLogger.info('HAR_PARSING', `Found ${harData.log.entries.length} HAR entries`);
                    
                    for (const entry of harData.log.entries) {
                        if (entry.response && entry.response.content && entry.response.content.text) {
                            const text = entry.response.content.text;
                            try {
                                const jsonData = JSON.parse(text);
                                if (jsonData.callTrace || jsonData.treeViewPath) {
                                    CertoraLogger.info('HAR_PARSING', 'Successfully found valid trace data in HAR');
                                    return jsonData;
                                }
                            } catch (e) {
                                continue;
                            }
                        }
                    }
                    
                    CertoraLogger.warn('HAR_PARSING', 'No valid trace data found in any HAR entry');
                } else {
                    CertoraLogger.error('HAR_PARSING', 'HAR file missing log or entries structure');
                }
                return null;
            } catch (error) {
                CertoraLogger.error('HAR_PARSING', 'Error extracting JSON from HAR', error);
                return null;
            }
        }

        function convertToMarkdown(traceData, fileName) {
            let md = `# Certora Trace Analysis\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## üå≥ Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second position) - Áõ¥Êé•‰ªévariablesÊï∞ÁªÑ‰∏≠ÊèêÂèñ
            md += `\n## üìä Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                CertoraLogger.info('VARIABLES', `Found ${traceData.variables.length} variables in data`);
                md += renderVariablesFromArray(traceData.variables);
            } else {
                if (!traceData.variables) {
                    CertoraLogger.warn('VARIABLES', 'Variables field missing from trace data');
                } else if (!Array.isArray(traceData.variables)) {
                    CertoraLogger.warn('VARIABLES', 'Variables field is not an array', traceData.variables);
                } else {
                    CertoraLogger.warn('VARIABLES', 'Variables array is empty');
                }
                md += `ÊöÇÊó†ÂèòÈáèÊï∞ÊçÆ\n\n`;
            }

            // 3. Global State Diff (third position) - ‰ªéCall Trace‰∏≠ÁöÑGlobal StateËäÇÁÇπËÆ°ÁÆóÂèòÂåñ
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## üîÑ Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                CertoraLogger.info('WARNINGS', `Found ${traceData.callResolutionWarnings.length} call resolution warnings`);
                md += `## üö® Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            } else {
                if (!traceData.callResolutionWarnings) {
                    CertoraLogger.info('WARNINGS', 'No callResolutionWarnings field in trace data');
                } else {
                    CertoraLogger.info('WARNINGS', 'Call resolution warnings array is empty');
                }
            }


            CertoraLogger.info('CONVERSION', 'Markdown conversion completed', { 
                markdownLength: md.length 
            });

            return md;
        }

        // ‰ªévariablesÊï∞ÁªÑ‰∏≠Ê∏≤ÊüìÂ±ÇÊ¨°ÁªìÊûÑ
        function renderVariablesFromArray(variables) {
            let md = '';
            let processedCount = 0;
            let skippedCount = 0;
            
            variables.forEach((variable, index) => {
                // Âè™Â§ÑÁêÜÊúâvariableNameÂ≠óÊÆµÁöÑÂØπË±°
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // Â§ÑÁêÜÊúâchildrenListÁöÑÂèòÈáèÔºàÂ¶Ç eÔºâ
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                        CertoraLogger.info('VARIABLES', `Processed nested variable: ${variable.variableName} (${variable.childrenList.length} children)`);
                    } else {
                        // ÁÆÄÂçïÂèòÈáèÔºåÁõ¥Êé•ËæìÂá∫ÂèòÈáèÂêçÂíåÂÄº
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `${name}: \`${value}\`\n\n`;
                        CertoraLogger.info('VARIABLES', `Processed simple variable: ${name} = ${value}`);
                    }
                    processedCount++;
                } else {
                    skippedCount++;
                    CertoraLogger.warn('VARIABLES', `Skipped invalid variable at index ${index}`, variable);
                }
            });
            
            CertoraLogger.info('VARIABLES', `Variables processing complete: ${processedCount} processed, ${skippedCount} skipped`);
            return md;
        }

        // Â§ÑÁêÜÂµåÂ•óÂèòÈáèÔºàÂ¶Ç e ÂèòÈáèÁöÑÂ≠êÂèòÈáèÔºâ
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];
            
            // Â¶ÇÊûúÊúâÂ≠êÂèòÈáèÔºåÈÄíÂΩíÂ§ÑÁêÜ
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // Á°Æ‰øùchildÊòØÊúâÊïàÁöÑÂØπË±°‰∏îÊúâvariableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // Âè∂ËäÇÁÇπÔºåËæìÂá∫ÂÆåÊï¥Ë∑ØÂæÑÂíåÂÄº
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `${fullPath}: \`${value}\`\n\n`;
            }
            
            return md;
        }

        // ËÆ°ÁÆóGlobal StateÂ∑ÆÂºÇ - ÈÄöËøáÈÅçÂéÜÊâÄÊúâGlobal StateËäÇÁÇπ
        function calculateGlobalStateDiff(callTrace) {
            CertoraLogger.info('GLOBAL_STATE', 'Starting Global State diff calculation');
            const globalStateNodes = [];
            
            // Êî∂ÈõÜÊâÄÊúâGlobal StateËäÇÁÇπ
            collectGlobalStateNodes(callTrace, globalStateNodes);
            
            if (globalStateNodes.length === 0) {
                CertoraLogger.warn('GLOBAL_STATE', 'No Global State nodes found in call trace');
                return {};
            }
            
            CertoraLogger.info('GLOBAL_STATE', `Found ${globalStateNodes.length} Global State nodes`);
            
            // ÊèêÂèñÁ¨¨‰∏Ä‰∏™ÂíåÊúÄÂêé‰∏Ä‰∏™Global StateÁöÑÁä∂ÊÄÅ
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);
            
            CertoraLogger.info('GLOBAL_STATE', `First state has ${Object.keys(firstState).length} keys`);
            CertoraLogger.info('GLOBAL_STATE', `Last state has ${Object.keys(lastState).length} keys`);
            
            // ËÆ°ÁÆóÂ∑ÆÂºÇ
            const diff = {};
            let changedCount = 0;
            let unchangedCount = 0;
            
            // Êî∂ÈõÜÊâÄÊúâÁä∂ÊÄÅÈîÆ
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);
            
            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];
                
                // Âè™ÊúâÂΩìÂÄºÁ°ÆÂÆûÂèëÁîüÂèòÂåñÊó∂ÊâçËÆ∞ÂΩï
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                    changedCount++;
                    CertoraLogger.info('GLOBAL_STATE', `State changed: ${key}`, { from: firstValue, to: lastValue });
                } else if (firstValue && lastValue) {
                    // ÂÄºÊ≤°ÊúâÂèòÂåñÔºå‰ΩÜÂ≠òÂú®‰∫é‰∏§‰∏™Áä∂ÊÄÅ‰∏≠
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                    unchangedCount++;
                }
            });
            
            CertoraLogger.info('GLOBAL_STATE', `State diff complete: ${changedCount} changed, ${unchangedCount} unchanged`);
            return diff;
        }

        // ÈÄíÂΩíÊî∂ÈõÜÊâÄÊúâGlobal StateËäÇÁÇπ
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }
            
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // ‰ªéGlobal StateËäÇÁÇπ‰∏≠ÊèêÂèñÁä∂ÊÄÅ‰ø°ÊÅØ
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};
            
            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
            
            return state;
        }

        // ÈÄíÂΩíÊèêÂèñÁä∂ÊÄÅ‰ø°ÊÅØ
        function extractStateRecursively(node, state) {
            // Â¶ÇÊûúËäÇÁÇπÊúâargumentsÔºåËØ¥ÊòéËøôÊòØ‰∏Ä‰∏™Áä∂ÊÄÅËÆ∞ÂΩï
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // ÊõøÊç¢Âç†‰ΩçÁ¨¶ÂæóÂà∞ÂÆåÊï¥ÁöÑÁä∂ÊÄÅË∑ØÂæÑ
                let fullPath = node.message.text;
                let stateValue = null;
                
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // ‰ΩøÁî®ÊúÄÊòìËØªÁöÑÂÄºË°®Á§∫
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // Â¶ÇÊûúÊúâÂçÅËøõÂà∂Ë°®Á§∫Ôºå‰ºòÂÖà‰ΩøÁî®
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);
                            
                            // ÊúÄÂêé‰∏Ä‰∏™ÂèÇÊï∞ÈÄöÂ∏∏ÊòØÂÄº
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });
                
                // Ëß£ÊûêË∑ØÂæÑÂíåÂÄº
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }
            
            // ÈÄíÂΩíÂ§ÑÁêÜÂ≠êËäÇÁÇπ
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // Ëß£ÊûêÁä∂ÊÄÅË∑ØÂæÑ
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }
            
            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();
            
            // Â¶ÇÊûúÊúâ‰ªéarguments‰∏≠ÊèêÂèñÁöÑÂÄºÔºå‰ºòÂÖà‰ΩøÁî®
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }
            
            // Ê∏ÖÁêÜÂºïÂè∑
            value = value.replace(/^['"]|['"]$/g, '');
            
            return { path, value };
        }

        // Ê∏≤ÊüìGlobal StateÂ∑ÆÂºÇ
        function renderGlobalStateDiff(diff) {
            let md = '';
            
            // ÊåâË∑ØÂæÑÁ±ªÂûãÂàÜÁªÑ
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] }
            };
            
            Object.entries(diff).forEach(([path, change]) => {
                let groupType = 'storage'; // ÈªòËÆ§ÂàÜÁ±ª‰∏∫storage
                
                if (path.includes('.balance:') || path.endsWith('.balance')) {
                    groupType = 'balance';
                } else if (path.includes('isInPlotIndexes') || path.includes('sumOfHarvestedBeans')) {
                    groupType = 'ghost';
                } else if (path.startsWith('s.') || path.includes('s.accts') || path.includes('s.sys')) {
                    groupType = 'storage';
                }
                
                groups[groupType].items.push({ path, change });
            });
            
            // Ê∏≤ÊüìÂêÑÁªÑ
            Object.entries(groups).forEach(([groupKey, group]) => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    
                    group.items.forEach(({ path, change }) => {
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` ‚Üí \`${change.to}\`\n\n`;
                        } else {
                            md += `- **${path}**: \`${change.to}\` *(unchanged)*\n\n`;
                        }
                    });
                    
                    md += `\n`;
                }
            });
            
            return md;
        }

        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const value = arg.value || (arg.values && arg.values[0]) || '?';
                    messageText = messageText.replace(`{${index}}`, value);
                });
            }

            // ‰∏∫ Global State Ê∑ªÂä†ÁºñÂè∑
            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // ÊåâÈîÆÂàÜÁªÑÁä∂ÊÄÅÂèòÂåñÔºåÁî®‰∫éÊòæÁ§∫ÂÄºÁöÑÂèòÂåñ
        function groupStateChangesByKey(stateChanges) {
            const keyGroups = {};
            
            stateChanges.forEach(change => {
                const parsed = parseStateChangeString(change.text);
                if (parsed.fullPath && parsed.value !== null) {
                    // ÊèêÂèñ‰∏ªÈîÆÔºàÂéªÊéâÂÖ∑‰ΩìÁöÑÂÄºÔºå‰øùÁïôË∑ØÂæÑÁªìÊûÑÔºâ
                    let key = parsed.fullPath;
                    
                    // ÁÆÄÂåñÈîÆÂêçÔºåÁßªÈô§ÂÖ∑‰ΩìÁöÑÂú∞ÂùÄÂíåÁ¥¢ÂºïÂÄºÔºå‰øùÁïôÁªìÊûÑ
                    key = key.replace(/0x[0-9a-fA-F]+/g, '[ADDRESS]')
                             .replace(/'\d+'/g, '[INDEX]')
                             .replace(/\['\w+'\]/g, '[KEY]');
                    
                    if (!keyGroups[key]) {
                        keyGroups[key] = [];
                    }
                    
                    keyGroups[key].push({
                        text: change.text,
                        value: parsed.value,
                        status: change.status,
                        fullPath: parsed.fullPath
                    });
                } else {
                    // ÂØπ‰∫éÊó†Ê≥ïËß£ÊûêÁöÑÂèòÂåñÔºå‰ΩøÁî®ÂéüÂßãÊñáÊú¨‰Ωú‰∏∫ÈîÆ
                    const key = change.text.replace(/0x[0-9a-fA-F]+/g, '[ADDRESS]');
                    if (!keyGroups[key]) {
                        keyGroups[key] = [];
                    }
                    keyGroups[key].push(change);
                }
            });
            
            return keyGroups;
        }

        function extractVariables(node, variables = new Set()) {
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    if (arg.tooltip && arg.value && arg.tooltip !== 'unused value' && arg.value !== '*') {
                        if (arg.tooltip.includes('key') || arg.tooltip.includes('value') || 
                            arg.tooltip.includes('storage') || arg.tooltip.includes('balance') || 
                            arg.tooltip.includes('ghost')) {
                            const name = arg.tooltip;
                            let value = arg.value;
                            
                            if (arg.values && arg.values.length > 1) {
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value);
                                if (decValue && !isNaN(decValue) && parseInt(decValue) < 1000000) {
                                    value = `${arg.value} (${decValue})`;
                                }
                            }
                            
                            if (name && value) {
                                variables.add(JSON.stringify({ name, value, type: arg.tooltip }));
                            }
                        }
                    }
                });
            }

            if (node.childrenList) {
                node.childrenList.forEach(child => extractVariables(child, variables));
            }

            return variables;
        }

        function groupVariables(variables) {
            const grouped = {
                'key': [],
                'storage value': [], 
                'balance': [],
                'ghost value': [],
                'other': []
            };

            variables.forEach(variable => {
                const type = variable.type.toLowerCase();
                if (type.includes('key')) {
                    grouped.key.push(variable);
                } else if (type.includes('storage value')) {
                    grouped['storage value'].push(variable);
                } else if (type.includes('balance')) {
                    grouped.balance.push(variable);
                } else if (type.includes('ghost')) {
                    grouped['ghost value'].push(variable);
                } else {
                    grouped.other.push(variable);
                }
            });

            return grouped;
        }

        function extractStateChanges(node, changes = []) {
            if (node.message?.text) {
                let text = node.message.text;
                
                if (text.includes('s.') && (text.includes('accts') || text.includes('sys') || 
                    text.includes('fields') || text.includes('plots'))) {
                    if (node.message.arguments) {
                        node.message.arguments.forEach((arg, index) => {
                            const placeholder = `{${index}}`;
                            if (text.includes(placeholder) && arg.value && arg.value !== '*') {
                                let value = arg.value;
                                if (arg.values && arg.values.length > 1) {
                                    const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value);
                                    if (decValue && !isNaN(decValue) && parseInt(decValue) < 1000000) {
                                        value = `${arg.value} (${decValue})`;
                                    }
                                }
                                text = text.replace(placeholder, value);
                            }
                        });
                    }
                    
                    if (!text.includes('{') || !text.includes('}')) {
                        changes.push({
                            text: text,
                            status: node.status,
                            type: getStateChangeType(text)
                        });
                    }
                }
            }

            if (node.childrenList) {
                node.childrenList.forEach(child => extractStateChanges(child, changes));
            }

            return changes;
        }

        function getStateChangeType(changeText) {
            if (changeText.includes('accts')) return 'account';
            if (changeText.includes('sys.fields')) return 'field';
            if (changeText.includes('sys.bean')) return 'bean';
            if (changeText.includes('plots')) return 'plot';
            if (changeText.includes('balance')) return 'balance';
            if (changeText.includes('sys.silo')) return 'silo';
            if (changeText.includes('sys.pod')) return 'pod';
            return 'other';
        }

        function groupStateChanges(changes) {
            const grouped = {
                'account': [],
                'field': [],
                'bean': [],
                'plot': [],
                'balance': [],
                'silo': [],
                'pod': [],
                'other': []
            };

            changes.forEach(change => {
                grouped[change.type].push(change);
            });

            return grouped;
        }

        function parseStateChangeString(changeStr) {
            const colonIndex = changeStr.indexOf(': ');
            if (colonIndex === -1) {
                return { fullPath: changeStr.trim(), value: null };
            }
            
            const fullPath = changeStr.substring(0, colonIndex).trim();
            const value = changeStr.substring(colonIndex + 2).trim();
            const cleanValue = value.replace(/^['\"](.*)['\"]$/, '$1');
            
            return { fullPath, value: cleanValue };
        }

        function showLoading() {
            const resultSection = document.getElementById('resultSection');
            resultSection.style.display = 'block';
            resultSection.innerHTML = '<div class="loading">Ê≠£Âú®Ëß£Êûê HAR Êñá‰ª∂...</div>';
            document.getElementById('uploadSection').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
        }

        function showResult() {
            const resultSection = document.getElementById('resultSection');
            const stats = CertoraLogger.getStats();
            
            // ÊûÑÂª∫Êó•ÂøóÁªüËÆ°HTML
            let statsHtml = `
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                    <h4 style="margin: 0 0 10px 0; color: #495057;">üìã Ëß£ÊûêÊó•ÂøóÁªüËÆ°</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; font-size: 13px;">
                        <div><strong>ÊÄªÊó•ÂøóÊï∞:</strong> ${stats.total}</div>
                        <div style="color: #dc3545;"><strong>ÈîôËØØ:</strong> ${stats.errors}</div>
                        <div style="color: #ffc107;"><strong>Ë≠¶Âëä:</strong> ${stats.warnings}</div>
                        <div style="color: #28a745;"><strong>‰ø°ÊÅØ:</strong> ${stats.total - stats.errors - stats.warnings}</div>
                    </div>`;
            
            if (Object.keys(stats.categories).length > 0) {
                statsHtml += `
                    <div style="margin-top: 15px;">
                        <strong>ÂàÜÁ±ªÁªüËÆ°:</strong>
                        <div style="margin-top: 5px; font-size: 12px;">`;
                
                Object.entries(stats.categories).forEach(([category, counts]) => {
                    const total = counts.info + counts.warn + counts.error;
                    statsHtml += `
                        <div style="margin: 2px 0; padding: 2px 8px; background: white; border-radius: 4px;">
                            <strong>${category}:</strong> ${total} Êù° 
                            (ÈîôËØØ: ${counts.error}, Ë≠¶Âëä: ${counts.warn}, ‰ø°ÊÅØ: ${counts.info})
                        </div>`;
                });
                
                statsHtml += `</div></div>`;
            }
            
            statsHtml += `</div>`;
            
            resultSection.innerHTML = `
                <div class="result-header">
                    <div class="result-title">Markdown ËæìÂá∫</div>
                    <div class="action-buttons">
                        <button class="btn btn-primary" onclick="copyMarkdown()">
                            üìã Â§çÂà∂ Markdown
                        </button>
                        <button class="btn btn-secondary" onclick="resetUpload()">
                            üîÑ ÈáçÊñ∞‰∏ä‰º†
                        </button>
                    </div>
                </div>
                ${statsHtml}
                <div class="markdown-preview" id="markdownContent">${escapeHtml(markdownContent)}</div>
            `;
        }

        function copyMarkdown() {
            navigator.clipboard.writeText(markdownContent).then(() => {
                showNotification('Markdown ÂÜÖÂÆπÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ', 'success');
            }).catch(() => {
                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = markdownContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('Markdown ÂÜÖÂÆπÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ', 'success');
            });
        }

        function resetUpload() {
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
            markdownContent = '';
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.background = type === 'error' ? '#dc3545' : '#28a745';
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>