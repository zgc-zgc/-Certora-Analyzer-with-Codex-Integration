<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora Analyzer with Codex</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .url-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            transition: border-color 0.3s;
            margin-bottom: 20px;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .status-error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .result-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-violated {
            background: #dc3545;
            color: white;
        }

        .status-sanity-failed {
            background: #fd7e14;
            color: white;
        }

        .status-timeout {
            background: #6c757d;
            color: white;
        }

        .codex-analysis {
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            overflow-y: auto;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .codex-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .codex-content {
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .action-buttons {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .prover-url {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border-radius: 10px;
            display: none;
        }

        .prover-url a {
            color: #155724;
            font-weight: 600;
        }

        .markdown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .markdown-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-modal:hover {
            color: #333;
        }

        .markdown-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
        }

        .copy-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .copy-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4);
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
        }

        .copy-btn:active {
            transform: translateY(0);
        }

        .view-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .view-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
        }

        .view-btn:active {
            transform: translateY(0);
        }

        .copy-btn-small {
            background: rgba(23, 162, 184, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .copy-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(19, 132, 150, 0.95);
        }

        .edit-btn-small {
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .edit-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(90, 110, 210, 0.95);
        }

        /* æ–°å¢æ ·å¼ï¼šä¿®å¤ prompt é¢„è§ˆç•Œé¢ */
        .fix-prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .fix-prompt-modal-content {
            position: relative;
            background: white;
            margin: 30px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .fix-prompt-editor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            margin-bottom: 20px;
        }

        .fix-prompt-editor:focus {
            outline: none;
            border-color: #667eea;
        }

        .fix-prompt-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .fix-output-area {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        .fix-output-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .verification-url {
            margin-top: 15px;
            padding: 15px;
            background: #d4edda;
            border-radius: 8px;
            display: none;
        }

        .verification-url a {
            color: #155724;
            font-weight: 600;
            text-decoration: none;
        }

        .verification-url a:hover {
            text-decoration: underline;
        }

        .fix-status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .fix-status.info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .fix-status.success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .fix-status.error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Certora Analyzer with Codex Integration</h1>
            <p>è‡ªåŠ¨åˆ†æ CVL éªŒè¯å¤±è´¥æ¡ˆä¾‹å¹¶æä¾›ä¿®å¤å»ºè®®</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3 style="margin-bottom: 20px; color: #212529;">è¾“å…¥ Certora URL</h3>
                <input type="text" class="url-input" id="certora-url"
                    placeholder="https://prover.certora.com/output/..." value="">

                <div style="margin: 10px 0 20px 0;">
                    <label for="project-path-main" style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        ğŸ—‚ï¸ Solidity é¡¹ç›®è·¯å¾„ï¼ˆworkdirï¼Œå¯é€‰ï¼Œåˆ†æä¸ä¿®å¤å…±ç”¨ï¼‰ï¼š
                    </label>
                    <input type="text" id="project-path-main"
                           placeholder="/Users/pixelpanda/Pinto/protocol/"
                           value="/Users/pixelpanda/Pinto/protocol/"
                           style="width: 100%; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; 
                                  font-family: 'Courier New', monospace; font-size: 14px;">
                    <small style="color: #6c757d; display: block; margin-top: 5px;">
                        ğŸ’¡ å°†ç”¨äº Codex åœ¨æ­£ç¡®ç›®å½•ä¸‹æ‰§è¡Œï¼ˆä¸ä¿®å¤é˜¶æ®µå…±ç”¨ï¼‰ã€‚
                    </small>
                </div>

                <div style="margin: 0 0 20px 0;">
                    <label for="certora-conf-select" style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        âš™ï¸ certoraRun é…ç½®æ–‡ä»¶ï¼ˆä» <workdir>/certora/conf è‡ªåŠ¨å‘ç° .confï¼‰ï¼š
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="certora-conf-select" style="flex: 1; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px;">
                            <option value="">ï¼ˆæœªåŠ è½½ï¼Œè¾“å…¥æˆ–æ›´æ”¹ä¸Šæ–¹é¡¹ç›®è·¯å¾„ä»¥è‡ªåŠ¨åŠ è½½ï¼‰</option>
                        </select>
                        <button class="btn btn-primary" id="reload-conf-btn" type="button" style="padding: 10px 16px;">ğŸ”„ åˆ·æ–°</button>
                    </div>
                    <small id="conf-help" style="color: #6c757d; display: block; margin-top: 5px;">
                        ğŸ’¡ ä¼šåˆ—å‡º <workdir>/certora/conf ç›®å½•ä¸‹çš„ .conf æ–‡ä»¶ï¼›è‹¥æ‰¾ä¸åˆ°ï¼Œå¯æ‰‹åŠ¨åœ¨è¯¥ç›®å½•æ”¾ç½® .conf å¹¶ç‚¹å‡»åˆ·æ–°ã€‚
                    </small>
                    <!-- å…¼å®¹æ—§é€»è¾‘ï¼šéšè—çš„æ–‡æœ¬è¾“å…¥ï¼Œä»…å½“æ— é€‰æ‹©æ—¶ä½œä¸ºå›é€€ -->
                    <input type="text" id="certora-conf-path" style="display:none;">
                </div>

                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeUrl()">
                    ğŸ” è·å–éªŒè¯æ•°æ®
                </button>
                <script>
                    // é¡µé¢åŠ è½½åå°è¯•æ ¹æ®é»˜è®¤çš„é¡¹ç›®è·¯å¾„åˆå§‹åŒ– conf ä¸‹æ‹‰
                    window.addEventListener('DOMContentLoaded', () => {
                        const projectInput = document.getElementById('project-path-main');
                        if (projectInput && projectInput.value.trim()) {
                            loadConfOptions();
                        }
                        const reloadBtn = document.getElementById('reload-conf-btn');
                        if (reloadBtn) {
                            reloadBtn.addEventListener('click', loadConfOptions);
                        }
                        if (projectInput) {
                            // å½“ç”¨æˆ·ä¿®æ”¹é¡¹ç›®è·¯å¾„æ—¶ï¼Œè‡ªåŠ¨åˆ·æ–° conf åˆ—è¡¨ï¼ˆé˜²æŠ–ï¼‰
                            let t = null;
                            projectInput.addEventListener('input', () => {
                                if (t) clearTimeout(t);
                                t = setTimeout(loadConfOptions, 400);
                            });
                            projectInput.addEventListener('change', () => {
                                if (t) clearTimeout(t);
                                loadConfOptions();
                            });
                        }
                    });
                </script>

                <div id="status-message"></div>
            </div>

            <div id="action-buttons" class="action-buttons" style="display: none;">
                <button class="btn btn-success" id="batchAnalyzeBtn" onclick="toggleBatchAnalysis()">
                    ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™
                </button>
                <button class="btn btn-warning" onclick="fixAll()">
                    ğŸ”§ æ‰§è¡Œé¡ºåºä¿®å¤
                </button>
            </div>

            <!-- ä¿®å¤æ‰§è¡Œè¾“å‡ºåŒºåŸŸ - ç§»åˆ°ä¸»ç•Œé¢ -->
            <div id="main-fix-output" style="display: none; margin-top: 20px;">
                <h3 style="margin-bottom: 20px; color: #212529;">ğŸ”§ ä¿®å¤æ‰§è¡Œè¿‡ç¨‹</h3>
                <div id="main-fix-controls" style="margin-bottom: 12px; display: none;">
                    <button class="btn btn-danger" id="stop-fix-btn" onclick="stopFix()">â¸ æš‚åœå¹¶ç»ˆæ­¢ Codex</button>
                </div>
                <div id="main-fix-status" class="status-message" style="margin-bottom: 15px;"></div>
                <div id="main-fix-content" style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; 
                     font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; 
                     word-break: break-word; max-height: 500px; overflow-y: auto; min-height: 200px; margin-bottom: 15px;"></div>
                <div id="main-verification-url" style="margin-top: 15px; padding: 15px; background: #d4edda; 
                     border-radius: 8px; display: none;">
                    <strong>ğŸ‰ éªŒè¯å®Œæˆï¼</strong><br>
                    æŸ¥çœ‹éªŒè¯ç»“æœï¼š<a id="main-verification-link" href="#" target="_blank" style="color: #155724; font-weight: 600;"></a>
                </div>
            </div>

            <div id="result-section" style="display: none;">
                <table class="result-table" id="result-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">è§„åˆ™å</th>
                            <th style="width: 10%;">çŠ¶æ€</th>
                            <th style="width: 10%;">Markdown</th>
                            <th style="width: 40%;">Codexåˆ†æç»“æœ</th>
                            <th style="width: 15%;">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="result-tbody">
                    </tbody>
                </table>
            </div>

            <div id="prover-url" class="prover-url">
                éªŒè¯å®Œæˆï¼æŸ¥çœ‹ç»“æœï¼š<a href="#" target="_blank" id="prover-link"></a>
            </div>
        </div>
    </div>

    <!-- Markdown Modal -->
    <div id="markdown-modal" class="markdown-modal">
        <div class="markdown-modal-content">
            <span class="close-modal" onclick="closeMarkdownModal()">&times;</span>
            <h3 id="modal-title" style="margin-bottom: 20px;">Markdown å†…å®¹</h3>
            <div id="modal-content" class="markdown-content"></div>
        </div>
    </div>

    <!-- Codex Analysis Modal -->
    <div id="codex-modal" class="codex-modal">
        <div class="codex-modal-content">
            <span class="close-modal" onclick="closeCodexModal()">&times;</span>
            <h3 id="codex-modal-title" style="margin-bottom: 20px;">Codex åˆ†æè¯¦æƒ…</h3>
            <div id="codex-modal-content" class="codex-content"></div>
        </div>
    </div>

    <!-- Fix Prompt Modal -->
    <div id="fix-prompt-modal" class="fix-prompt-modal">
        <div class="fix-prompt-modal-content">
            <span class="close-modal" onclick="closeFixPromptModal()">&times;</span>
            <h3 style="margin-bottom: 20px;">ğŸ“ ä¿®å¤ä»»åŠ¡é¢„è§ˆä¸ç¼–è¾‘</h3>
            
            <div style="margin-bottom: 15px;">
                <label for="fix-prompt-editor" style="font-weight: 600; color: #495057;">ä¿®å¤ Promptï¼ˆå¯ç¼–è¾‘ï¼‰ï¼š</label>
            </div>
            
            <textarea id="fix-prompt-editor" class="fix-prompt-editor" 
                      placeholder="æ­£åœ¨ç”Ÿæˆä¿®å¤ prompt..."></textarea>
            
            <div class="fix-prompt-buttons">
                <button class="btn btn-danger" onclick="closeFixPromptModal()">
                    âŒ å–æ¶ˆ
                </button>
                <button class="btn btn-success" id="execute-fix-btn" onclick="executeFixWithPrompt()">
                    ğŸš€ å¼€å§‹æ‰§è¡Œä¿®å¤
                </button>
            </div>

            <!-- ä¿®å¤æ‰§è¡Œè¾“å‡ºåŒºåŸŸ -->
            <div id="fix-output-area" class="fix-output-area">
                <h4 style="margin-bottom: 15px;">ğŸ”§ ä¿®å¤æ‰§è¡Œè¿‡ç¨‹</h4>
                <div id="fix-status"></div>
                <div id="fix-output-content" class="fix-output-content"></div>
                <div id="verification-url" class="verification-url">
                    <strong>ğŸ‰ éªŒè¯å®Œæˆï¼</strong><br>
                    æŸ¥çœ‹éªŒè¯ç»“æœï¼š<a id="verification-link" href="#" target="_blank"></a>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allRulesData = null;
        let jsonContents = {};
        let processedRules = [];
        let sanityAggregated = null;
        let stopAnalysisFlag = false;
        const analysisControllers = new Map(); // ä¸ºæ¯ä¸ªåˆ†æç»´æŠ¤ç‹¬ç«‹çš„æ§åˆ¶å™¨
        let lastFixAnalyses = []; // é¡ºåºä¿®å¤ç”¨çš„åˆ†æç»“æœç¼“å­˜
        let fixAbortController = null; // é¡ºåºä¿®å¤çš„æ§åˆ¶å™¨ï¼ˆç”¨äºæš‚åœ/ç»ˆæ­¢ï¼‰

        // åŠ è½½ <workdir>/certora/conf ä¸‹çš„ .conf åˆ°ä¸‹æ‹‰æ¡†
        async function loadConfOptions() {
            try {
                const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
                const select = document.getElementById('certora-conf-select');
                const help = document.getElementById('conf-help');
                if (!projectPath) {
                    select.innerHTML = '<option value="">ï¼ˆè¯·å…ˆå¡«å†™ä¸Šæ–¹é¡¹ç›®è·¯å¾„ï¼‰</option>';
                    return;
                }
                select.innerHTML = '<option value="">ï¼ˆåŠ è½½ä¸­â€¦ï¼‰</option>';
                const resp = await fetch('http://localhost:3002/list-conf?projectPath=' + encodeURIComponent(projectPath));
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const data = await resp.json();
                if (!data.success) throw new Error(data.error || 'åŠ è½½å¤±è´¥');

                const files = Array.isArray(data.files) ? data.files : [];
                if (files.length === 0) {
                    select.innerHTML = '<option value="">ï¼ˆæœªåœ¨ ' + (data.baseDir || (projectPath + '/certora/conf')) + ' æ‰¾åˆ° .confï¼‰</option>';
                    return;
                }
                // å¡«å……é€‰é¡¹ï¼ˆæ˜¾ç¤ºç›¸å¯¹è·¯å¾„ï¼Œå€¼ä¸ºç»å¯¹è·¯å¾„æ–¹ä¾¿åç«¯ï¼‰
                select.innerHTML = '';
                files.sort((a,b) => a.relPath.localeCompare(b.relPath));
                for (const f of files) {
                    const opt = document.createElement('option');
                    opt.value = f.fullPath;
                    opt.textContent = f.relPath;
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('certora-conf-select');
                select.innerHTML = '<option value="">ï¼ˆåŠ è½½å¤±è´¥ï¼š' + (e.message || e) + 'ï¼‰</option>';
            }
        }

        // å¤„ç† Codex è¾“å‡ºï¼Œåªä¿ç•™æœ€ç»ˆå›ç­”
        function extractCodexAnswer(fullOutput) {
            // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ—¶é—´æˆ³æ ‡è®°å’Œ "tokens used:" ä¹‹é—´çš„å†…å®¹
            const lines = fullOutput.split('\n');
            let lastTimeIndex = -1;
            let tokensUsedIndex = -1;

            // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ—¶é—´æˆ³æ ‡è®°ï¼Œæ ¼å¼å¦‚ [2025-01-01T10:30:00]
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                }
                if (tokensUsedIndex > -1 && lines[i].match(/^\[[\d\-T:\.Z]+\]/)) {
                    lastTimeIndex = i;
                    break;
                }
            }

            if (lastTimeIndex >= 0 && tokensUsedIndex > lastTimeIndex) {
                // æå–æœ€åä¸€ä¸ªæ—¶é—´æˆ³ååˆ° tokens used ä¹‹å‰çš„å†…å®¹
                const answerLines = lines.slice(lastTimeIndex + 1, tokensUsedIndex);
                let answer = answerLines.join('\n').trim();

                // ç§»é™¤å¯èƒ½çš„é¢å¤–æ ‡è®°
                answer = answer.replace(/^(Assistant|AI|Codex):\s*/gm, '');
                answer = answer.replace(/^\s*[-â€¢]\s*/gm, '');

                return answer || fullOutput;
            }

            // å¦‚æœæ²¡æ‰¾åˆ°æ—¶é—´æˆ³ï¼Œå°è¯•æŸ¥æ‰¾ "codex" æ ‡è®°
            let lastCodexIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('] codex')) {
                    lastCodexIndex = i;
                }
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                    break;
                }
            }

            if (lastCodexIndex >= 0 && tokensUsedIndex > lastCodexIndex) {
                const answerLines = lines.slice(lastCodexIndex + 1, tokensUsedIndex);
                return answerLines.join('\n').trim();
            }

            // å¦‚æœéƒ½æ²¡æ‰¾åˆ°ï¼Œè¿”å›åŸå†…å®¹
            return fullOutput;
        }

        async function analyzeUrl() {
            const url = document.getElementById('certora-url').value.trim();
            if (!url) {
                showStatus('è¯·è¾“å…¥URL', 'error');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è·å–ä¸­...';

            showStatus('æ­£åœ¨è·å–éªŒè¯æ•°æ®...', 'info');

            try {
                // è°ƒç”¨æœ¬åœ°æœåŠ¡
                const response = await fetch('http://localhost:3002/analyze-and-fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `æœåŠ¡å™¨é”™è¯¯: ${response.status}`);
                }

                const data = await response.json();
                allRulesData = data;

                // ä¿å­˜æ‰€æœ‰JSONå†…å®¹
                data.rules.forEach(rule => {
                    if (rule.content) {
                        jsonContents[rule.outputFile] = rule.content;
                    }
                });

                processData(data);
                showStatus(`âœ… æˆåŠŸè·å– ${data.rules.length} ä¸ªè§„åˆ™çš„æ•°æ®`, 'success');

            } catch (error) {
                console.error('Error:', error);
                showStatus(`é”™è¯¯: ${error.message}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†: node scripts/certora_auto_server.mjs`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ” è·å–éªŒè¯æ•°æ®';
            }
        }

        function processData(data) {
            processedRules = [];

            // å¤„ç† VIOLATED è§„åˆ™
            data.rules.filter(r => r.status === 'VIOLATED').forEach(rule => {
                const markdown = rule.content ? convertToMarkdown(rule) : '';
                processedRules.push({
                    ...rule,
                    type: 'VIOLATED',
                    markdown: markdown,
                    displayName: rule.ruleName
                });
            });

            // æ•´åˆ SANITY_FAILED è§„åˆ™
            const sanityFailed = data.rules.filter(r => r.status === 'SANITY_FAILED');
            if (sanityFailed.length > 0) {
                sanityAggregated = aggregateSanityFailures(sanityFailed);
                processedRules.push({
                    ruleName: 'æ±‡æ€»: Sanity Failed è§„åˆ™',
                    status: 'SANITY_FAILED',
                    type: 'SANITY_FAILED',
                    markdown: sanityAggregated,
                    displayName: 'æ±‡æ€»: Sanity Failed è§„åˆ™',
                    outputFile: 'sanity_aggregated'
                });
            }

            displayResults();
            document.getElementById('action-buttons').style.display = 'flex';
        }

        function aggregateSanityFailures(rules) {
            const sanityMap = new Map();

            rules.forEach(rule => {
                const parts = rule.ruleName.split(' > ');
                const baseRule = parts[0];
                const funcName = parts[parts.length - 1];

                if (!sanityMap.has(baseRule)) {
                    sanityMap.set(baseRule, new Set());
                }
                sanityMap.get(baseRule).add(funcName);
            });

            return Array.from(sanityMap.entries()).map(([rule, funcs]) =>
                `è§„åˆ™ ${rule} åœ¨ä»¥ä¸‹å‡½æ•°ä¸­ sanity failed:\n${Array.from(funcs).map(f => `- ${f}`).join('\n')}`
            ).join('\n\n');
        }

        function displayResults() {
            const tbody = document.getElementById('result-tbody');
            tbody.innerHTML = '';

            processedRules.forEach((rule, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${formatRuleName(rule.displayName)}</td>
                    <td><span class="status-badge status-${rule.status.toLowerCase().replace('_', '-')}">${rule.status}</span></td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button class="view-btn" onclick="viewMarkdown(${index})">
                                ğŸ“„ æŸ¥çœ‹
                            </button>
                            <button class="copy-btn" onclick="copyMarkdown(${index})">
                                ğŸ“‹ å¤åˆ¶MD
                            </button>
                        </div>
                    </td>
                    <td>
                        <div style="position: relative;">
                            <textarea class="codex-analysis" 
                                      id="analysis-${rule.outputFile}" 
                                      data-output-file="${rule.outputFile}"
                                      data-rule-name="${rule.displayName}"
                                      placeholder="å¯ç›´æ¥åœ¨æ­¤ç¼–è¾‘ Codex åˆ†æç»“æœï¼ˆæˆ–å…ˆç‚¹å‡»åˆ†æï¼‰"></textarea>
                            <div style="display: flex; gap: 5px; position: absolute; top: 5px; right: 5px;">
                                <button class="copy-btn-small" 
                                        onclick="copyCodexAnalysis('${rule.outputFile}')"
                                        title="å¤åˆ¶">
                                    ğŸ“‹
                                </button>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-primary" id="analyze-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px;" 
                                    onclick="analyzeRule(${index})">åˆ†æ</button>
                            <button class="btn btn-danger" id="stop-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px; display: none;" 
                                    onclick="stopSingleAnalysis('${rule.outputFile}')">åœæ­¢</button>
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('result-section').style.display = 'block';
        }

        // é¢„è§ˆåŒºç›´æ¥å¯ç¼–è¾‘ï¼Œæ— éœ€åˆ‡æ¢ç¼–è¾‘æ¨¡å¼æˆ–å¼¹çª—

        function formatRuleName(name) {
            const parts = name.split(' > ');
            if (parts.length === 1) {
                return name;
            }
            return `${parts[0]} > ... > ${parts[parts.length - 1]}`;
        }

        function viewMarkdown(index) {
            const rule = processedRules[index];
            document.getElementById('modal-title').textContent = `Markdown - ${rule.displayName}`;
            document.getElementById('modal-content').textContent = rule.markdown;
            document.getElementById('markdown-modal').style.display = 'block';
        }

        function closeMarkdownModal() {
            document.getElementById('markdown-modal').style.display = 'none';
        }

        async function analyzeRule(index, isBatchAnalysis = false, retryCount = 0) {
            const maxRetries = 3;
            
            // åªæœ‰åœ¨æ‰¹é‡åˆ†ææ—¶æ‰æ£€æŸ¥ stopAnalysisFlag
            if (isBatchAnalysis && stopAnalysisFlag) {
                console.log('æ‰¹é‡åˆ†æè¢«åœæ­¢æ ‡å¿—é˜»æ­¢');
                return;
            }

            const rule = processedRules[index];
            if (!rule) {
                console.error(`è§„åˆ™ç´¢å¼• ${index} ä¸å­˜åœ¨`);
                return;
            }

            const outputFile = rule.outputFile;

            console.log(`å¼€å§‹æµå¼åˆ†æè§„åˆ™: ${outputFile}, æ‰¹é‡åˆ†æ: ${isBatchAnalysis}, é‡è¯•æ¬¡æ•°: ${retryCount}`);
            console.log(`è§„åˆ™ç±»å‹: ${rule.type}, Markdowné•¿åº¦: ${rule.markdown ? rule.markdown.length : 0}`);

            const textarea = document.getElementById(`analysis-${outputFile}`);
            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);

            if (!textarea || !analyzeBtn) {
                console.error(`æ‰¾ä¸åˆ°UIå…ƒç´ : textarea=${!!textarea}, analyzeBtn=${!!analyzeBtn}`);
                return;
            }

            // å¦‚æœè¿™ä¸ªè§„åˆ™å·²ç»åœ¨åˆ†æä¸­ï¼Œä¸é‡å¤åˆ†æ
            if (analysisControllers.has(outputFile)) {
                console.log(`è§„åˆ™ ${outputFile} å·²åœ¨åˆ†æä¸­ï¼Œè·³è¿‡`);
                return;
            }

            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®ï¼Œéšè—åˆ†ææŒ‰é’®
            if (analyzeBtn) analyzeBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            if (retryCount > 0) {
                textarea.value = `é‡è¯•ä¸­... (${retryCount}/${maxRetries})`;
            } else {
                textarea.value = 'æ­£åœ¨è¿æ¥Codex...';
            }
            textarea.disabled = true;

            // ä¸ºè¿™ä¸ªç‰¹å®šçš„åˆ†æåˆ›å»º AbortController
            const controller = new AbortController();
            analysisControllers.set(outputFile, controller);

            console.log(`åˆ›å»ºäº†æ§åˆ¶å™¨ï¼Œå½“å‰æ§åˆ¶å™¨æ•°é‡: ${analysisControllers.size}`);

            // æ£€æŸ¥æ§åˆ¶å™¨æ˜¯å¦ç«‹å³è¢«ä¸­æ­¢
            if (controller.signal.aborted) {
                console.error('æ§åˆ¶å™¨åˆ›å»ºåç«‹å³è¢«ä¸­æ­¢ï¼');
                analysisControllers.delete(outputFile);
                textarea.value = 'åˆ†æå¤±è´¥ï¼šæ§åˆ¶å™¨è¢«ä¸­æ­¢';
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                return;
            }

            try {
                console.log(`å‘é€æµå¼åˆ†æè¯·æ±‚: ${rule.type}, Markdownå‰100å­—ç¬¦: ${rule.markdown ? rule.markdown.substring(0, 100) : 'null'}`);

                // ç¡®ä¿ markdown å­˜åœ¨
                if (!rule.markdown) {
                    throw new Error('Markdownå†…å®¹ä¸ºç©º');
                }

                const projectPathMain = (document.getElementById('project-path-main')?.value || '').trim();
                const requestBody = {
                    content: rule.markdown,
                    type: rule.type
                };
                if (projectPathMain) {
                    requestBody.projectPath = projectPathMain;
                }

                console.log(`è¯·æ±‚ä½“å¤§å°: ${JSON.stringify(requestBody).length} å­—èŠ‚`);

                // ä½¿ç”¨æµå¼ç«¯ç‚¹
                const response = await fetch('http://localhost:3002/analyze-rule-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                console.log(`æ”¶åˆ°å“åº”: ${response.status}`);

                // æ£€æŸ¥å“åº”æ˜¯å¦æ­£å¸¸
                if (!response.ok) {
                    if (response.status === 500 && retryCount < maxRetries) {
                        // HTTP 500 é”™è¯¯ï¼Œè¿›è¡Œé‡è¯•
                        console.log(`HTTP 500é”™è¯¯ï¼Œå°†åœ¨2ç§’åé‡è¯• (${retryCount + 1}/${maxRetries})`);
                        analysisControllers.delete(outputFile);
                        
                        // ç­‰å¾…2ç§’åé‡è¯•
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // å¤„ç†SSEæµå¼å“åº”
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                // ä¸ºè¯¥è§„åˆ™å»ºç«‹æŒä¹…ä¸Šä¸‹æ–‡ï¼Œé¿å…æ¯æ¬¡å›è°ƒåˆ›å»ºæ–°å¯¹è±¡å¯¼è‡´ä¸¢å¤±çŠ¶æ€
                const ctx = { fullThinkingProcess: '', finalResult: '' };

                textarea.value = ''; // æ¸…ç©ºåˆå§‹å†…å®¹

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ­¢
                    if (controller.signal.aborted) {
                        reader.cancel();
                        throw new Error('åˆ†æè¢«ç”¨æˆ·åœæ­¢');
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleAnalysisStreamData(data, textarea, outputFile, ctx);
                            } catch (e) {
                                console.error('è§£æSSEæ•°æ®é”™è¯¯:', e, line);
                            }
                        }
                    }
                }

                console.log(`æµå¼åˆ†æå®Œæˆ: ${outputFile}`);

            } catch (error) {
                console.error(`åˆ†æå‡ºé”™: ${outputFile}`, error);
                console.error('é”™è¯¯è¯¦æƒ…:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'AbortError') {
                    console.log('è¯·æ±‚è¢«ä¸­æ­¢ï¼Œæ§åˆ¶å™¨çŠ¶æ€:', controller.signal.aborted);
                    textarea.value = 'åˆ†æå·²å–æ¶ˆ';
                } else if (error.message.includes('Failed to fetch')) {
                    if (retryCount < maxRetries) {
                        console.log(`ç½‘ç»œé”™è¯¯ï¼Œå°†é‡è¯•: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·ç¡®ä¿æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ';
                } else if (error.message === 'Markdownå†…å®¹ä¸ºç©º') {
                    textarea.value = 'é”™è¯¯ï¼šæ²¡æœ‰å¯åˆ†æçš„å†…å®¹';
                } else {
                    if (retryCount < maxRetries && !error.name === 'AbortError') {
                        console.log(`é€šç”¨é”™è¯¯ï¼Œå°†é‡è¯•: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = `é”™è¯¯: ${error.message}`;
                }
            } finally {
                textarea.disabled = false;
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                // æ¸…ç†æ§åˆ¶å™¨
                analysisControllers.delete(outputFile);
                console.log(`æ¸…ç†æ§åˆ¶å™¨ï¼Œå‰©ä½™æ§åˆ¶å™¨æ•°é‡: ${analysisControllers.size}`);
            }
        }

        function handleAnalysisStreamData(data, textarea, outputFile, context) {
            switch (data.type) {
                case 'info':
                    // æ˜¾ç¤ºè¿æ¥ä¿¡æ¯ï¼Œä½†ä¸æ·»åŠ åˆ°æ€è€ƒè¿‡ç¨‹
                    if (data.message.includes('å¼€å§‹åˆ†æ')) {
                        textarea.value = 'Codex å¼€å§‹æ€è€ƒ...';
                    }
                    break;
                    
                case 'output':
                    // ä»…æ˜¾ç¤ºä¸€æ¬¡ç³»ç»Ÿå¤´ï¼ˆæœåŠ¡ç«¯åªä¼šå‘é€è¿™ä¸€æ®µï¼‰
                    if (data.message && data.message.trim()) {
                        context.fullThinkingProcess = data.message.replace(/\r\n/g, '\n').replace(/\n{3,}/g, '\n\n');
                        textarea.value = context.fullThinkingProcess;
                        textarea.scrollTop = textarea.scrollHeight;
                    }
                    break;
                    
                case 'final':
                    // ä¿å­˜æœ€ç»ˆç»“æœ
                    context.finalResult = data.message;
                    break;
                    
                case 'success':
                    // åˆ†ææˆåŠŸå®Œæˆï¼Œç”¨æœ€ç»ˆç»“æœæ›¿æ¢æ€è€ƒè¿‡ç¨‹
                    let finalContent = '';
                    if (context.finalResult && context.finalResult.trim()) {
                        finalContent = context.finalResult.trim();
                    } else {
                        // å¦‚æœæ²¡æœ‰æœ€ç»ˆç»“æœï¼Œä» fullThinkingProcessï¼ˆå¯èƒ½ä»…å«ç³»ç»Ÿå¤´ï¼‰ä¸åå°å®Œæ•´è¾“å‡ºä¸­æå–
                        const extracted = extractCodexAnswer(context.fullThinkingProcess);
                        finalContent = extracted ? extracted.trim() : context.fullThinkingProcess.trim();
                    }
                    // ä»…å±•ç¤ºæœ€ç»ˆç»“æœï¼ˆå¤´éƒ¨ä¿¡æ¯åªåœ¨å¼€å§‹æ—¶æ˜¾ç¤ºï¼Œä¸æ··å…¥æœ€ç»ˆå†…å®¹ï¼‰
                    textarea.value = finalContent;
                    // é¢„è§ˆåŒºé»˜è®¤å¯ç¼–è¾‘ï¼Œæ— éœ€å†åˆ‡æ¢
                    console.log(`æµå¼åˆ†ææˆåŠŸ: ${outputFile}`);
                    break;
                    
                case 'error':
                    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    textarea.value = `åˆ†æé”™è¯¯: ${data.message}`;
                    console.error(`æµå¼åˆ†æé”™è¯¯: ${outputFile}`, data.message);
                    break;
                    
                case 'complete':
                    // åˆ†æå®Œæˆï¼ˆæ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼‰
                    console.log(`æµå¼åˆ†æç»“æŸ: ${outputFile}`);
                    break;
                    
                default:
                    console.log(`æœªçŸ¥çš„æµå¼æ•°æ®ç±»å‹: ${data.type}`, data);
                    break;
            }
        }

        function stopSingleAnalysis(outputFile) {
            const controller = analysisControllers.get(outputFile);
            if (controller) {
                controller.abort();
                analysisControllers.delete(outputFile);
            }

            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
            const textarea = document.getElementById(`analysis-${outputFile}`);

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (textarea) {
                textarea.value = 'åˆ†æå·²åœæ­¢';
                textarea.disabled = false;
            }
        }

        let isBatchAnalyzing = false;

        async function toggleBatchAnalysis() {
            if (isBatchAnalyzing) {
                // å½“å‰æ­£åœ¨åˆ†æï¼Œæ‰§è¡Œåœæ­¢æ“ä½œ
                stopAnalysis();
            } else {
                // å½“å‰æœªåœ¨åˆ†æï¼Œå¼€å§‹æ‰¹é‡åˆ†æ
                await analyzeAllRules();
            }
        }

        async function analyzeAllRules() {
            isBatchAnalyzing = true;
            stopAnalysisFlag = false;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            batchBtn.className = 'btn btn-danger';
            batchBtn.innerHTML = 'â¹ï¸ åœæ­¢åˆ†æ';
            
            showStatus('å¼€å§‹æ‰¹é‡åˆ†æ...', 'info');

            // å¹¶å‘æ‰§è¡Œæ‰€æœ‰åˆ†æä»»åŠ¡
            const analysisPromises = [];
            for (let i = 0; i < processedRules.length; i++) {
                if (stopAnalysisFlag) {
                    break;
                }
                // ä¸ç­‰å¾…æ¯ä¸ªåˆ†æå®Œæˆï¼Œç›´æ¥æ¨å…¥Promiseæ•°ç»„
                analysisPromises.push(analyzeRule(i, true));
            }

            try {
                // ç­‰å¾…æ‰€æœ‰åˆ†æä»»åŠ¡å®Œæˆ
                await Promise.allSettled(analysisPromises);
            } catch (error) {
                console.error('æ‰¹é‡åˆ†æè¿‡ç¨‹ä¸­å‡ºé”™:', error);
            }

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            isBatchAnalyzing = false;
            batchBtn.className = 'btn btn-success';
            batchBtn.innerHTML = 'ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™';
            
            if (!stopAnalysisFlag) {
                showStatus('âœ… æ‰€æœ‰è§„åˆ™åˆ†æå®Œæˆ', 'success');
            } else {
                showStatus('æ‰¹é‡åˆ†æå·²åœæ­¢', 'info');
            }
        }

        function stopAnalysis() {
            stopAnalysisFlag = true;
            isBatchAnalyzing = false;
            
            // æ¢å¤æ‰¹é‡åˆ†ææŒ‰é’®çŠ¶æ€
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            if (batchBtn) {
                batchBtn.className = 'btn btn-success';
                batchBtn.innerHTML = 'ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™';
            }
            
            // åœæ­¢æ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„åˆ†æ
            analysisControllers.forEach((controller, outputFile) => {
                controller.abort();
                // æ›´æ–°å¯¹åº”çš„UI
                const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
                const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
                const textarea = document.getElementById(`analysis-${outputFile}`);

                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                if (textarea && textarea.value === 'åˆ†æä¸­...') {
                    textarea.value = 'æ‰¹é‡åˆ†æå·²åœæ­¢';
                    textarea.disabled = false;
                }
            });
            analysisControllers.clear();

            showStatus('æ‰¹é‡åˆ†æå·²åœæ­¢', 'info');
        }

        async function fixAll() {
            // ä»…ä¿®å¤â€œå·²æœ‰åˆ†æç»“è®ºâ€çš„é¡¹ï¼›ä¸ä¼šè‡ªåŠ¨è§¦å‘æ‰¹é‡åˆ†æ
            const analyses = [];

            // ä¼˜å…ˆä»DOMä¸­æ”¶é›†ï¼Œé¿å…å› IDå†²çªæˆ–processedRulesä¸ä¸€è‡´å¯¼è‡´æ¼æ”¶
            const tas = Array.from(document.querySelectorAll('textarea.codex-analysis'));
            tas.forEach(ta => {
                const val = (ta.value || '').trim();
                if (!val) return;
                if (val.includes('åˆ†æä¸­...') || val.includes('æ‰¹é‡åˆ†æå·²åœæ­¢') || val.startsWith('é‡è¯•ä¸­...')) return;
                if (val.length < 3) return;
                if (/ç‚¹å‡»åˆ†ææŒ‰é’®/.test(val)) return;

                const ruleName = ta.dataset.ruleName || '';
                analyses.push({ text: val, ruleName });
            });

            if (analyses.length === 0) {
                showStatus('æ²¡æœ‰å¯ç”¨çš„åˆ†æç»“æœï¼Œåªæœ‰å®Œæˆ Codex åˆ†æçš„é¡¹æ‰ä¼šè¿›å…¥ä¿®å¤', 'error');
                return;
            }

            // ç¼“å­˜åˆ°å…¨å±€ï¼Œä¾›é¡ºåºä¿®å¤ä½¿ç”¨
            lastFixAnalyses = analyses;

            // å°†é€‰ä¸­æ¡ç›®åˆ—è¡¨ä¹Ÿå±•ç¤ºå‡ºæ¥ï¼Œä¾¿äºç”¨æˆ·æ ¸å¯¹
            const namesPreview = analyses.map((a, i) => `${i + 1}. ${a.ruleName || '(æœªå‘½åè§„åˆ™)'}`).join('ï¼›');
            showStatus(`æ­£åœ¨ç”Ÿæˆä¿®å¤ promptï¼ˆå…± ${analyses.length} é¡¹ï¼‰ï¼š${namesPreview}`, 'info');

            try {
                // ç¬¬ä¸€æ­¥ï¼šç”Ÿæˆ prompt
                const response = await fetch('http://localhost:3002/generate-fix-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ analyses })
                });

                const result = await response.json();
                if (result.success) {
                    // ç›´æ¥æ‰§è¡Œä¿®å¤ï¼Œä¸æ˜¾ç¤ºé¢„è§ˆæ¨¡æ€æ¡†
                    executeFixDirectly(result.prompt);
                } else {
                    showStatus(`ç”Ÿæˆ prompt å¤±è´¥: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`é”™è¯¯: ${error.message}`, 'error');
            }
        }

        function closeFixPromptModal() {
            document.getElementById('fix-prompt-modal').style.display = 'none';
            // é‡ç½®è¾“å‡ºåŒºåŸŸ
            document.getElementById('fix-output-area').style.display = 'none';
            document.getElementById('fix-output-content').textContent = '';
            document.getElementById('verification-url').style.display = 'none';
        }

        async function executeFixDirectly(prompt) {
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();
            
            if (!prompt) {
                showStatus('ä¿®å¤ prompt ä¸ºç©º', 'error');
                return;
            }

            // æ˜¾ç¤ºä¸»ç•Œé¢è¾“å‡ºåŒºåŸŸ
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®
            document.getElementById('main-fix-controls').style.display = 'block';
            
            // æ˜¾ç¤ºé¡¹ç›®è·¯å¾„ä¿¡æ¯
            if (projectPath) {
                showMainFixStatus(`æ­£åœ¨æ‰§è¡Œä¿®å¤ä»»åŠ¡... é¡¹ç›®è·¯å¾„: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('æ­£åœ¨æ‰§è¡Œä¿®å¤ä»»åŠ¡... ä½¿ç”¨è‡ªåŠ¨é¡¹ç›®æœç´¢', 'info');
            }

            try {
                // ä½¿ç”¨é¡ºåºæµå¼ç«¯ç‚¹æ‰§è¡Œä¿®å¤ï¼ŒåŒ…å«é¡¹ç›®è·¯å¾„ä¸confè·¯å¾„
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // åˆ›å»ºå¹¶ä¿å­˜æ§åˆ¶å™¨ï¼Œä¾¿äºæš‚åœ
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('è§£æSSEæ•°æ®é”™è¯¯:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('ä¿®å¤æ‰§è¡Œé”™è¯¯:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('å·²æš‚åœå¹¶è¯·æ±‚ç»ˆæ­¢ Codex è¿›ç¨‹', 'info');
                } else {
                    showMainFixStatus(`æ‰§è¡Œé”™è¯¯: ${error.message}`, 'error');
                }
            } finally {
                // æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéšè—åœæ­¢æŒ‰é’®
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        async function executeFixWithPrompt() {
            const prompt = document.getElementById('fix-prompt-editor').value.trim();
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();
            
            if (!prompt) {
                showFixStatus('è¯·è¾“å…¥ä¿®å¤ prompt', 'error');
                return;
            }

            // å…³é—­é¢„è§ˆæ¨¡æ€æ¡†
            document.getElementById('fix-prompt-modal').style.display = 'none';
            
            // æ˜¾ç¤ºä¸»ç•Œé¢è¾“å‡ºåŒºåŸŸ
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®
            document.getElementById('main-fix-controls').style.display = 'block';
            
            // æ˜¾ç¤ºé¡¹ç›®è·¯å¾„ä¿¡æ¯
            if (projectPath) {
                showMainFixStatus(`æ­£åœ¨æ‰§è¡Œä¿®å¤ä»»åŠ¡... é¡¹ç›®è·¯å¾„: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('æ­£åœ¨æ‰§è¡Œä¿®å¤ä»»åŠ¡... ä½¿ç”¨è‡ªåŠ¨é¡¹ç›®æœç´¢', 'info');
            }

            try {
                // ä½¿ç”¨é¡ºåºæµå¼ç«¯ç‚¹æ‰§è¡Œä¿®å¤ï¼ŒåŒ…å«é¡¹ç›®è·¯å¾„ä¸confè·¯å¾„
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // åˆ›å»ºå¹¶ä¿å­˜æ§åˆ¶å™¨ï¼Œä¾¿äºæš‚åœ
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('è§£æSSEæ•°æ®é”™è¯¯:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('ä¿®å¤æ‰§è¡Œé”™è¯¯:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('å·²æš‚åœå¹¶è¯·æ±‚ç»ˆæ­¢ Codex è¿›ç¨‹', 'info');
                } else {
                    showMainFixStatus(`æ‰§è¡Œé”™è¯¯: ${error.message}`, 'error');
                }
            } finally {
                // æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéšè—åœæ­¢æŒ‰é’®
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        function handleMainFixStreamData(data) {
            const outputContent = document.getElementById('main-fix-content');
            
            switch (data.type) {
                case 'info':
                    showMainFixStatus(data.message, 'info');
                    // åŒæ­¥å†™å…¥æ—¥å¿—åŒºåŸŸï¼Œé¿å…ç”¨æˆ·é—æ¼é¡¶éƒ¨çŠ¶æ€æ 
                    outputContent.innerHTML += `<span style="color:#0d6efd;">[INFO]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    break;
                case 'output':
                    // æ ¼å¼åŒ–è¾“å‡ºï¼Œå¤„ç†æ—¶é—´æˆ³æ¢è¡Œ
                    const formattedOutput = formatCodexOutput(data.message);
                    if (formattedOutput) {
                        outputContent.innerHTML += formattedOutput;
                        outputContent.scrollTop = outputContent.scrollHeight;
                    }
                    break;
                case 'error':
                    outputContent.innerHTML += `<span style="color: #dc3545; font-weight: bold;">[ERROR] ${data.message}</span>\n`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    showMainFixStatus('æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯', 'error');
                    break;
                case 'url':
                    // æ˜¾ç¤ºéªŒè¯URL
                    document.getElementById('main-verification-link').href = data.message;
                    document.getElementById('main-verification-link').textContent = data.message;
                    document.getElementById('main-verification-url').style.display = 'block';
                    break;
                case 'success':
                    showMainFixStatus(data.message, 'success');
                    outputContent.innerHTML += `<span style="color:#20c997;">[SUCCESS]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    break;
                case 'complete':
                    showMainFixStatus('ä¿®å¤ä»»åŠ¡æ‰§è¡Œå®Œæˆ', 'success');
                    // ä»»åŠ¡è‡ªç„¶å®Œæˆï¼Œéšè—åœæ­¢æŒ‰é’®
                    document.getElementById('main-fix-controls').style.display = 'none';
                    break;
            }
        }

        // ç®€å•è½¬ä¹‰ï¼Œé˜²æ­¢æ—¥å¿—ä¸­çš„HTMLç ´åè¾“å‡º
        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatCodexOutput(output) {
            // æ ¼å¼åŒ– Codex è¾“å‡ºï¼Œå¤„ç†æ—¶é—´æˆ³å’Œå…¶ä»–æ ¼å¼
            let formatted = output;
            
            // å¤„ç†æ—¶é—´æˆ³æ ¼å¼ [YYYY-MM-DDTHH:MM:SS.xxxZ] æˆ– [æ—¶é—´æˆ³]
            formatted = formatted.replace(/(\[\d{4}-\d{2}-\d{2}T[\d:.Z]+\])/g, '\n<span style="color: #667eea; font-weight: bold;">$1</span>');
            
            // å¤„ç†å…¶ä»–å¸¸è§çš„æ—¥å¿—æ ¼å¼
            formatted = formatted.replace(/\[INFO\]/g, '<span style="color: #28a745;">[INFO]</span>');
            formatted = formatted.replace(/\[ERROR\]/g, '<span style="color: #dc3545;">[ERROR]</span>');
            formatted = formatted.replace(/\[WARNING\]/g, '<span style="color: #ffc107;">[WARNING]</span>');
            formatted = formatted.replace(/\[SUCCESS\]/g, '<span style="color: #20c997;">[SUCCESS]</span>');
            
            // å¤„ç† execã€bashã€codex ç­‰å‘½ä»¤æ ‡è®°
            formatted = formatted.replace(/(\] (exec|bash|codex|thinking)\b)/gi, '<span style="color: #6c757d; font-style: italic;">$1</span>');
            
            // å¤„ç† â¡ï¸ âœ… âŒ ç­‰ç‰¹æ®Šç¬¦å·ï¼Œä½¿å…¶æ›´é†’ç›®
            formatted = formatted.replace(/(â¡ï¸|âœ…|âŒ|âš ï¸)/g, '<span style="font-size: 1.2em;">$1</span>');
            
            // å¤„ç†è§„åˆ™åå’Œæ­¥éª¤ä¿¡æ¯
            formatted = formatted.replace(/(ç¬¬\s*\d+\/\d+\s*é¡¹)/g, '<span style="color: #764ba2; font-weight: bold;">$1</span>');
            formatted = formatted.replace(/(è§„åˆ™ï¼š[^\n]+)/g, '<span style="color: #667eea; font-weight: bold;">$1</span>');
            
            // è½¬æ¢æ¢è¡Œç¬¦ä¸º HTML æ¢è¡Œ
            formatted = formatted.replace(/\n/g, '<br>');
            
            return formatted;
        }

        function showMainFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('main-fix-status');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // åœæ­¢é¡ºåºä¿®å¤ï¼šä¸­æ­¢SSEå¹¶è¯·æ±‚åç«¯ç»ˆæ­¢ Codex è¿›ç¨‹
        async function stopFix() {
            try {
                // å…ˆä¸­æ­¢å‰ç«¯ä¸æœåŠ¡å™¨çš„è¿æ¥ï¼Œè¿™ä¼šè§¦å‘æœåŠ¡å™¨ç«¯ req 'close' é’©å­ï¼Œä»è€Œ SIGTERM å½“å‰å­è¿›ç¨‹
                if (fixAbortController) {
                    fixAbortController.abort();
                }

                showMainFixStatus('æ­£åœ¨ç»ˆæ­¢ Codex è¿›ç¨‹...', 'info');

                // å†è°ƒç”¨åç«¯ç»Ÿä¸€ç»ˆæ­¢æ¥å£ï¼Œç¡®ä¿æ‰€æœ‰ç›¸å…³ codex è¿›ç¨‹è¢«å…³é—­
                await fetch('http://localhost:3002/kill-processes', { method: 'POST' }).catch(() => {});
                showMainFixStatus('å·²è¯·æ±‚ç»ˆæ­¢ Codex è¿›ç¨‹', 'success');
            } catch (e) {
                showMainFixStatus(`ç»ˆæ­¢è¿›ç¨‹æ—¶å‡ºé”™: ${e.message}`, 'error');
            } finally {
                // éšè—æŒ‰é’®ï¼Œé¿å…é‡å¤ç‚¹å‡»
                document.getElementById('main-fix-controls').style.display = 'none';
            }
        }

        function showFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('fix-status');
            statusDiv.className = `fix-status ${type}`;
            statusDiv.textContent = message;
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // æ ¹æ®å‚è€ƒé¡¹ç›®é‡å†™çš„convertToMarkdownå‡½æ•°
        function convertToMarkdown(rule) {
            const traceData = rule.content;
            const simplifiedRuleName = rule.ruleName.split('â†³')[0].trim();
            let md = `# Certora Trace Analysis\n\n`;
            md += `**Rule:** ${simplifiedRuleName}\n`;
            md += `**Status:** ${rule.status}\n`;
            md += `**File:** ${rule.outputFile}\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## ğŸŒ³ Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second position) - ç›´æ¥ä»variablesæ•°ç»„ä¸­æå–
            md += `\n## ğŸ“Š Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                md += renderVariablesFromArray(traceData.variables);
            } else {
                md += `æš‚æ— å˜é‡æ•°æ®\n\n`;
            }

            // 3. Global State Diff (third position) - ä»Call Traceä¸­çš„Global StateèŠ‚ç‚¹è®¡ç®—å˜åŒ–
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## ğŸ”„ Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                md += `## ğŸš¨ Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            }

            return md;
        }

        // Call Traceè½¬æ¢ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    let value = '?';

                    if (arg.value !== undefined) {
                        value = arg.value;
                        // å¦‚æœæœ‰å¤šä¸ªå€¼è¡¨ç¤ºï¼Œä¼˜å…ˆæ˜¾ç¤ºå¯è¯»æ€§é«˜çš„
                        if (arg.values && arg.values.length > 1) {
                            const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                            if (decValue && parseInt(decValue) < 1000000) {
                                value = `${arg.value} (${decValue})`;
                            }
                        }
                    } else if (arg.values && Array.isArray(arg.values) && arg.values.length > 0) {
                        value = arg.values[0];
                    }

                    messageText = messageText.replace(placeholder, value);
                });
            }

            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // è®¡ç®—Global Stateå·®å¼‚ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬  
        function calculateGlobalStateDiff(callTrace) {
            const globalStateNodes = [];

            // æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
            collectGlobalStateNodes(callTrace, globalStateNodes);

            if (globalStateNodes.length === 0) {
                return {};
            }

            // æå–ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªGlobal Stateçš„çŠ¶æ€
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);

            // è®¡ç®—å·®å¼‚
            const diff = {};

            // æ”¶é›†æ‰€æœ‰çŠ¶æ€é”®
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);

            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];

                // åªæœ‰å½“å€¼ç¡®å®å‘ç”Ÿå˜åŒ–æ—¶æ‰è®°å½•
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                } else if (firstValue && lastValue) {
                    // å€¼æ²¡æœ‰å˜åŒ–ï¼Œä½†å­˜åœ¨äºä¸¤ä¸ªçŠ¶æ€ä¸­
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                }
            });

            return diff;
        }

        // é€’å½’æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node && node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }

            if (node && node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // ä»Global StateèŠ‚ç‚¹ä¸­æå–çŠ¶æ€ä¿¡æ¯
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};

            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }

            return state;
        }

        // é€’å½’æå–çŠ¶æ€ä¿¡æ¯
        function extractStateRecursively(node, state) {
            // å¦‚æœèŠ‚ç‚¹æœ‰argumentsï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªçŠ¶æ€è®°å½•
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // æ›¿æ¢å ä½ç¬¦å¾—åˆ°å®Œæ•´çš„çŠ¶æ€è·¯å¾„
                let fullPath = node.message.text;
                let stateValue = null;

                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // ä½¿ç”¨æœ€æ˜“è¯»çš„å€¼è¡¨ç¤º
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // å¦‚æœæœ‰åè¿›åˆ¶è¡¨ç¤ºï¼Œä¼˜å…ˆä½¿ç”¨
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);

                            // æœ€åä¸€ä¸ªå‚æ•°é€šå¸¸æ˜¯å€¼
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });

                // è§£æè·¯å¾„å’Œå€¼
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }

            // é€’å½’å¤„ç†å­èŠ‚ç‚¹
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // è§£æçŠ¶æ€è·¯å¾„
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }

            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();

            // å¦‚æœæœ‰ä»argumentsä¸­æå–çš„å€¼ï¼Œä¼˜å…ˆä½¿ç”¨
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }

            // æ¸…ç†å¼•å·
            value = value.replace(/^['"]|['"]$/g, '');

            return { path, value };
        }

        // æ¸²æŸ“Global Stateå·®å¼‚
        function renderGlobalStateDiff(diff) {
            let md = '';

            // æŒ‰è·¯å¾„ç±»å‹åˆ†ç»„
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] },
                'other': { title: 'Other Changes', items: [] }
            };

            Object.entries(diff).forEach(([path, change]) => {
                const item = { path, change };

                if (path.includes('storage') || path.includes('balanceOf') || path.includes('_storage')) {
                    groups.storage.items.push(item);
                } else if (path.includes('balance') || path.includes('Balance')) {
                    groups.balance.items.push(item);
                } else if (path.includes('ghost') || path.includes('Ghost')) {
                    groups.ghost.items.push(item);
                } else {
                    groups.other.items.push(item);
                }
            });

            // æ¸²æŸ“å„ç»„
            Object.values(groups).forEach(group => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    group.items.forEach(item => {
                        const { path, change } = item;
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` â†’ \`${change.to}\` âœ¨\n`;
                        } else {
                            md += `- **${path}**: \`${change.from}\` (unchanged)\n`;
                        }
                    });
                    md += `\n`;
                }
            });

            return md;
        }

        // ä»variablesæ•°ç»„ä¸­æ¸²æŸ“å±‚æ¬¡ç»“æ„ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function renderVariablesFromArray(variables) {
            let md = '';

            variables.forEach((variable, index) => {
                // åªå¤„ç†æœ‰variableNameå­—æ®µçš„å¯¹è±¡
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // å¤„ç†æœ‰childrenListçš„å˜é‡
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                    } else {
                        // ç®€å•å˜é‡ï¼Œç›´æ¥è¾“å‡ºå˜é‡åå’Œå€¼
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `**${name}**: \`${value}\`\n\n`;
                    }
                }
            });

            return md;
        }

        // å¤„ç†åµŒå¥—å˜é‡ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];

            // å¦‚æœæœ‰å­å˜é‡ï¼Œé€’å½’å¤„ç†
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // ç¡®ä¿childæ˜¯æœ‰æ•ˆçš„å¯¹è±¡ä¸”æœ‰variableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // å¶èŠ‚ç‚¹ï¼Œè¾“å‡ºå®Œæ•´è·¯å¾„å’Œå€¼
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `**${fullPath}**: \`${value}\`\n\n`;
            }

            return md;
        }

        // å¯åŠ¨æç¤º
        window.addEventListener('DOMContentLoaded', () => {
            showStatus('è¯·å…ˆè¿è¡ŒæœåŠ¡å™¨: cd /Users/pixelpanda/certora-scraper && node scripts/certora_auto_server.mjs', 'info');
        });

        // ç‚¹å‡»modalå¤–éƒ¨å…³é—­
        // å¤åˆ¶åŠŸèƒ½
        function showCopyNotification(message) {
            // ç§»é™¤ç°æœ‰çš„é€šçŸ¥
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // åˆ›å»ºæ–°é€šçŸ¥
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // 2ç§’åéšè—å¹¶åˆ é™¤
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                // å›é€€æ–¹æ³•
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (err) {
                    document.body.removeChild(textArea);
                    return false;
                }
            }
        }

        function copyMarkdown(index) {
            const rule = processedRules[index];
            if (rule && rule.markdown) {
                copyToClipboard(rule.markdown).then(success => {
                    if (success) {
                        showCopyNotification('âœ… Markdownå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } else {
                        showCopyNotification('âŒ å¤åˆ¶å¤±è´¥');
                    }
                });
            } else {
                showCopyNotification('âŒ æ²¡æœ‰å¯å¤åˆ¶çš„Markdownå†…å®¹');
            }
        }

        function copyCodexAnalysis(outputFile) {
            const textarea = document.getElementById(`analysis-${outputFile}`);
            if (textarea && textarea.value && textarea.value.trim() !== '' && !textarea.value.includes('åˆ†æä¸­...')) {
                copyToClipboard(textarea.value).then(success => {
                    if (success) {
                        showCopyNotification('âœ… Codexåˆ†æå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } else {
                        showCopyNotification('âŒ å¤åˆ¶å¤±è´¥');
                    }
                });
            } else {
                showCopyNotification('âŒ æ²¡æœ‰å¯å¤åˆ¶çš„åˆ†æç»“æœ');
            }
        }

        window.onclick = function (event) {
            const modal1 = document.getElementById('markdown-modal');
            const modal2 = document.getElementById('codex-modal');
            const modal3 = document.getElementById('fix-prompt-modal');
            if (event.target == modal1) {
                modal1.style.display = 'none';
            }
            if (event.target == modal2) {
                modal2.style.display = 'none';
            }
            if (event.target == modal3) {
                closeFixPromptModal();
            }
        }
    </script>
</body>

</html>
