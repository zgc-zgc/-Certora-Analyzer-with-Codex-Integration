<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora Analyzer with Codex</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .url-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            transition: border-color 0.3s;
            margin-bottom: 20px;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .status-error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .result-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-violated {
            background: #dc3545;
            color: white;
        }

        .status-sanity-failed {
            background: #fd7e14;
            color: white;
        }

        .status-timeout {
            background: #6c757d;
            color: white;
        }

        .codex-analysis {
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            overflow-y: auto;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .codex-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .codex-content {
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .action-buttons {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .prover-url {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border-radius: 10px;
            display: none;
        }

        .prover-url a {
            color: #155724;
            font-weight: 600;
        }

        .markdown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .markdown-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-modal:hover {
            color: #333;
        }

        .markdown-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
        }

        .copy-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .copy-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4);
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
        }

        .copy-btn:active {
            transform: translateY(0);
        }

        .view-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .view-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
        }

        .view-btn:active {
            transform: translateY(0);
        }

        .copy-btn-small {
            background: rgba(23, 162, 184, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .copy-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(19, 132, 150, 0.95);
        }

        .edit-btn-small {
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .edit-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(90, 110, 210, 0.95);
        }

        /* 新增样式：修复 prompt 预览界面 */
        .fix-prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .fix-prompt-modal-content {
            position: relative;
            background: white;
            margin: 30px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .fix-prompt-editor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            margin-bottom: 20px;
        }

        .fix-prompt-editor:focus {
            outline: none;
            border-color: #667eea;
        }

        .fix-prompt-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .fix-output-area {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        .fix-output-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .verification-url {
            margin-top: 15px;
            padding: 15px;
            background: #d4edda;
            border-radius: 8px;
            display: none;
        }

        .verification-url a {
            color: #155724;
            font-weight: 600;
            text-decoration: none;
        }

        .verification-url a:hover {
            text-decoration: underline;
        }

        .fix-status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .fix-status.info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .fix-status.success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .fix-status.error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Certora Analyzer with Codex Integration</h1>
            <p>自动分析 CVL 验证失败案例并提供修复建议</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3 style="margin-bottom: 20px; color: #212529;">输入 Certora URL</h3>
                <input type="text" class="url-input" id="certora-url"
                    placeholder="https://prover.certora.com/output/..." value="">

                <div style="margin: 10px 0 20px 0;">
                    <label for="project-path-main" style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        🗂️ Solidity 项目路径（workdir，可选，分析与修复共用）：
                    </label>
                    <input type="text" id="project-path-main"
                           placeholder="/Users/pixelpanda/Pinto/protocol/"
                           value="/Users/pixelpanda/Pinto/protocol/"
                           style="width: 100%; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; 
                                  font-family: 'Courier New', monospace; font-size: 14px;">
                    <small style="color: #6c757d; display: block; margin-top: 5px;">
                        💡 将用于 Codex 在正确目录下执行（与修复阶段共用）。
                    </small>
                </div>

                <div style="margin: 0 0 20px 0;">
                    <label for="certora-conf-select" style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        ⚙️ certoraRun 配置文件（从 <workdir>/certora/conf 自动发现 .conf）：
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="certora-conf-select" style="flex: 1; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px;">
                            <option value="">（未加载，输入或更改上方项目路径以自动加载）</option>
                        </select>
                        <button class="btn btn-primary" id="reload-conf-btn" type="button" style="padding: 10px 16px;">🔄 刷新</button>
                    </div>
                    <small id="conf-help" style="color: #6c757d; display: block; margin-top: 5px;">
                        💡 会列出 <workdir>/certora/conf 目录下的 .conf 文件；若找不到，可手动在该目录放置 .conf 并点击刷新。
                    </small>
                    <!-- 兼容旧逻辑：隐藏的文本输入，仅当无选择时作为回退 -->
                    <input type="text" id="certora-conf-path" style="display:none;">
                </div>

                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeUrl()">
                    🔍 获取验证数据
                </button>
                <script>
                    // 页面加载后尝试根据默认的项目路径初始化 conf 下拉
                    window.addEventListener('DOMContentLoaded', () => {
                        const projectInput = document.getElementById('project-path-main');
                        if (projectInput && projectInput.value.trim()) {
                            loadConfOptions();
                        }
                        const reloadBtn = document.getElementById('reload-conf-btn');
                        if (reloadBtn) {
                            reloadBtn.addEventListener('click', loadConfOptions);
                        }
                        if (projectInput) {
                            // 当用户修改项目路径时，自动刷新 conf 列表（防抖）
                            let t = null;
                            projectInput.addEventListener('input', () => {
                                if (t) clearTimeout(t);
                                t = setTimeout(loadConfOptions, 400);
                            });
                            projectInput.addEventListener('change', () => {
                                if (t) clearTimeout(t);
                                loadConfOptions();
                            });
                        }
                    });
                </script>

                <div id="status-message"></div>
            </div>

            <div id="action-buttons" class="action-buttons" style="display: none;">
                <button class="btn btn-success" id="batchAnalyzeBtn" onclick="toggleBatchAnalysis()">
                    🤖 Codex 分析所有规则
                </button>
                <button class="btn btn-warning" onclick="fixAll()">
                    🔧 执行顺序修复
                </button>
            </div>

            <!-- 修复执行输出区域 - 移到主界面 -->
            <div id="main-fix-output" style="display: none; margin-top: 20px;">
                <h3 style="margin-bottom: 20px; color: #212529;">🔧 修复执行过程</h3>
                <div id="main-fix-controls" style="margin-bottom: 12px; display: none;">
                    <button class="btn btn-danger" id="stop-fix-btn" onclick="stopFix()">⏸ 暂停并终止 Codex</button>
                </div>
                <div id="main-fix-status" class="status-message" style="margin-bottom: 15px;"></div>
                <div id="main-fix-content" style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; 
                     font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; 
                     word-break: break-word; max-height: 500px; overflow-y: auto; min-height: 200px; margin-bottom: 15px;"></div>
                <div id="main-verification-url" style="margin-top: 15px; padding: 15px; background: #d4edda; 
                     border-radius: 8px; display: none;">
                    <strong>🎉 验证完成！</strong><br>
                    查看验证结果：<a id="main-verification-link" href="#" target="_blank" style="color: #155724; font-weight: 600;"></a>
                </div>
            </div>

            <div id="result-section" style="display: none;">
                <table class="result-table" id="result-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">规则名</th>
                            <th style="width: 10%;">状态</th>
                            <th style="width: 10%;">Markdown</th>
                            <th style="width: 40%;">Codex分析结果</th>
                            <th style="width: 15%;">操作</th>
                        </tr>
                    </thead>
                    <tbody id="result-tbody">
                    </tbody>
                </table>
            </div>

            <div id="prover-url" class="prover-url">
                验证完成！查看结果：<a href="#" target="_blank" id="prover-link"></a>
            </div>
        </div>
    </div>

    <!-- Markdown Modal -->
    <div id="markdown-modal" class="markdown-modal">
        <div class="markdown-modal-content">
            <span class="close-modal" onclick="closeMarkdownModal()">&times;</span>
            <h3 id="modal-title" style="margin-bottom: 20px;">Markdown 内容</h3>
            <div id="modal-content" class="markdown-content"></div>
        </div>
    </div>

    <!-- Codex Analysis Modal -->
    <div id="codex-modal" class="codex-modal">
        <div class="codex-modal-content">
            <span class="close-modal" onclick="closeCodexModal()">&times;</span>
            <h3 id="codex-modal-title" style="margin-bottom: 20px;">Codex 分析详情</h3>
            <div id="codex-modal-content" class="codex-content"></div>
        </div>
    </div>

    <!-- Fix Prompt Modal -->
    <div id="fix-prompt-modal" class="fix-prompt-modal">
        <div class="fix-prompt-modal-content">
            <span class="close-modal" onclick="closeFixPromptModal()">&times;</span>
            <h3 style="margin-bottom: 20px;">📝 修复任务预览与编辑</h3>
            
            <div style="margin-bottom: 15px;">
                <label for="fix-prompt-editor" style="font-weight: 600; color: #495057;">修复 Prompt（可编辑）：</label>
            </div>
            
            <textarea id="fix-prompt-editor" class="fix-prompt-editor" 
                      placeholder="正在生成修复 prompt..."></textarea>
            
            <div class="fix-prompt-buttons">
                <button class="btn btn-danger" onclick="closeFixPromptModal()">
                    ❌ 取消
                </button>
                <button class="btn btn-success" id="execute-fix-btn" onclick="executeFixWithPrompt()">
                    🚀 开始执行修复
                </button>
            </div>

            <!-- 修复执行输出区域 -->
            <div id="fix-output-area" class="fix-output-area">
                <h4 style="margin-bottom: 15px;">🔧 修复执行过程</h4>
                <div id="fix-status"></div>
                <div id="fix-output-content" class="fix-output-content"></div>
                <div id="verification-url" class="verification-url">
                    <strong>🎉 验证完成！</strong><br>
                    查看验证结果：<a id="verification-link" href="#" target="_blank"></a>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allRulesData = null;
        let jsonContents = {};
        let processedRules = [];
        let sanityAggregated = null;
        let stopAnalysisFlag = false;
        const analysisControllers = new Map(); // 为每个分析维护独立的控制器
        let lastFixAnalyses = []; // 顺序修复用的分析结果缓存
        let fixAbortController = null; // 顺序修复的控制器（用于暂停/终止）

        // 加载 <workdir>/certora/conf 下的 .conf 到下拉框
        async function loadConfOptions() {
            try {
                const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
                const select = document.getElementById('certora-conf-select');
                const help = document.getElementById('conf-help');
                if (!projectPath) {
                    select.innerHTML = '<option value="">（请先填写上方项目路径）</option>';
                    return;
                }
                select.innerHTML = '<option value="">（加载中…）</option>';
                const resp = await fetch('http://localhost:3002/list-conf?projectPath=' + encodeURIComponent(projectPath));
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const data = await resp.json();
                if (!data.success) throw new Error(data.error || '加载失败');

                const files = Array.isArray(data.files) ? data.files : [];
                if (files.length === 0) {
                    select.innerHTML = '<option value="">（未在 ' + (data.baseDir || (projectPath + '/certora/conf')) + ' 找到 .conf）</option>';
                    return;
                }
                // 填充选项（显示相对路径，值为绝对路径方便后端）
                select.innerHTML = '';
                files.sort((a,b) => a.relPath.localeCompare(b.relPath));
                for (const f of files) {
                    const opt = document.createElement('option');
                    opt.value = f.fullPath;
                    opt.textContent = f.relPath;
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('certora-conf-select');
                select.innerHTML = '<option value="">（加载失败：' + (e.message || e) + '）</option>';
            }
        }

        // 处理 Codex 输出，只保留最终回答
        function extractCodexAnswer(fullOutput) {
            // 查找最后一个时间戳标记和 "tokens used:" 之间的内容
            const lines = fullOutput.split('\n');
            let lastTimeIndex = -1;
            let tokensUsedIndex = -1;

            // 查找最后一个时间戳标记，格式如 [2025-01-01T10:30:00]
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                }
                if (tokensUsedIndex > -1 && lines[i].match(/^\[[\d\-T:\.Z]+\]/)) {
                    lastTimeIndex = i;
                    break;
                }
            }

            if (lastTimeIndex >= 0 && tokensUsedIndex > lastTimeIndex) {
                // 提取最后一个时间戳后到 tokens used 之前的内容
                const answerLines = lines.slice(lastTimeIndex + 1, tokensUsedIndex);
                let answer = answerLines.join('\n').trim();

                // 移除可能的额外标记
                answer = answer.replace(/^(Assistant|AI|Codex):\s*/gm, '');
                answer = answer.replace(/^\s*[-•]\s*/gm, '');

                return answer || fullOutput;
            }

            // 如果没找到时间戳，尝试查找 "codex" 标记
            let lastCodexIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('] codex')) {
                    lastCodexIndex = i;
                }
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                    break;
                }
            }

            if (lastCodexIndex >= 0 && tokensUsedIndex > lastCodexIndex) {
                const answerLines = lines.slice(lastCodexIndex + 1, tokensUsedIndex);
                return answerLines.join('\n').trim();
            }

            // 如果都没找到，返回原内容
            return fullOutput;
        }

        async function analyzeUrl() {
            const url = document.getElementById('certora-url').value.trim();
            if (!url) {
                showStatus('请输入URL', 'error');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = '⏳ 获取中...';

            showStatus('正在获取验证数据...', 'info');

            try {
                // 调用本地服务
                const response = await fetch('http://localhost:3002/analyze-and-fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `服务器错误: ${response.status}`);
                }

                const data = await response.json();
                allRulesData = data;

                // 保存所有JSON内容
                data.rules.forEach(rule => {
                    if (rule.content) {
                        jsonContents[rule.outputFile] = rule.content;
                    }
                });

                processData(data);
                showStatus(`✅ 成功获取 ${data.rules.length} 个规则的数据`, 'success');

            } catch (error) {
                console.error('Error:', error);
                showStatus(`错误: ${error.message}。请确保运行了: node scripts/certora_auto_server.mjs`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = '🔍 获取验证数据';
            }
        }

        function processData(data) {
            processedRules = [];

            // 处理 VIOLATED 规则
            data.rules.filter(r => r.status === 'VIOLATED').forEach(rule => {
                const markdown = rule.content ? convertToMarkdown(rule) : '';
                processedRules.push({
                    ...rule,
                    type: 'VIOLATED',
                    markdown: markdown,
                    displayName: rule.ruleName
                });
            });

            // 整合 SANITY_FAILED 规则
            const sanityFailed = data.rules.filter(r => r.status === 'SANITY_FAILED');
            if (sanityFailed.length > 0) {
                sanityAggregated = aggregateSanityFailures(sanityFailed);
                processedRules.push({
                    ruleName: '汇总: Sanity Failed 规则',
                    status: 'SANITY_FAILED',
                    type: 'SANITY_FAILED',
                    markdown: sanityAggregated,
                    displayName: '汇总: Sanity Failed 规则',
                    outputFile: 'sanity_aggregated'
                });
            }

            displayResults();
            document.getElementById('action-buttons').style.display = 'flex';
        }

        function aggregateSanityFailures(rules) {
            const sanityMap = new Map();

            rules.forEach(rule => {
                const parts = rule.ruleName.split(' > ');
                const baseRule = parts[0];
                const funcName = parts[parts.length - 1];

                if (!sanityMap.has(baseRule)) {
                    sanityMap.set(baseRule, new Set());
                }
                sanityMap.get(baseRule).add(funcName);
            });

            return Array.from(sanityMap.entries()).map(([rule, funcs]) =>
                `规则 ${rule} 在以下函数中 sanity failed:\n${Array.from(funcs).map(f => `- ${f}`).join('\n')}`
            ).join('\n\n');
        }

        function displayResults() {
            const tbody = document.getElementById('result-tbody');
            tbody.innerHTML = '';

            processedRules.forEach((rule, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${formatRuleName(rule.displayName)}</td>
                    <td><span class="status-badge status-${rule.status.toLowerCase().replace('_', '-')}">${rule.status}</span></td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button class="view-btn" onclick="viewMarkdown(${index})">
                                📄 查看
                            </button>
                            <button class="copy-btn" onclick="copyMarkdown(${index})">
                                📋 复制MD
                            </button>
                        </div>
                    </td>
                    <td>
                        <div style="position: relative;">
                            <textarea class="codex-analysis" 
                                      id="analysis-${rule.outputFile}" 
                                      data-output-file="${rule.outputFile}"
                                      data-rule-name="${rule.displayName}"
                                      placeholder="可直接在此编辑 Codex 分析结果（或先点击分析）"></textarea>
                            <div style="display: flex; gap: 5px; position: absolute; top: 5px; right: 5px;">
                                <button class="copy-btn-small" 
                                        onclick="copyCodexAnalysis('${rule.outputFile}')"
                                        title="复制">
                                    📋
                                </button>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-primary" id="analyze-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px;" 
                                    onclick="analyzeRule(${index})">分析</button>
                            <button class="btn btn-danger" id="stop-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px; display: none;" 
                                    onclick="stopSingleAnalysis('${rule.outputFile}')">停止</button>
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('result-section').style.display = 'block';
        }

        // 预览区直接可编辑，无需切换编辑模式或弹窗

        function formatRuleName(name) {
            const parts = name.split(' > ');
            if (parts.length === 1) {
                return name;
            }
            return `${parts[0]} > ... > ${parts[parts.length - 1]}`;
        }

        function viewMarkdown(index) {
            const rule = processedRules[index];
            document.getElementById('modal-title').textContent = `Markdown - ${rule.displayName}`;
            document.getElementById('modal-content').textContent = rule.markdown;
            document.getElementById('markdown-modal').style.display = 'block';
        }

        function closeMarkdownModal() {
            document.getElementById('markdown-modal').style.display = 'none';
        }

        async function analyzeRule(index, isBatchAnalysis = false, retryCount = 0) {
            const maxRetries = 3;
            
            // 只有在批量分析时才检查 stopAnalysisFlag
            if (isBatchAnalysis && stopAnalysisFlag) {
                console.log('批量分析被停止标志阻止');
                return;
            }

            const rule = processedRules[index];
            if (!rule) {
                console.error(`规则索引 ${index} 不存在`);
                return;
            }

            const outputFile = rule.outputFile;

            console.log(`开始流式分析规则: ${outputFile}, 批量分析: ${isBatchAnalysis}, 重试次数: ${retryCount}`);
            console.log(`规则类型: ${rule.type}, Markdown长度: ${rule.markdown ? rule.markdown.length : 0}`);

            const textarea = document.getElementById(`analysis-${outputFile}`);
            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);

            if (!textarea || !analyzeBtn) {
                console.error(`找不到UI元素: textarea=${!!textarea}, analyzeBtn=${!!analyzeBtn}`);
                return;
            }

            // 如果这个规则已经在分析中，不重复分析
            if (analysisControllers.has(outputFile)) {
                console.log(`规则 ${outputFile} 已在分析中，跳过`);
                return;
            }

            // 显示停止按钮，隐藏分析按钮
            if (analyzeBtn) analyzeBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            if (retryCount > 0) {
                textarea.value = `重试中... (${retryCount}/${maxRetries})`;
            } else {
                textarea.value = '正在连接Codex...';
            }
            textarea.disabled = true;

            // 为这个特定的分析创建 AbortController
            const controller = new AbortController();
            analysisControllers.set(outputFile, controller);

            console.log(`创建了控制器，当前控制器数量: ${analysisControllers.size}`);

            // 检查控制器是否立即被中止
            if (controller.signal.aborted) {
                console.error('控制器创建后立即被中止！');
                analysisControllers.delete(outputFile);
                textarea.value = '分析失败：控制器被中止';
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                return;
            }

            try {
                console.log(`发送流式分析请求: ${rule.type}, Markdown前100字符: ${rule.markdown ? rule.markdown.substring(0, 100) : 'null'}`);

                // 确保 markdown 存在
                if (!rule.markdown) {
                    throw new Error('Markdown内容为空');
                }

                const projectPathMain = (document.getElementById('project-path-main')?.value || '').trim();
                const requestBody = {
                    content: rule.markdown,
                    type: rule.type
                };
                if (projectPathMain) {
                    requestBody.projectPath = projectPathMain;
                }

                console.log(`请求体大小: ${JSON.stringify(requestBody).length} 字节`);

                // 使用流式端点
                const response = await fetch('http://localhost:3002/analyze-rule-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                console.log(`收到响应: ${response.status}`);

                // 检查响应是否正常
                if (!response.ok) {
                    if (response.status === 500 && retryCount < maxRetries) {
                        // HTTP 500 错误，进行重试
                        console.log(`HTTP 500错误，将在2秒后重试 (${retryCount + 1}/${maxRetries})`);
                        analysisControllers.delete(outputFile);
                        
                        // 等待2秒后重试
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // 处理SSE流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                // 为该规则建立持久上下文，避免每次回调创建新对象导致丢失状态
                const ctx = { fullThinkingProcess: '', finalResult: '' };

                textarea.value = ''; // 清空初始内容

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // 检查是否被中止
                    if (controller.signal.aborted) {
                        reader.cancel();
                        throw new Error('分析被用户停止');
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // 保留不完整的行

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleAnalysisStreamData(data, textarea, outputFile, ctx);
                            } catch (e) {
                                console.error('解析SSE数据错误:', e, line);
                            }
                        }
                    }
                }

                console.log(`流式分析完成: ${outputFile}`);

            } catch (error) {
                console.error(`分析出错: ${outputFile}`, error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'AbortError') {
                    console.log('请求被中止，控制器状态:', controller.signal.aborted);
                    textarea.value = '分析已取消';
                } else if (error.message.includes('Failed to fetch')) {
                    if (retryCount < maxRetries) {
                        console.log(`网络错误，将重试: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = '无法连接到服务器，请确保服务器正在运行';
                } else if (error.message === 'Markdown内容为空') {
                    textarea.value = '错误：没有可分析的内容';
                } else {
                    if (retryCount < maxRetries && !error.name === 'AbortError') {
                        console.log(`通用错误，将重试: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = `错误: ${error.message}`;
                }
            } finally {
                textarea.disabled = false;
                // 恢复按钮状态
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                // 清理控制器
                analysisControllers.delete(outputFile);
                console.log(`清理控制器，剩余控制器数量: ${analysisControllers.size}`);
            }
        }

        function handleAnalysisStreamData(data, textarea, outputFile, context) {
            switch (data.type) {
                case 'info':
                    // 显示连接信息，但不添加到思考过程
                    if (data.message.includes('开始分析')) {
                        textarea.value = 'Codex 开始思考...';
                    }
                    break;
                    
                case 'output':
                    // 仅显示一次系统头（服务端只会发送这一段）
                    if (data.message && data.message.trim()) {
                        context.fullThinkingProcess = data.message.replace(/\r\n/g, '\n').replace(/\n{3,}/g, '\n\n');
                        textarea.value = context.fullThinkingProcess;
                        textarea.scrollTop = textarea.scrollHeight;
                    }
                    break;
                    
                case 'final':
                    // 保存最终结果
                    context.finalResult = data.message;
                    break;
                    
                case 'success':
                    // 分析成功完成，用最终结果替换思考过程
                    let finalContent = '';
                    if (context.finalResult && context.finalResult.trim()) {
                        finalContent = context.finalResult.trim();
                    } else {
                        // 如果没有最终结果，从 fullThinkingProcess（可能仅含系统头）与后台完整输出中提取
                        const extracted = extractCodexAnswer(context.fullThinkingProcess);
                        finalContent = extracted ? extracted.trim() : context.fullThinkingProcess.trim();
                    }
                    // 仅展示最终结果（头部信息只在开始时显示，不混入最终内容）
                    textarea.value = finalContent;
                    // 预览区默认可编辑，无需再切换
                    console.log(`流式分析成功: ${outputFile}`);
                    break;
                    
                case 'error':
                    // 显示错误信息
                    textarea.value = `分析错误: ${data.message}`;
                    console.error(`流式分析错误: ${outputFile}`, data.message);
                    break;
                    
                case 'complete':
                    // 分析完成（无论成功还是失败）
                    console.log(`流式分析结束: ${outputFile}`);
                    break;
                    
                default:
                    console.log(`未知的流式数据类型: ${data.type}`, data);
                    break;
            }
        }

        function stopSingleAnalysis(outputFile) {
            const controller = analysisControllers.get(outputFile);
            if (controller) {
                controller.abort();
                analysisControllers.delete(outputFile);
            }

            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
            const textarea = document.getElementById(`analysis-${outputFile}`);

            // 恢复按钮状态
            if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (textarea) {
                textarea.value = '分析已停止';
                textarea.disabled = false;
            }
        }

        let isBatchAnalyzing = false;

        async function toggleBatchAnalysis() {
            if (isBatchAnalyzing) {
                // 当前正在分析，执行停止操作
                stopAnalysis();
            } else {
                // 当前未在分析，开始批量分析
                await analyzeAllRules();
            }
        }

        async function analyzeAllRules() {
            isBatchAnalyzing = true;
            stopAnalysisFlag = false;
            
            // 更新按钮状态
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            batchBtn.className = 'btn btn-danger';
            batchBtn.innerHTML = '⏹️ 停止分析';
            
            showStatus('开始批量分析...', 'info');

            // 并发执行所有分析任务
            const analysisPromises = [];
            for (let i = 0; i < processedRules.length; i++) {
                if (stopAnalysisFlag) {
                    break;
                }
                // 不等待每个分析完成，直接推入Promise数组
                analysisPromises.push(analyzeRule(i, true));
            }

            try {
                // 等待所有分析任务完成
                await Promise.allSettled(analysisPromises);
            } catch (error) {
                console.error('批量分析过程中出错:', error);
            }

            // 恢复按钮状态
            isBatchAnalyzing = false;
            batchBtn.className = 'btn btn-success';
            batchBtn.innerHTML = '🤖 Codex 分析所有规则';
            
            if (!stopAnalysisFlag) {
                showStatus('✅ 所有规则分析完成', 'success');
            } else {
                showStatus('批量分析已停止', 'info');
            }
        }

        function stopAnalysis() {
            stopAnalysisFlag = true;
            isBatchAnalyzing = false;
            
            // 恢复批量分析按钮状态
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            if (batchBtn) {
                batchBtn.className = 'btn btn-success';
                batchBtn.innerHTML = '🤖 Codex 分析所有规则';
            }
            
            // 停止所有正在进行的分析
            analysisControllers.forEach((controller, outputFile) => {
                controller.abort();
                // 更新对应的UI
                const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
                const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
                const textarea = document.getElementById(`analysis-${outputFile}`);

                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                if (textarea && textarea.value === '分析中...') {
                    textarea.value = '批量分析已停止';
                    textarea.disabled = false;
                }
            });
            analysisControllers.clear();

            showStatus('批量分析已停止', 'info');
        }

        async function fixAll() {
            // 仅修复“已有分析结论”的项；不会自动触发批量分析
            const analyses = [];

            // 优先从DOM中收集，避免因ID冲突或processedRules不一致导致漏收
            const tas = Array.from(document.querySelectorAll('textarea.codex-analysis'));
            tas.forEach(ta => {
                const val = (ta.value || '').trim();
                if (!val) return;
                if (val.includes('分析中...') || val.includes('批量分析已停止') || val.startsWith('重试中...')) return;
                if (val.length < 3) return;
                if (/点击分析按钮/.test(val)) return;

                const ruleName = ta.dataset.ruleName || '';
                analyses.push({ text: val, ruleName });
            });

            if (analyses.length === 0) {
                showStatus('没有可用的分析结果，只有完成 Codex 分析的项才会进入修复', 'error');
                return;
            }

            // 缓存到全局，供顺序修复使用
            lastFixAnalyses = analyses;

            // 将选中条目列表也展示出来，便于用户核对
            const namesPreview = analyses.map((a, i) => `${i + 1}. ${a.ruleName || '(未命名规则)'}`).join('；');
            showStatus(`正在生成修复 prompt（共 ${analyses.length} 项）：${namesPreview}`, 'info');

            try {
                // 第一步：生成 prompt
                const response = await fetch('http://localhost:3002/generate-fix-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ analyses })
                });

                const result = await response.json();
                if (result.success) {
                    // 直接执行修复，不显示预览模态框
                    executeFixDirectly(result.prompt);
                } else {
                    showStatus(`生成 prompt 失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`错误: ${error.message}`, 'error');
            }
        }

        function closeFixPromptModal() {
            document.getElementById('fix-prompt-modal').style.display = 'none';
            // 重置输出区域
            document.getElementById('fix-output-area').style.display = 'none';
            document.getElementById('fix-output-content').textContent = '';
            document.getElementById('verification-url').style.display = 'none';
        }

        async function executeFixDirectly(prompt) {
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();
            
            if (!prompt) {
                showStatus('修复 prompt 为空', 'error');
                return;
            }

            // 显示主界面输出区域
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // 显示停止按钮
            document.getElementById('main-fix-controls').style.display = 'block';
            
            // 显示项目路径信息
            if (projectPath) {
                showMainFixStatus(`正在执行修复任务... 项目路径: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('正在执行修复任务... 使用自动项目搜索', 'info');
            }

            try {
                // 使用顺序流式端点执行修复，包含项目路径与conf路径
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // 创建并保存控制器，便于暂停
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // 保留不完整的行

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('解析SSE数据错误:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('修复执行错误:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('已暂停并请求终止 Codex 进程', 'info');
                } else {
                    showMainFixStatus(`执行错误: ${error.message}`, 'error');
                }
            } finally {
                // 无论成功或失败，隐藏停止按钮
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        async function executeFixWithPrompt() {
            const prompt = document.getElementById('fix-prompt-editor').value.trim();
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();
            
            if (!prompt) {
                showFixStatus('请输入修复 prompt', 'error');
                return;
            }

            // 关闭预览模态框
            document.getElementById('fix-prompt-modal').style.display = 'none';
            
            // 显示主界面输出区域
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // 显示停止按钮
            document.getElementById('main-fix-controls').style.display = 'block';
            
            // 显示项目路径信息
            if (projectPath) {
                showMainFixStatus(`正在执行修复任务... 项目路径: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('正在执行修复任务... 使用自动项目搜索', 'info');
            }

            try {
                // 使用顺序流式端点执行修复，包含项目路径与conf路径
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // 创建并保存控制器，便于暂停
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // 保留不完整的行

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('解析SSE数据错误:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('修复执行错误:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('已暂停并请求终止 Codex 进程', 'info');
                } else {
                    showMainFixStatus(`执行错误: ${error.message}`, 'error');
                }
            } finally {
                // 无论成功或失败，隐藏停止按钮
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        function handleMainFixStreamData(data) {
            const outputContent = document.getElementById('main-fix-content');
            
            switch (data.type) {
                case 'info':
                    showMainFixStatus(data.message, 'info');
                    // 同步写入日志区域，避免用户遗漏顶部状态栏
                    outputContent.innerHTML += `<span style="color:#0d6efd;">[INFO]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    break;
                case 'output':
                    // 格式化输出，处理时间戳换行
                    const formattedOutput = formatCodexOutput(data.message);
                    if (formattedOutput) {
                        outputContent.innerHTML += formattedOutput;
                        outputContent.scrollTop = outputContent.scrollHeight;
                    }
                    break;
                case 'error':
                    outputContent.innerHTML += `<span style="color: #dc3545; font-weight: bold;">[ERROR] ${data.message}</span>\n`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    showMainFixStatus('执行过程中出现错误', 'error');
                    break;
                case 'url':
                    // 显示验证URL
                    document.getElementById('main-verification-link').href = data.message;
                    document.getElementById('main-verification-link').textContent = data.message;
                    document.getElementById('main-verification-url').style.display = 'block';
                    break;
                case 'success':
                    showMainFixStatus(data.message, 'success');
                    outputContent.innerHTML += `<span style="color:#20c997;">[SUCCESS]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    break;
                case 'complete':
                    showMainFixStatus('修复任务执行完成', 'success');
                    // 任务自然完成，隐藏停止按钮
                    document.getElementById('main-fix-controls').style.display = 'none';
                    break;
            }
        }

        // 简单转义，防止日志中的HTML破坏输出
        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatCodexOutput(output) {
            // 格式化 Codex 输出，处理时间戳和其他格式
            let formatted = output;
            
            // 处理时间戳格式 [YYYY-MM-DDTHH:MM:SS.xxxZ] 或 [时间戳]
            formatted = formatted.replace(/(\[\d{4}-\d{2}-\d{2}T[\d:.Z]+\])/g, '\n<span style="color: #667eea; font-weight: bold;">$1</span>');
            
            // 处理其他常见的日志格式
            formatted = formatted.replace(/\[INFO\]/g, '<span style="color: #28a745;">[INFO]</span>');
            formatted = formatted.replace(/\[ERROR\]/g, '<span style="color: #dc3545;">[ERROR]</span>');
            formatted = formatted.replace(/\[WARNING\]/g, '<span style="color: #ffc107;">[WARNING]</span>');
            formatted = formatted.replace(/\[SUCCESS\]/g, '<span style="color: #20c997;">[SUCCESS]</span>');
            
            // 处理 exec、bash、codex 等命令标记
            formatted = formatted.replace(/(\] (exec|bash|codex|thinking)\b)/gi, '<span style="color: #6c757d; font-style: italic;">$1</span>');
            
            // 处理 ➡️ ✅ ❌ 等特殊符号，使其更醒目
            formatted = formatted.replace(/(➡️|✅|❌|⚠️)/g, '<span style="font-size: 1.2em;">$1</span>');
            
            // 处理规则名和步骤信息
            formatted = formatted.replace(/(第\s*\d+\/\d+\s*项)/g, '<span style="color: #764ba2; font-weight: bold;">$1</span>');
            formatted = formatted.replace(/(规则：[^\n]+)/g, '<span style="color: #667eea; font-weight: bold;">$1</span>');
            
            // 转换换行符为 HTML 换行
            formatted = formatted.replace(/\n/g, '<br>');
            
            return formatted;
        }

        function showMainFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('main-fix-status');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // 停止顺序修复：中止SSE并请求后端终止 Codex 进程
        async function stopFix() {
            try {
                // 先中止前端与服务器的连接，这会触发服务器端 req 'close' 钩子，从而 SIGTERM 当前子进程
                if (fixAbortController) {
                    fixAbortController.abort();
                }

                showMainFixStatus('正在终止 Codex 进程...', 'info');

                // 再调用后端统一终止接口，确保所有相关 codex 进程被关闭
                await fetch('http://localhost:3002/kill-processes', { method: 'POST' }).catch(() => {});
                showMainFixStatus('已请求终止 Codex 进程', 'success');
            } catch (e) {
                showMainFixStatus(`终止进程时出错: ${e.message}`, 'error');
            } finally {
                // 隐藏按钮，避免重复点击
                document.getElementById('main-fix-controls').style.display = 'none';
            }
        }

        function showFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('fix-status');
            statusDiv.className = `fix-status ${type}`;
            statusDiv.textContent = message;
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // 根据参考项目重写的convertToMarkdown函数
        function convertToMarkdown(rule) {
            const traceData = rule.content;
            const simplifiedRuleName = rule.ruleName.split('↳')[0].trim();
            let md = `# Certora Trace Analysis\n\n`;
            md += `**Rule:** ${simplifiedRuleName}\n`;
            md += `**Status:** ${rule.status}\n`;
            md += `**File:** ${rule.outputFile}\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## 🌳 Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second position) - 直接从variables数组中提取
            md += `\n## 📊 Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                md += renderVariablesFromArray(traceData.variables);
            } else {
                md += `暂无变量数据\n\n`;
            }

            // 3. Global State Diff (third position) - 从Call Trace中的Global State节点计算变化
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## 🔄 Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                md += `## 🚨 Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            }

            return md;
        }

        // Call Trace转换 - 参考项目版本
        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    let value = '?';

                    if (arg.value !== undefined) {
                        value = arg.value;
                        // 如果有多个值表示，优先显示可读性高的
                        if (arg.values && arg.values.length > 1) {
                            const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                            if (decValue && parseInt(decValue) < 1000000) {
                                value = `${arg.value} (${decValue})`;
                            }
                        }
                    } else if (arg.values && Array.isArray(arg.values) && arg.values.length > 0) {
                        value = arg.values[0];
                    }

                    messageText = messageText.replace(placeholder, value);
                });
            }

            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // 计算Global State差异 - 参考项目版本  
        function calculateGlobalStateDiff(callTrace) {
            const globalStateNodes = [];

            // 收集所有Global State节点
            collectGlobalStateNodes(callTrace, globalStateNodes);

            if (globalStateNodes.length === 0) {
                return {};
            }

            // 提取第一个和最后一个Global State的状态
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);

            // 计算差异
            const diff = {};

            // 收集所有状态键
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);

            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];

                // 只有当值确实发生变化时才记录
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                } else if (firstValue && lastValue) {
                    // 值没有变化，但存在于两个状态中
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                }
            });

            return diff;
        }

        // 递归收集所有Global State节点
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node && node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }

            if (node && node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // 从Global State节点中提取状态信息
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};

            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }

            return state;
        }

        // 递归提取状态信息
        function extractStateRecursively(node, state) {
            // 如果节点有arguments，说明这是一个状态记录
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // 替换占位符得到完整的状态路径
                let fullPath = node.message.text;
                let stateValue = null;

                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // 使用最易读的值表示
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // 如果有十进制表示，优先使用
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);

                            // 最后一个参数通常是值
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });

                // 解析路径和值
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }

            // 递归处理子节点
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // 解析状态路径
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }

            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();

            // 如果有从arguments中提取的值，优先使用
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }

            // 清理引号
            value = value.replace(/^['"]|['"]$/g, '');

            return { path, value };
        }

        // 渲染Global State差异
        function renderGlobalStateDiff(diff) {
            let md = '';

            // 按路径类型分组
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] },
                'other': { title: 'Other Changes', items: [] }
            };

            Object.entries(diff).forEach(([path, change]) => {
                const item = { path, change };

                if (path.includes('storage') || path.includes('balanceOf') || path.includes('_storage')) {
                    groups.storage.items.push(item);
                } else if (path.includes('balance') || path.includes('Balance')) {
                    groups.balance.items.push(item);
                } else if (path.includes('ghost') || path.includes('Ghost')) {
                    groups.ghost.items.push(item);
                } else {
                    groups.other.items.push(item);
                }
            });

            // 渲染各组
            Object.values(groups).forEach(group => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    group.items.forEach(item => {
                        const { path, change } = item;
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` → \`${change.to}\` ✨\n`;
                        } else {
                            md += `- **${path}**: \`${change.from}\` (unchanged)\n`;
                        }
                    });
                    md += `\n`;
                }
            });

            return md;
        }

        // 从variables数组中渲染层次结构 - 参考项目版本
        function renderVariablesFromArray(variables) {
            let md = '';

            variables.forEach((variable, index) => {
                // 只处理有variableName字段的对象
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // 处理有childrenList的变量
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                    } else {
                        // 简单变量，直接输出变量名和值
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `**${name}**: \`${value}\`\n\n`;
                    }
                }
            });

            return md;
        }

        // 处理嵌套变量 - 参考项目版本
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];

            // 如果有子变量，递归处理
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // 确保child是有效的对象且有variableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // 叶节点，输出完整路径和值
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `**${fullPath}**: \`${value}\`\n\n`;
            }

            return md;
        }

        // 启动提示
        window.addEventListener('DOMContentLoaded', () => {
            showStatus('请先运行服务器: cd /Users/pixelpanda/certora-scraper && node scripts/certora_auto_server.mjs', 'info');
        });

        // 点击modal外部关闭
        // 复制功能
        function showCopyNotification(message) {
            // 移除现有的通知
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // 创建新通知
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // 显示动画
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // 2秒后隐藏并删除
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                // 回退方法
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (err) {
                    document.body.removeChild(textArea);
                    return false;
                }
            }
        }

        function copyMarkdown(index) {
            const rule = processedRules[index];
            if (rule && rule.markdown) {
                copyToClipboard(rule.markdown).then(success => {
                    if (success) {
                        showCopyNotification('✅ Markdown已复制到剪贴板');
                    } else {
                        showCopyNotification('❌ 复制失败');
                    }
                });
            } else {
                showCopyNotification('❌ 没有可复制的Markdown内容');
            }
        }

        function copyCodexAnalysis(outputFile) {
            const textarea = document.getElementById(`analysis-${outputFile}`);
            if (textarea && textarea.value && textarea.value.trim() !== '' && !textarea.value.includes('分析中...')) {
                copyToClipboard(textarea.value).then(success => {
                    if (success) {
                        showCopyNotification('✅ Codex分析已复制到剪贴板');
                    } else {
                        showCopyNotification('❌ 复制失败');
                    }
                });
            } else {
                showCopyNotification('❌ 没有可复制的分析结果');
            }
        }

        window.onclick = function (event) {
            const modal1 = document.getElementById('markdown-modal');
            const modal2 = document.getElementById('codex-modal');
            const modal3 = document.getElementById('fix-prompt-modal');
            if (event.target == modal1) {
                modal1.style.display = 'none';
            }
            if (event.target == modal2) {
                modal2.style.display = 'none';
            }
            if (event.target == modal3) {
                closeFixPromptModal();
            }
        }
    </script>
</body>

</html>
