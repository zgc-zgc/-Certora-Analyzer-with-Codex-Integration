<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora Analyzer with Codex</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .url-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            transition: border-color 0.3s;
            margin-bottom: 20px;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .status-error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .result-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-violated {
            background: #dc3545;
            color: white;
        }

        .status-sanity-failed {
            background: #fd7e14;
            color: white;
        }

        .status-timeout {
            background: #6c757d;
            color: white;
        }

        .codex-analysis {
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            overflow-y: auto;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .codex-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .codex-content {
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .action-buttons {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .prover-url {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border-radius: 10px;
            display: none;
        }

        .prover-url a {
            color: #155724;
            font-weight: 600;
        }

        .markdown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .markdown-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-modal:hover {
            color: #333;
        }

        .markdown-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
        }

        .copy-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .copy-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4);
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
        }

        .copy-btn:active {
            transform: translateY(0);
        }

        .view-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .view-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
        }

        .view-btn:active {
            transform: translateY(0);
        }

        .copy-btn-small {
            background: rgba(23, 162, 184, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .copy-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(19, 132, 150, 0.95);
        }

        .edit-btn-small {
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .edit-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(90, 110, 210, 0.95);
        }

        /* New styles: fix prompt preview interface */
        .fix-prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .fix-prompt-modal-content {
            position: relative;
            background: white;
            margin: 30px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .fix-prompt-editor {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            margin-bottom: 20px;
        }

        .fix-prompt-editor:focus {
            outline: none;
            border-color: #667eea;
        }

        .fix-prompt-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .fix-output-area {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        .fix-output-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .verification-url {
            margin-top: 15px;
            padding: 15px;
            background: #d4edda;
            border-radius: 8px;
            display: none;
        }

        .verification-url a {
            color: #155724;
            font-weight: 600;
            text-decoration: none;
        }

        .verification-url a:hover {
            text-decoration: underline;
        }

        .fix-status {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .fix-status.info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .fix-status.success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .fix-status.error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Certora Analyzer with Codex Integration</h1>
            <p>Automatically analyze & fix CVL verification failure cases</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3 style="margin-bottom: 20px; color: #212529;">Enter Certora URL</h3>
                <input type="text" class="url-input" id="certora-url"
                    placeholder="https://prover.certora.com/output/..." value="">

                <div style="margin: 10px 0 20px 0;">
                    <label for="project-path-main"
                        style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        🗂️ Solidity project path (workdir, optional, shared for analysis and fix):
                    </label>
                    <input type="text" id="project-path-main" placeholder="/Users/pixelpanda/Pinto/protocol/"
                        value="/Users/pixelpanda/Pinto/protocol/" style="width: 100%; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; 
                                  font-family: 'Courier New', monospace; font-size: 14px;">
                    <small style="color: #6c757d; display: block; margin-top: 5px;">
                        💡 Will be used for Codex to execute in the correct directory (shared with fix phase).
                    </small>
                </div>

                <div style="margin: 0 0 20px 0;">
                    <label for="certora-conf-select"
                        style="font-weight: 600; color: #495057; display: block; margin-bottom: 8px;">
                        ⚙️ certoraRun configuration file (auto-discover .conf from <workdir>/certora/conf):
                    </label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="certora-conf-select"
                            style="flex: 1; padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px;">
                            <option value="">(Not loaded, enter or change project path above to auto-load)</option>
                        </select>
                        <button class="btn btn-primary" id="reload-conf-btn" type="button"
                            style="padding: 10px 16px;">🔄 Refresh</button>
                    </div>
                    <small id="conf-help" style="color: #6c757d; display: block; margin-top: 5px;">
                        💡 Lists .conf files in <workdir>/certora/conf directory; if not found, manually place .conf in
                            that directory and click refresh.
                    </small>
                    <!-- Compatible with old logic: hidden text input, used as fallback only when no selection -->
                    <input type="text" id="certora-conf-path" style="display:none;">
                </div>

                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeUrl()">
                    🔍 Get verification data
                </button>
                <script>
                    // Try to initialize conf dropdown based on default project path after page load
                    window.addEventListener('DOMContentLoaded', () => {
                        const projectInput = document.getElementById('project-path-main');
                        if (projectInput && projectInput.value.trim()) {
                            loadConfOptions();
                        }
                        const reloadBtn = document.getElementById('reload-conf-btn');
                        if (reloadBtn) {
                            reloadBtn.addEventListener('click', loadConfOptions);
                        }
                        if (projectInput) {
                            // When user changes project path, automatically refresh conf list (with debounce)
                            let t = null;
                            projectInput.addEventListener('input', () => {
                                if (t) clearTimeout(t);
                                t = setTimeout(loadConfOptions, 400);
                            });
                            projectInput.addEventListener('change', () => {
                                if (t) clearTimeout(t);
                                loadConfOptions();
                            });
                        }
                    });
                </script>

                <div id="status-message"></div>
            </div>

            <div id="action-buttons" class="action-buttons" style="display: none;">
                <button class="btn btn-success" id="batchAnalyzeBtn" onclick="toggleBatchAnalysis()">
                    🤖 Codex analyze all rules
                </button>
                <button class="btn btn-warning" onclick="fixAll()">
                    🔧 Execute sequential fix
                </button>
            </div>

            <!-- Fix execution output area - moved to main interface -->
            <div id="main-fix-output" style="display: none; margin-top: 20px;">
                <h3 style="margin-bottom: 20px; color: #212529;">🔧 Fix execution process</h3>
                <div id="main-fix-controls" style="margin-bottom: 12px; display: none;">
                    <button class="btn btn-danger" id="stop-fix-btn" onclick="stopFix()">⏸ Pause and terminate
                        Codex</button>
                </div>
                <div id="main-fix-status" class="status-message" style="margin-bottom: 15px;"></div>
                <div id="main-fix-content"
                    style="background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 8px; 
                     font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; 
                     word-break: break-word; max-height: 500px; overflow-y: auto; min-height: 200px; margin-bottom: 15px;"></div>
                <div id="main-verification-url" style="margin-top: 15px; padding: 15px; background: #d4edda; 
                     border-radius: 8px; display: none;">
                    <strong>🎉 Verification submitted!</strong><br>
                    View verification results: <a id="main-verification-link" href="#" target="_blank"
                        style="color: #155724; font-weight: 600;"></a>
                </div>
            </div>

            <div id="result-section" style="display: none;">
                <table class="result-table" id="result-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">Rule Name</th>
                            <th style="width: 10%;">Status</th>
                            <th style="width: 10%;">Data</th>
                            <th style="width: 40%;">Codex Analysis Result</th>
                            <th style="width: 15%;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="result-tbody">
                    </tbody>
                </table>
            </div>

            <div id="prover-url" class="prover-url">
                Verification complete! View results: <a href="#" target="_blank" id="prover-link"></a>
            </div>
        </div>
    </div>

    <!-- Markdown Modal -->
    <div id="markdown-modal" class="markdown-modal">
        <div class="markdown-modal-content">
            <span class="close-modal" onclick="closeMarkdownModal()">&times;</span>
            <h3 id="modal-title" style="margin-bottom: 20px;">Markdown Content</h3>
            <div id="modal-content" class="markdown-content"></div>
        </div>
    </div>

    <!-- Codex Analysis Modal -->
    <div id="codex-modal" class="codex-modal">
        <div class="codex-modal-content">
            <span class="close-modal" onclick="closeCodexModal()">&times;</span>
            <h3 id="codex-modal-title" style="margin-bottom: 20px;">Codex Analysis Details</h3>
            <div id="codex-modal-content" class="codex-content"></div>
        </div>
    </div>

    <!-- Fix Prompt Modal -->
    <div id="fix-prompt-modal" class="fix-prompt-modal">
        <div class="fix-prompt-modal-content">
            <span class="close-modal" onclick="closeFixPromptModal()">&times;</span>
            <h3 style="margin-bottom: 20px;">📝 Fix Task Preview and Edit</h3>

            <div style="margin-bottom: 15px;">
                <label for="fix-prompt-editor" style="font-weight: 600; color: #495057;">Fix Prompt (editable):</label>
            </div>

            <textarea id="fix-prompt-editor" class="fix-prompt-editor"
                placeholder="Generating fix prompt..."></textarea>

            <div class="fix-prompt-buttons">
                <button class="btn btn-danger" onclick="closeFixPromptModal()">
                    ❌ Cancel
                </button>
                <button class="btn btn-success" id="execute-fix-btn" onclick="executeFixWithPrompt()">
                    🚀 Start executing fix
                </button>
            </div>

            <!-- Fix execution output area -->
            <div id="fix-output-area" class="fix-output-area">
                <h4 style="margin-bottom: 15px;">🔧 Fix Execution Process</h4>
                <div id="fix-status"></div>
                <div id="fix-output-content" class="fix-output-content"></div>
                <div id="verification-url" class="verification-url">
                    <strong>🎉 Verification Completed!</strong><br>
                    View verification result: <a id="verification-link" href="#" target="_blank"></a>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allRulesData = null;
        let jsonContents = {};
        let processedRules = [];
        let sanityAggregated = null;
        let stopAnalysisFlag = false;
        const analysisControllers = new Map(); // Maintain controller per analysis
        let lastFixAnalyses = []; // Cache for sequential fix
        let fixAbortController = null; // Controller for sequential fix (pause/terminate)

        // Load .conf under <workdir>/certora/conf into dropdown
        async function loadConfOptions() {
            try {
                const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
                const select = document.getElementById('certora-conf-select');
                const help = document.getElementById('conf-help');
                if (!projectPath) {
                    select.innerHTML = '<option value="">(Enter project path above first)</option>';
                    return;
                }
                select.innerHTML = '<option value="">(Loading…)</option>';
                const resp = await fetch('http://localhost:3002/list-conf?projectPath=' + encodeURIComponent(projectPath));
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const data = await resp.json();
                if (!data.success) throw new Error(data.error || 'Load failed');

                const files = Array.isArray(data.files) ? data.files : [];
                if (files.length === 0) {
                    select.innerHTML = '<option value="">(No .conf found in ' + (data.baseDir || (projectPath + '/certora/conf')) + ')</option>';
                    return;
                }
                // Fill options (display relPath, value fullPath)
                select.innerHTML = '';
                files.sort((a, b) => a.relPath.localeCompare(b.relPath));
                for (const f of files) {
                    const opt = document.createElement('option');
                    opt.value = f.fullPath;
                    opt.textContent = f.relPath;
                    select.appendChild(opt);
                }
            } catch (e) {
                const select = document.getElementById('certora-conf-select');
                select.innerHTML = '<option value="">(Load failed: ' + (e.message || e) + ')</option>';
            }
        }

        // Process Codex output and keep only final answer
        function extractCodexAnswer(fullOutput) {
            // Find content between last timestamp and "tokens used:"
            const lines = fullOutput.split('\n');
            let lastTimeIndex = -1;
            let tokensUsedIndex = -1;

            // Find last timestamp like [2025-01-01T10:30:00]
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                }
                if (tokensUsedIndex > -1 && lines[i].match(/^\[[\d\-T:\.Z]+\]/)) {
                    lastTimeIndex = i;
                    break;
                }
            }

            if (lastTimeIndex >= 0 && tokensUsedIndex > lastTimeIndex) {
                // Extract content after last timestamp until tokens used
                const answerLines = lines.slice(lastTimeIndex + 1, tokensUsedIndex);
                let answer = answerLines.join('\n').trim();

                // Remove extra markers
                answer = answer.replace(/^(Assistant|AI|Codex):\s*/gm, '');
                answer = answer.replace(/^\s*[-•]\s*/gm, '');

                return answer || fullOutput;
            }

            // If no timestamp, try look for "codex" marker
            let lastCodexIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('] codex')) {
                    lastCodexIndex = i;
                }
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                    break;
                }
            }

            if (lastCodexIndex >= 0 && tokensUsedIndex > lastCodexIndex) {
                const answerLines = lines.slice(lastCodexIndex + 1, tokensUsedIndex);
                return answerLines.join('\n').trim();
            }

            // If nothing found, return original
            return fullOutput;
        }

        async function analyzeUrl() {
            const url = document.getElementById('certora-url').value.trim();
            if (!url) {
                showStatus('Please enter URL', 'error');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = '⏳ Processing...';

            showStatus('Getting verification data...', 'info');

            try {
                // Call local service
                const response = await fetch('http://localhost:3002/analyze-and-fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `Server error: ${response.status}`);
                }

                const data = await response.json();
                allRulesData = data;

                // Cache all JSON contents
                data.rules.forEach(rule => {
                    if (rule.content) {
                        jsonContents[rule.outputFile] = rule.content;
                    }
                });

                processData(data);
                showStatus(`✅ Successfully retrieved ${data.rules.length} rules data`, 'success');

            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error: ${error.message}. Please ensure you ran: node scripts/certora_auto_server.mjs`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = '🔍 Get verification data';
            }
        }

        function processData(data) {
            processedRules = [];

            // Process VIOLATED rules
            data.rules.filter(r => r.status === 'VIOLATED').forEach(rule => {
                const markdown = rule.content ? convertToMarkdown(rule) : '';
                processedRules.push({
                    ...rule,
                    type: 'VIOLATED',
                    markdown: markdown,
                    displayName: rule.ruleName
                });
            });

            // Aggregate SANITY_FAILED rules
            const sanityFailed = data.rules.filter(r => r.status === 'SANITY_FAILED');
            if (sanityFailed.length > 0) {
                sanityAggregated = aggregateSanityFailures(sanityFailed);
                processedRules.push({
                    ruleName: 'Summary: Sanity Failed Rules',
                    status: 'SANITY_FAILED',
                    type: 'SANITY_FAILED',
                    markdown: sanityAggregated,
                    displayName: 'Summary: Sanity Failed Rules',
                    outputFile: 'sanity_aggregated'
                });
            }

            displayResults();
            document.getElementById('action-buttons').style.display = 'flex';
        }

        function aggregateSanityFailures(rules) {
            const sanityMap = new Map();

            rules.forEach(rule => {
                const parts = rule.ruleName.split(' > ');
                const baseRule = parts[0];
                const funcName = parts[parts.length - 1];

                if (!sanityMap.has(baseRule)) {
                    sanityMap.set(baseRule, new Set());
                }
                sanityMap.get(baseRule).add(funcName);
            });

            return Array.from(sanityMap.entries()).map(([rule, funcs]) =>
                `Rule ${rule} sanity failed in the following functions:\n${Array.from(funcs).map(f => `- ${f}`).join('\n')}`
            ).join('\n\n');
        }

        function displayResults() {
            const tbody = document.getElementById('result-tbody');
            tbody.innerHTML = '';

            processedRules.forEach((rule, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${formatRuleName(rule.displayName)}</td>
                    <td><span class="status-badge status-${rule.status.toLowerCase().replace('_', '-')}">${rule.status}</span></td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button class="view-btn" onclick="viewMarkdown(${index})">
                                📄 View
                            </button>
                            <button class="copy-btn" onclick="copyMarkdown(${index})">
                                📋 Copy
                            </button>
                        </div>
                    </td>
                    <td>
                        <div style="position: relative;">
                            <textarea class="codex-analysis" 
                                      id="analysis-${rule.outputFile}" 
                                      data-output-file="${rule.outputFile}"
                                      data-rule-name="${rule.displayName}"
                                      placeholder="You can edit Codex analysis here (or click Analyze first)"></textarea>
                            <div style="display: flex; gap: 5px; position: absolute; top: 5px; right: 5px;">
                                <button class="copy-btn-small" 
                                        onclick="copyCodexAnalysis('${rule.outputFile}')"
                                        title="Copy">
                                    📋
                                </button>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-primary" id="analyze-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px;" 
                                    onclick="analyzeRule(${index})">Analyze</button>
                            <button class="btn btn-danger" id="stop-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px; display: none;" 
                                    onclick="stopSingleAnalysis('${rule.outputFile}')">Stop</button>
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('result-section').style.display = 'block';
        }

        // Preview area is editable directly; no modal/switch needed

        function formatRuleName(name) {
            const parts = name.split(' > ');
            if (parts.length === 1) {
                return name;
            }
            return `${parts[0]} > ... > ${parts[parts.length - 1]}`;
        }

        function viewMarkdown(index) {
            const rule = processedRules[index];
            document.getElementById('modal-title').textContent = `Markdown - ${rule.displayName}`;
            document.getElementById('modal-content').textContent = rule.markdown;
            document.getElementById('markdown-modal').style.display = 'block';
        }

        function closeMarkdownModal() {
            document.getElementById('markdown-modal').style.display = 'none';
        }

        async function analyzeRule(index, isBatchAnalysis = false, retryCount = 0) {
            const maxRetries = 3;

            // Only check stopAnalysisFlag during batch analysis
            if (isBatchAnalysis && stopAnalysisFlag) {
                console.log('Batch analysis prevented by stop flag');
                return;
            }

            const rule = processedRules[index];
            if (!rule) {
                console.error(`Rule index ${index} does not exist`);
                return;
            }

            const outputFile = rule.outputFile;

            console.log(`Start streaming analysis: ${outputFile}, batch: ${isBatchAnalysis}, retry: ${retryCount}`);
            console.log(`Rule type: ${rule.type}, Markdown length: ${rule.markdown ? rule.markdown.length : 0}`);

            const textarea = document.getElementById(`analysis-${outputFile}`);
            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);

            if (!textarea || !analyzeBtn) {
                console.error(`UI elements not found: textarea=${!!textarea}, analyzeBtn=${!!analyzeBtn}`);
                return;
            }

            // If already analyzing this rule, skip
            if (analysisControllers.has(outputFile)) {
                console.log(`Rule ${outputFile} is already being analyzed, skipping`);
                return;
            }

            // Show Stop, hide Analyze
            if (analyzeBtn) analyzeBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            if (retryCount > 0) {
                textarea.value = `Retrying... (${retryCount}/${maxRetries})`;
            } else {
                textarea.value = 'Connecting to Codex...';
            }
            textarea.disabled = true;

            // Create AbortController for this analysis
            const controller = new AbortController();
            analysisControllers.set(outputFile, controller);

            console.log(`Created controller, current count: ${analysisControllers.size}`);

            // Check if controller is already aborted
            if (controller.signal.aborted) {
                console.error('Controller aborted immediately after creation!');
                analysisControllers.delete(outputFile);
                textarea.value = 'Analysis failed: controller aborted';
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                return;
            }

            try {
                console.log(`Sending streaming analysis request: ${rule.type}, first 100 chars: ${rule.markdown ? rule.markdown.substring(0, 100) : 'null'}`);

                // Ensure markdown exists
                if (!rule.markdown) {
                    throw new Error('Markdown content is empty');
                }

                const projectPathMain = (document.getElementById('project-path-main')?.value || '').trim();
                const requestBody = {
                    content: rule.markdown,
                    type: rule.type
                };
                if (projectPathMain) {
                    requestBody.projectPath = projectPathMain;
                }

                console.log(`Request body size: ${JSON.stringify(requestBody).length} bytes`);

                // Use streaming endpoint
                const response = await fetch('http://localhost:3002/analyze-rule-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                console.log(`Received response: ${response.status}`);

                // Check response ok
                if (!response.ok) {
                    if (response.status === 500 && retryCount < maxRetries) {
                        // HTTP 500: retry
                        console.log(`HTTP 500 error, retrying in 2s (${retryCount + 1}/${maxRetries})`);
                        analysisControllers.delete(outputFile);

                        // Wait 2s then retry
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Handle SSE streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                // Build persistent context for this rule
                const ctx = { fullThinkingProcess: '', finalResult: '' };

                textarea.value = ''; // Clear initial content

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // Check abort
                    if (controller.signal.aborted) {
                        reader.cancel();
                        throw new Error('Analysis stopped by user');
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // keep incomplete line

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleAnalysisStreamData(data, textarea, outputFile, ctx);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, line);
                            }
                        }
                    }
                }

                console.log(`Streaming analysis completed: ${outputFile}`);

            } catch (error) {
                console.error(`Analysis error: ${outputFile}`, error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'AbortError') {
                    console.log('Request aborted, controller state:', controller.signal.aborted);
                    textarea.value = 'Analysis cancelled';
                } else if (error.message.includes('Failed to fetch')) {
                    if (retryCount < maxRetries) {
                        console.log(`Network error, will retry: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = 'Cannot connect to server. Please ensure the server is running';
                } else if (error.message === 'Markdown content is empty') {
                    textarea.value = 'Error: no content to analyze';
                } else {
                    if (retryCount < maxRetries && !error.name === 'AbortError') {
                        console.log(`Generic error, will retry: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = `Error: ${error.message}`;
                }
            } finally {
                textarea.disabled = false;
                // Restore button state
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                // Cleanup controller
                analysisControllers.delete(outputFile);
                console.log(`Cleanup controller, remaining count: ${analysisControllers.size}`);
            }
        }

        function handleAnalysisStreamData(data, textarea, outputFile, context) {
            switch (data.type) {
                case 'info':
                    // Show connection info, but don't mix into thinking content
                    if (/start(ing)? analysis/i.test(data.message)) {
                        textarea.value = 'Codex is thinking...';
                    }
                    break;

                case 'output':
                    // Append output content more efficiently
                    if (data.message) {
                        context.fullThinkingProcess += data.message;
                        // Use insertAdjacentText for better performance
                        const currentPos = textarea.selectionStart;
                        const currentEnd = textarea.selectionEnd;
                        textarea.value += data.message;
                        // Restore cursor position to avoid jumping
                        textarea.setSelectionRange(currentPos, currentEnd);
                        // Defer scrolling to avoid blocking
                        requestAnimationFrame(() => {
                            textarea.scrollTop = textarea.scrollHeight;
                        });
                    }
                    break;

                case 'final':
                    // Save final result
                    context.finalResult = data.message;
                    break;

                case 'success':
                    // Analysis succeeded; replace thinking process with final result
                    let finalContent = '';
                    if (context.finalResult && context.finalResult.trim()) {
                        finalContent = context.finalResult.trim();
                    } else {
                        // If no explicit final result, extract from fullThinkingProcess
                        const extracted = extractCodexAnswer(context.fullThinkingProcess);
                        finalContent = extracted ? extracted.trim() : context.fullThinkingProcess.trim();
                    }
                    // Show only the final result
                    textarea.value = finalContent;
                    // Preview is editable by default
                    console.log(`Streaming analysis success: ${outputFile}`);
                    break;

                case 'error':
                    // Show error message
                    textarea.value = `Analysis error: ${data.message}`;
                    console.error(`Streaming analysis error: ${outputFile}`, data.message);
                    break;

                case 'complete':
                    // Analysis finished (success or failure)
                    console.log(`Streaming analysis finished: ${outputFile}`);
                    break;

                default:
                    console.log(`Unknown streamed data type: ${data.type}`, data);
                    break;
            }
        }

        function stopSingleAnalysis(outputFile) {
            const controller = analysisControllers.get(outputFile);
            if (controller) {
                controller.abort();
                analysisControllers.delete(outputFile);
            }

            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
            const textarea = document.getElementById(`analysis-${outputFile}`);

            // Restore button state
            if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (textarea) {
                textarea.value = 'Analysis stopped';
                textarea.disabled = false;
            }
        }

        let isBatchAnalyzing = false;

        async function toggleBatchAnalysis() {
            if (isBatchAnalyzing) {
                // Currently analyzing — perform stop
                stopAnalysis();
            } else {
                // Not analyzing — start batch analysis
                await analyzeAllRules();
            }
        }

        async function analyzeAllRules() {
            isBatchAnalyzing = true;
            stopAnalysisFlag = false;

            // Update batch button state
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            batchBtn.className = 'btn btn-danger';
            batchBtn.innerHTML = '⏹️ Stop Analysis';

            showStatus('Starting batch analysis...', 'info');

            // Start all analyses concurrently
            const analysisPromises = [];
            for (let i = 0; i < processedRules.length; i++) {
                if (stopAnalysisFlag) {
                    break;
                }
                // Push promises without waiting for each one
                analysisPromises.push(analyzeRule(i, true));
            }

            try {
                // Wait for all analyses to settle
                await Promise.allSettled(analysisPromises);
            } catch (error) {
                console.error('Error during batch analysis:', error);
            }

            // Restore button state
            isBatchAnalyzing = false;
            batchBtn.className = 'btn btn-success';
            batchBtn.innerHTML = '🤖 Codex analyze all rules';

            if (!stopAnalysisFlag) {
                showStatus('✅ All rules analysis completed', 'success');
            } else {
                showStatus('Batch analysis stopped', 'info');
            }
        }

        function stopAnalysis() {
            stopAnalysisFlag = true;
            isBatchAnalyzing = false;

            // Restore batch analyze button state
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            if (batchBtn) {
                batchBtn.className = 'btn btn-success';
                batchBtn.innerHTML = '🤖 Codex analyze all rules';
            }

            // Stop all ongoing analyses
            analysisControllers.forEach((controller, outputFile) => {
                controller.abort();
                // Update corresponding UI
                const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
                const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
                const textarea = document.getElementById(`analysis-${outputFile}`);

                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                if (textarea && textarea.value === 'Analyzing...') {
                    textarea.value = 'Batch analysis stopped';
                    textarea.disabled = false;
                }
            });
            analysisControllers.clear();

            showStatus('Batch analysis stopped', 'info');
        }

        async function fixAll() {
            // Only fix items with existing analysis; does not auto-start batch analysis
            const analyses = [];

            // Prefer collecting from DOM to avoid ID conflicts or stale processedRules
            const tas = Array.from(document.querySelectorAll('textarea.codex-analysis'));
            tas.forEach(ta => {
                const val = (ta.value || '').trim();
                if (!val) return;
                if (val.includes('Analyzing...') || val.includes('Batch analysis stopped') || val.startsWith('Retrying...')) return;
                if (val.length < 3) return;
                if (/Click Analyze/.test(val)) return;

                const ruleName = ta.dataset.ruleName || '';
                analyses.push({ text: val, ruleName });
            });

            if (analyses.length === 0) {
                showStatus('No available analysis results, only items that completed Codex analysis will enter fix', 'error');
                return;
            }

            // Cache to global for sequential fix
            lastFixAnalyses = analyses;

            // Initialize rule status tracking and show multi-line list with status
            window.ruleFixStatus = analyses.map((a, i) => ({
                index: i + 1,
                ruleName: a.ruleName || '(Unnamed Rule)',
                status: 'Pending'
            }));
            updateStatusDisplay();

            try {
                // Step 1: generate prompt
                const response = await fetch('http://localhost:3002/generate-fix-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ analyses })
                });

                const result = await response.json();
                if (result.success) {
                    // Execute fix directly; no preview modal
                    executeFixDirectly(result.prompt);
                } else {
                    showStatus(`Generate prompt failed: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }
        }

        function closeFixPromptModal() {
            document.getElementById('fix-prompt-modal').style.display = 'none';
            // Reset output area
            document.getElementById('fix-output-area').style.display = 'none';
            document.getElementById('fix-output-content').textContent = '';
            document.getElementById('verification-url').style.display = 'none';
        }

        async function executeFixDirectly(prompt) {
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();

            if (!prompt) {
                showStatus('Fix prompt is empty', 'error');
                return;
            }

            // Show main output area
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // Show stop button
            document.getElementById('main-fix-controls').style.display = 'block';

            // Show project path info
            if (projectPath) {
                showMainFixStatus(`Executing fix task... Project path: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('Executing fix task... Using automatic project search', 'info');
            }

            try {
                // Execute fix using sequential streaming endpoint, include project/conf paths
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // Create and save controller for cancellation
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // keep incomplete line

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Fix execution error:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('Paused and requested termination of Codex processes', 'info');
                } else {
                    showMainFixStatus(`Execution error: ${error.message}`, 'error');
                }
            } finally {
                // Hide stop button regardless of result
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        async function executeFixWithPrompt() {
            const prompt = document.getElementById('fix-prompt-editor').value.trim();
            const projectPath = (document.getElementById('project-path-main')?.value || '').trim();
            const confPath = (
                document.getElementById('certora-conf-select')?.value ||
                document.getElementById('certora-conf-path')?.value ||
                ''
            ).trim();

            if (!prompt) {
                showFixStatus('Please enter fix prompt', 'error');
                return;
            }

            // Close preview modal
            document.getElementById('fix-prompt-modal').style.display = 'none';

            // Show main output area
            document.getElementById('main-fix-output').style.display = 'block';
            document.getElementById('main-fix-content').textContent = '';
            document.getElementById('main-verification-url').style.display = 'none';
            // Show stop button
            document.getElementById('main-fix-controls').style.display = 'block';

            // Show project path info
            if (projectPath) {
                showMainFixStatus(`Executing fix task... Project path: ${projectPath}`, 'info');
            } else {
                showMainFixStatus('Executing fix task... Using automatic project search', 'info');
            }

            try {
                // Use sequential streaming endpoint for fix, include projectPath/confPath
                const requestBody = { basePrompt: prompt, analyses: lastFixAnalyses };
                if (projectPath) requestBody.projectPath = projectPath;
                if (confPath) requestBody.confPath = confPath;
                // Create and hold controller for cancellation
                fixAbortController = new AbortController();

                const response = await fetch('http://localhost:3002/fix-sequential-stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: fixAbortController.signal
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // keep incomplete line

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                handleMainFixStreamData(data);
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, line);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Fix execution error:', error);
                if (error.name === 'AbortError') {
                    showMainFixStatus('Paused and requested termination of Codex processes', 'info');
                } else {
                    showMainFixStatus(`Execution error: ${error.message}`, 'error');
                }
            } finally {
                // Hide stop button regardless of result
                document.getElementById('main-fix-controls').style.display = 'none';
                fixAbortController = null;
            }
        }

        function handleMainFixStreamData(data) {
            const outputContent = document.getElementById('main-fix-content');

            switch (data.type) {
                case 'info':
                    showMainFixStatus(data.message, 'info');
                    // Mirror status in log area to avoid missing the top bar
                    outputContent.innerHTML += `<span style="color:#0d6efd;">[INFO]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;

                    // Update per-rule fix status
                    updateRuleStatus(data.message);
                    break;
                case 'output':
                    // Format output; handle timestamp line breaks
                    const formattedOutput = formatCodexOutput(data.message);
                    if (formattedOutput) {
                        outputContent.innerHTML += formattedOutput;
                        outputContent.scrollTop = outputContent.scrollHeight;
                    }
                    break;
                case 'error':
                    outputContent.innerHTML += `<span style="color: #dc3545; font-weight: bold;">[ERROR] ${data.message}</span>\n`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    showMainFixStatus('An error occurred during execution', 'error');
                    break;
                case 'url':
                    // Show verification URL
                    document.getElementById('main-verification-link').href = data.message;
                    document.getElementById('main-verification-link').textContent = data.message;
                    document.getElementById('main-verification-url').style.display = 'block';
                    break;
                case 'success':
                    showMainFixStatus(data.message, 'success');
                    outputContent.innerHTML += `<span style="color:#20c997;">[SUCCESS]</span> ${escapeHtml(data.message)}<br>`;
                    outputContent.scrollTop = outputContent.scrollHeight;
                    break;
                case 'complete':
                    showMainFixStatus('Fix execution finished', 'success');
                    // Natural completion; hide stop button
                    document.getElementById('main-fix-controls').style.display = 'none';
                    break;
            }
        }

        // Update per-rule fix status from server logs
        function updateRuleStatus(message) {
            if (!window.ruleFixStatus) return;

            // More flexible pattern matching with case-insensitive and partial matching
            const msg = message.toLowerCase().trim();

            // Detect start patterns - more flexible matching
            const startPatterns = [
                /start(?:ing)?\s+(?:fix\s+)?(\d+)\/(\d+)[\s:]*(.+)/i,
                /➡️\s*start\s+(\d+)\/(\d+)[\s:]*(.+)/i,
                /🔧\s*(?:invoking codex|fix)\s*(?:item\s*)?(\d+)/i,
                /begin(?:ning)?\s+(?:item\s*)?(\d+)/i
            ];

            for (const pattern of startPatterns) {
                const match = message.match(pattern);
                if (match) {
                    const index = parseInt(match[1]) - 1;
                    if (window.ruleFixStatus[index]) {
                        window.ruleFixStatus[index].status = 'In progress';
                        updateStatusDisplay();
                        return;
                    }
                }
            }

            // Detect completion patterns - more flexible matching  
            const completePatterns = [
                /(?:completed|done|finished|success)\s+(\d+)\/(\d+)/i,
                /✅.*(?:fix\s+)?(\d+).*completed/i,
                /📋\s*result\s+(\d+):\s*success/i,
                /===== \[done\s+(\d+)\/(\d+)\]\s*success/i
            ];

            for (const pattern of completePatterns) {
                const match = message.match(pattern);
                if (match) {
                    const index = parseInt(match[1]) - 1;
                    if (window.ruleFixStatus[index]) {
                        window.ruleFixStatus[index].status = 'Completed';
                        updateStatusDisplay();
                        return;
                    }
                }
            }

            // Detect failure patterns
            const failurePatterns = [
                /(?:failed|failure|error).*(?:item\s*)?(\d+)/i,
                /❌.*(?:fix\s+)?(\d+)/i,
                /📋\s*result\s+(\d+):\s*failure/i,
                /===== \[done\s+(\d+)\/(\d+)\]\s*failure/i
            ];

            for (const pattern of failurePatterns) {
                const match = message.match(pattern);
                if (match) {
                    const index = parseInt(match[1]) - 1;
                    if (window.ruleFixStatus[index]) {
                        window.ruleFixStatus[index].status = 'Failed';
                        updateStatusDisplay();
                        return;
                    }
                }
            }
        }

        // Update status display with better visual feedback and real-time updates
        function updateStatusDisplay() {
            if (!window.ruleFixStatus) return;

            const statusHtml = window.ruleFixStatus.map(item => {
                let statusColor = '#6c757d'; // default gray (pending)
                let statusIcon = '⏳'; // waiting icon
                let statusBg = 'transparent';

                if (item.status === 'In progress') {
                    statusColor = '#ffc107'; // yellow
                    statusIcon = '⚙️'; // gear icon
                    statusBg = '#fff3cd'; // light yellow background
                } else if (item.status === 'Completed') {
                    statusColor = '#28a745'; // green
                    statusIcon = '✅'; // checkmark icon
                    statusBg = '#d4edda'; // light green background
                } else if (item.status === 'Failed') {
                    statusColor = '#dc3545'; // red
                    statusIcon = '❌'; // X icon
                    statusBg = '#f8d7da'; // light red background
                }

                return `<div style="margin: 8px 0; padding: 8px 12px; border-radius: 8px; background: ${statusBg}; border-left: 4px solid ${statusColor}; transition: all 0.3s ease;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 1.4em; min-width: 24px;">${statusIcon}</span>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: ${statusColor};">${item.index}. ${escapeHtml(item.ruleName)}</div>
                            <div style="font-size: 0.9em; color: ${statusColor}; margin-top: 2px;">[${item.status}]</div>
                        </div>
                        ${item.status === 'In progress' ? '<div class="loading-spinner" style="width: 16px; height: 16px;"></div>' : ''}
                    </div>
                </div>`;
            }).join('');

            const progressSummary = window.ruleFixStatus.reduce((acc, item) => {
                acc[item.status] = (acc[item.status] || 0) + 1;
                return acc;
            }, {});

            const totalItems = window.ruleFixStatus.length;
            const completedItems = progressSummary['Completed'] || 0;
            const inProgressItems = progressSummary['In progress'] || 0;
            const failedItems = progressSummary['Failed'] || 0;
            const pendingItems = progressSummary['Pending'] || 0;

            const summaryHtml = `
                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px; border: 1px solid #dee2e6;">
                    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                        <span style="color: #28a745;">✅ Completed: <strong>${completedItems}</strong></span>
                        <span style="color: #ffc107;">⚙️ In Progress: <strong>${inProgressItems}</strong></span>
                        <span style="color: #dc3545;">❌ Failed: <strong>${failedItems}</strong></span>
                        <span style="color: #6c757d;">⏳ Pending: <strong>${pendingItems}</strong></span>
                    </div>
                    <div style="margin-top: 8px;">
                        <div style="background: #e9ecef; height: 8px; border-radius: 4px; overflow: hidden;">
                            <div style="background: linear-gradient(90deg, #28a745 0%, #20c997 100%); height: 100%; width: ${(completedItems / totalItems) * 100}%; transition: width 0.5s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 4px; font-size: 0.9em; color: #6c757d;">
                            ${completedItems} / ${totalItems} tasks completed (${Math.round((completedItems / totalItems) * 100)}%)
                        </div>
                    </div>
                </div>
            `;

            showStatus(`${summaryHtml}${statusHtml}`, 'info');
        }

        // Simple escape to prevent HTML from breaking output
        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatCodexOutput(output) {
            // Format Codex output and handle timestamps/others
            let formatted = output;

            // Format timestamps like [YYYY-MM-DDTHH:MM:SS.xxxZ]
            formatted = formatted.replace(/(\[\d{4}-\d{2}-\d{2}T[\d:.Z]+\])/g, '\n<span style="color: #667eea; font-weight: bold;">$1</span>');

            // Highlight common log tags
            formatted = formatted.replace(/\[INFO\]/g, '<span style="color: #28a745;">[INFO]</span>');
            formatted = formatted.replace(/\[ERROR\]/g, '<span style="color: #dc3545;">[ERROR]</span>');
            formatted = formatted.replace(/\[WARNING\]/g, '<span style="color: #ffc107;">[WARNING]</span>');
            formatted = formatted.replace(/\[SUCCESS\]/g, '<span style="color: #20c997;">[SUCCESS]</span>');

            // Style exec/bash/codex markers
            formatted = formatted.replace(/(\] (exec|bash|codex|thinking)\b)/gi, '<span style="color: #6c757d; font-style: italic;">$1</span>');

            // Emphasize special symbols
            formatted = formatted.replace(/(➡️|✅|❌|⚠️)/g, '<span style="font-size: 1.2em;">$1</span>');

            // Emphasize rule/step info (English)
            formatted = formatted.replace(/(Item\s*\d+\/\d+|Step\s*\d+\/\d+)/g, '<span style="color: #764ba2; font-weight: bold;">$1</span>');
            formatted = formatted.replace(/(Rule:\s*[^\n]+)/g, '<span style="color: #667eea; font-weight: bold;">$1</span>');

            // Convert newlines to HTML breaks
            formatted = formatted.replace(/\n/g, '<br>');

            return formatted;
        }

        function showMainFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('main-fix-status');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // Stop sequential fix: abort SSE and request backend to terminate Codex
        async function stopFix() {
            try {
                // Abort client-server connection first to trigger server-side SIGTERM
                if (fixAbortController) {
                    fixAbortController.abort();
                }

                showMainFixStatus('Terminating Codex processes...', 'info');

                // Then call unified backend kill to ensure all codex processes are closed
                await fetch('http://localhost:3002/kill-processes', { method: 'POST' }).catch(() => { });
                showMainFixStatus('Kill request sent to Codex processes', 'success');
            } catch (e) {
                showMainFixStatus(`Error terminating processes: ${e.message}`, 'error');
            } finally {
                // Hide button to avoid repeated clicks
                document.getElementById('main-fix-controls').style.display = 'none';
            }
        }

        function showFixStatus(message, type = 'info') {
            const statusDiv = document.getElementById('fix-status');
            statusDiv.className = `fix-status ${type}`;
            statusDiv.textContent = message;
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = `status-message status-${type}`;
            // Allow HTML for line breaks and styled status list
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
        }

        // convertToMarkdown function (rewritten based on reference project)
        function convertToMarkdown(rule) {
            const traceData = rule.content;
            const simplifiedRuleName = rule.ruleName.split('↳')[0].trim();
            let md = `# Certora Trace Analysis\n\n`;
            md += `**Rule:** ${simplifiedRuleName}\n`;
            md += `**Status:** ${rule.status}\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## 🌳 Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second) - from variables array
            md += `\n## 📊 Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                md += renderVariablesFromArray(traceData.variables);
            } else {
                md += `No variable data\n\n`;
            }

            // 3. Global State Diff (third) - compute from Call Trace Global State nodes
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## 🔄 Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                md += `## 🚨 Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            }

            return md;
        }

        // Call Trace conversion - reference implementation
        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    let value = '?';

                    if (arg.value !== undefined) {
                        value = arg.value;
                        // If multiple representations exist, prefer the more readable one
                        if (arg.values && arg.values.length > 1) {
                            const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                            if (decValue && parseInt(decValue) < 1000000) {
                                value = `${arg.value} (${decValue})`;
                            }
                        }
                    } else if (arg.values && Array.isArray(arg.values) && arg.values.length > 0) {
                        value = arg.values[0];
                    }

                    messageText = messageText.replace(placeholder, value);
                });
            }

            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // Compute Global State differences - reference implementation  
        function calculateGlobalStateDiff(callTrace) {
            const globalStateNodes = [];

            // Collect all Global State nodes
            collectGlobalStateNodes(callTrace, globalStateNodes);

            if (globalStateNodes.length === 0) {
                return {};
            }

            // Extract first and last Global State states
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);

            // Compute differences
            const diff = {};

            // Collect all state keys
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);

            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];

                // Record only if value changes
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                } else if (firstValue && lastValue) {
                    // Value unchanged but present in both states
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                }
            });

            return diff;
        }

        // Recursively collect all Global State nodes
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node && node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }

            if (node && node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // Extract state info from Global State node
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};

            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }

            return state;
        }

        // Recursively extract state info
        function extractStateRecursively(node, state) {
            // If node has arguments, this indicates a state record
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // Replace placeholders to get the full state path
                let fullPath = node.message.text;
                let stateValue = null;

                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // Prefer the most readable value
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // Prefer decimal representation if available
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);

                            // The last argument is usually the value
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });

                // Parse path and value
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }

            // Recursively process child nodes
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // Parse state path
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }

            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();

            // Prefer value extracted from arguments when present
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }

            // Trim quotes
            value = value.replace(/^['"]|['"]$/g, '');

            return { path, value };
        }

        // Render Global State diff
        function renderGlobalStateDiff(diff) {
            let md = '';

            // Group by path type
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] },
                'other': { title: 'Other Changes', items: [] }
            };

            Object.entries(diff).forEach(([path, change]) => {
                const item = { path, change };

                if (path.includes('storage') || path.includes('balanceOf') || path.includes('_storage')) {
                    groups.storage.items.push(item);
                } else if (path.includes('balance') || path.includes('Balance')) {
                    groups.balance.items.push(item);
                } else if (path.includes('ghost') || path.includes('Ghost')) {
                    groups.ghost.items.push(item);
                } else {
                    groups.other.items.push(item);
                }
            });

            // Render each group
            Object.values(groups).forEach(group => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    group.items.forEach(item => {
                        const { path, change } = item;
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` → \`${change.to}\` ✨\n`;
                        } else {
                            md += `- **${path}**: \`${change.from}\` (unchanged)\n`;
                        }
                    });
                    md += `\n`;
                }
            });

            return md;
        }

        // Render hierarchy from variables array - reference implementation
        function renderVariablesFromArray(variables) {
            let md = '';

            variables.forEach((variable, index) => {
                // Only process objects with variableName field
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // Handle variables with childrenList
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                    } else {
                        // Simple variable: output name and value
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `**${name}**: \`${value}\`\n\n`;
                    }
                }
            });

            return md;
        }

        // Handle nested variables - reference implementation
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];

            // If there are child variables, recurse
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // Ensure child is a valid object with variableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // Leaf node: output full path and value
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `**${fullPath}**: \`${value}\`\n\n`;
            }

            return md;
        }

        // Startup tip
        window.addEventListener('DOMContentLoaded', () => {
            showStatus('Please run server first: cd /Users/pixelpanda/certora-scraper && node scripts/certora_auto_server.mjs', 'info');
        });

        // Close modal by clicking outside
        // Copy helpers
        function showCopyNotification(message) {
            // Remove existing notification
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Create new notification
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // Hide after 2 seconds
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                // Fallback method
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (err) {
                    document.body.removeChild(textArea);
                    return false;
                }
            }
        }

        function copyMarkdown(index) {
            const rule = processedRules[index];
            if (rule && rule.markdown) {
                copyToClipboard(rule.markdown).then(success => {
                    if (success) {
                        showCopyNotification('✅ Markdown copied to clipboard');
                    } else {
                        showCopyNotification('❌ Copy failed');
                    }
                });
            } else {
                showCopyNotification('❌ No Markdown content to copy');
            }
        }

        function copyCodexAnalysis(outputFile) {
            const textarea = document.getElementById(`analysis-${outputFile}`);
            if (textarea && textarea.value && textarea.value.trim() !== '' && !textarea.value.includes('Analyzing...')) {
                copyToClipboard(textarea.value).then(success => {
                    if (success) {
                        showCopyNotification('✅ Codex analysis copied to clipboard');
                    } else {
                        showCopyNotification('❌ Copy failed');
                    }
                });
            } else {
                showCopyNotification('❌ No analysis content to copy');
            }
        }

        window.onclick = function (event) {
            const modal1 = document.getElementById('markdown-modal');
            const modal2 = document.getElementById('codex-modal');
            const modal3 = document.getElementById('fix-prompt-modal');
            if (event.target == modal1) {
                modal1.style.display = 'none';
            }
            if (event.target == modal2) {
                modal2.style.display = 'none';
            }
            if (event.target == modal3) {
                closeFixPromptModal();
            }
        }
    </script>
</body>

</html>