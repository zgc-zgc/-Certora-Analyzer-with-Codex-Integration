<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certora Analyzer with Codex</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .url-input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            transition: border-color 0.3s;
            margin-bottom: 20px;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .status-success {
            background: #d1e7dd;
            color: #0f5132;
            border: 1px solid #badbcc;
        }

        .status-error {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .result-table tr:hover {
            background: #f8f9fa;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-violated {
            background: #dc3545;
            color: white;
        }

        .status-sanity-failed {
            background: #fd7e14;
            color: white;
        }

        .status-timeout {
            background: #6c757d;
            color: white;
        }

        .codex-analysis {
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            overflow-y: auto;
        }

        .codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .codex-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .codex-content {
            background: #f8f9fa;
            color: #212529;
            padding: 20px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .action-buttons {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .prover-url {
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border-radius: 10px;
            display: none;
        }

        .prover-url a {
            color: #155724;
            font-weight: 600;
        }

        .markdown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .markdown-modal-content {
            position: relative;
            background: white;
            margin: 50px auto;
            padding: 20px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-modal:hover {
            color: #333;
        }

        .markdown-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
        }

        .copy-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .copy-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.4);
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
        }

        .copy-btn:active {
            transform: translateY(0);
        }

        .view-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .view-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
        }

        .view-btn:active {
            transform: translateY(0);
        }

        .copy-btn-small {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(23, 162, 184, 0.9);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            backdrop-filter: blur(4px);
        }

        .copy-btn-small:hover {
            opacity: 1;
            transform: scale(1.05);
            background: rgba(19, 132, 150, 0.95);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Certora Analyzer with Codex Integration</h1>
            <p>è‡ªåŠ¨åˆ†æ CVL éªŒè¯å¤±è´¥æ¡ˆä¾‹å¹¶æä¾›ä¿®å¤å»ºè®®</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3 style="margin-bottom: 20px; color: #212529;">è¾“å…¥ Certora URL</h3>
                <input type="text" class="url-input" id="certora-url"
                    placeholder="https://prover.certora.com/output/..." value="">

                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeUrl()">
                    ğŸ” è·å–éªŒè¯æ•°æ®
                </button>

                <div id="status-message"></div>
            </div>

            <div id="action-buttons" class="action-buttons" style="display: none;">
                <button class="btn btn-success" id="batchAnalyzeBtn" onclick="toggleBatchAnalysis()">
                    ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™
                </button>
                <button class="btn btn-warning" onclick="fixAll()">
                    ğŸ”§ æ‰§è¡Œæ‰¹é‡ä¿®å¤
                </button>
            </div>

            <div id="result-section" style="display: none;">
                <table class="result-table" id="result-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">è§„åˆ™å</th>
                            <th style="width: 10%;">çŠ¶æ€</th>
                            <th style="width: 10%;">Markdown</th>
                            <th style="width: 40%;">Codexåˆ†æç»“æœ</th>
                            <th style="width: 15%;">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="result-tbody">
                    </tbody>
                </table>
            </div>

            <div id="prover-url" class="prover-url">
                éªŒè¯å®Œæˆï¼æŸ¥çœ‹ç»“æœï¼š<a href="#" target="_blank" id="prover-link"></a>
            </div>
        </div>
    </div>

    <!-- Markdown Modal -->
    <div id="markdown-modal" class="markdown-modal">
        <div class="markdown-modal-content">
            <span class="close-modal" onclick="closeMarkdownModal()">&times;</span>
            <h3 id="modal-title" style="margin-bottom: 20px;">Markdown å†…å®¹</h3>
            <div id="modal-content" class="markdown-content"></div>
        </div>
    </div>

    <!-- Codex Analysis Modal -->
    <div id="codex-modal" class="codex-modal">
        <div class="codex-modal-content">
            <span class="close-modal" onclick="closeCodexModal()">&times;</span>
            <h3 id="codex-modal-title" style="margin-bottom: 20px;">Codex åˆ†æè¯¦æƒ…</h3>
            <div id="codex-modal-content" class="codex-content"></div>
        </div>
    </div>

    <script>
        let allRulesData = null;
        let jsonContents = {};
        let processedRules = [];
        let sanityAggregated = null;
        let stopAnalysisFlag = false;
        const analysisControllers = new Map(); // ä¸ºæ¯ä¸ªåˆ†æç»´æŠ¤ç‹¬ç«‹çš„æ§åˆ¶å™¨

        // å¤„ç† Codex è¾“å‡ºï¼Œåªä¿ç•™æœ€ç»ˆå›ç­”
        function extractCodexAnswer(fullOutput) {
            // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ—¶é—´æˆ³æ ‡è®°å’Œ "tokens used:" ä¹‹é—´çš„å†…å®¹
            const lines = fullOutput.split('\n');
            let lastTimeIndex = -1;
            let tokensUsedIndex = -1;

            // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ—¶é—´æˆ³æ ‡è®°ï¼Œæ ¼å¼å¦‚ [2025-01-01T10:30:00]
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                }
                if (tokensUsedIndex > -1 && lines[i].match(/^\[[\d\-T:\.Z]+\]/)) {
                    lastTimeIndex = i;
                    break;
                }
            }

            if (lastTimeIndex >= 0 && tokensUsedIndex > lastTimeIndex) {
                // æå–æœ€åä¸€ä¸ªæ—¶é—´æˆ³ååˆ° tokens used ä¹‹å‰çš„å†…å®¹
                const answerLines = lines.slice(lastTimeIndex + 1, tokensUsedIndex);
                let answer = answerLines.join('\n').trim();

                // ç§»é™¤å¯èƒ½çš„é¢å¤–æ ‡è®°
                answer = answer.replace(/^(Assistant|AI|Codex):\s*/gm, '');
                answer = answer.replace(/^\s*[-â€¢]\s*/gm, '');

                return answer || fullOutput;
            }

            // å¦‚æœæ²¡æ‰¾åˆ°æ—¶é—´æˆ³ï¼Œå°è¯•æŸ¥æ‰¾ "codex" æ ‡è®°
            let lastCodexIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('] codex')) {
                    lastCodexIndex = i;
                }
                if (lines[i].includes('tokens used:')) {
                    tokensUsedIndex = i;
                    break;
                }
            }

            if (lastCodexIndex >= 0 && tokensUsedIndex > lastCodexIndex) {
                const answerLines = lines.slice(lastCodexIndex + 1, tokensUsedIndex);
                return answerLines.join('\n').trim();
            }

            // å¦‚æœéƒ½æ²¡æ‰¾åˆ°ï¼Œè¿”å›åŸå†…å®¹
            return fullOutput;
        }

        async function analyzeUrl() {
            const url = document.getElementById('certora-url').value.trim();
            if (!url) {
                showStatus('è¯·è¾“å…¥URL', 'error');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = 'â³ è·å–ä¸­...';

            showStatus('æ­£åœ¨è·å–éªŒè¯æ•°æ®...', 'info');

            try {
                // è°ƒç”¨æœ¬åœ°æœåŠ¡
                const response = await fetch('http://localhost:3002/analyze-and-fetch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `æœåŠ¡å™¨é”™è¯¯: ${response.status}`);
                }

                const data = await response.json();
                allRulesData = data;

                // ä¿å­˜æ‰€æœ‰JSONå†…å®¹
                data.rules.forEach(rule => {
                    if (rule.content) {
                        jsonContents[rule.outputFile] = rule.content;
                    }
                });

                processData(data);
                showStatus(`âœ… æˆåŠŸè·å– ${data.rules.length} ä¸ªè§„åˆ™çš„æ•°æ®`, 'success');

            } catch (error) {
                console.error('Error:', error);
                showStatus(`é”™è¯¯: ${error.message}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†: node scripts/certora_auto_server.mjs`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ğŸ” è·å–éªŒè¯æ•°æ®';
            }
        }

        function processData(data) {
            processedRules = [];

            // å¤„ç† VIOLATED è§„åˆ™
            data.rules.filter(r => r.status === 'VIOLATED').forEach(rule => {
                const markdown = rule.content ? convertToMarkdown(rule) : '';
                processedRules.push({
                    ...rule,
                    type: 'VIOLATED',
                    markdown: markdown,
                    displayName: rule.ruleName
                });
            });

            // æ•´åˆ SANITY_FAILED è§„åˆ™
            const sanityFailed = data.rules.filter(r => r.status === 'SANITY_FAILED');
            if (sanityFailed.length > 0) {
                sanityAggregated = aggregateSanityFailures(sanityFailed);
                processedRules.push({
                    ruleName: 'æ±‡æ€»: Sanity Failed è§„åˆ™',
                    status: 'SANITY_FAILED',
                    type: 'SANITY_FAILED',
                    markdown: sanityAggregated,
                    displayName: 'æ±‡æ€»: Sanity Failed è§„åˆ™',
                    outputFile: 'sanity_aggregated'
                });
            }

            displayResults();
            document.getElementById('action-buttons').style.display = 'flex';
        }

        function aggregateSanityFailures(rules) {
            const sanityMap = new Map();

            rules.forEach(rule => {
                const parts = rule.ruleName.split(' > ');
                const baseRule = parts[0];
                const funcName = parts[parts.length - 1];

                if (!sanityMap.has(baseRule)) {
                    sanityMap.set(baseRule, new Set());
                }
                sanityMap.get(baseRule).add(funcName);
            });

            return Array.from(sanityMap.entries()).map(([rule, funcs]) =>
                `è§„åˆ™ ${rule} åœ¨ä»¥ä¸‹å‡½æ•°ä¸­ sanity failed:\n${Array.from(funcs).map(f => `- ${f}`).join('\n')}`
            ).join('\n\n');
        }

        function displayResults() {
            const tbody = document.getElementById('result-tbody');
            tbody.innerHTML = '';

            processedRules.forEach((rule, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${formatRuleName(rule.displayName)}</td>
                    <td><span class="status-badge status-${rule.status.toLowerCase().replace('_', '-')}">${rule.status}</span></td>
                    <td>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button class="view-btn" onclick="viewMarkdown(${index})">
                                ğŸ“„ æŸ¥çœ‹
                            </button>
                            <button class="copy-btn" onclick="copyMarkdown(${index})">
                                ğŸ“‹ å¤åˆ¶MD
                            </button>
                        </div>
                    </td>
                    <td>
                        <div style="position: relative;">
                            <textarea class="codex-analysis" 
                                      id="analysis-${rule.outputFile}" 
                                      placeholder="ç‚¹å‡»åˆ†ææŒ‰é’®è·å–Codexåˆ†æç»“æœ..."
                                      onclick="expandCodexAnalysis('${rule.outputFile}')"
                                      readonly></textarea>
                            <button class="copy-btn-small" 
                                    onclick="copyCodexAnalysis('${rule.outputFile}')">
                                ğŸ“‹ å¤åˆ¶
                            </button>
                        </div>
                    </td>
                    <td>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn btn-primary" id="analyze-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px;" 
                                    onclick="analyzeRule(${index})">åˆ†æ</button>
                            <button class="btn btn-danger" id="stop-btn-${rule.outputFile}" 
                                    style="padding: 6px 12px; font-size: 14px; display: none;" 
                                    onclick="stopSingleAnalysis('${rule.outputFile}')">åœæ­¢</button>
                        </div>
                    </td>
                `;
                tbody.appendChild(row);
            });

            document.getElementById('result-section').style.display = 'block';
        }

        function expandCodexAnalysis(outputFile) {
            const textarea = document.getElementById(`analysis-${outputFile}`);
            if (textarea.value && textarea.value !== '' && !textarea.value.includes('åˆ†æä¸­...')) {
                document.getElementById('codex-modal-title').textContent = 'Codex åˆ†æè¯¦æƒ…';
                document.getElementById('codex-modal-content').textContent = textarea.value;
                document.getElementById('codex-modal').style.display = 'block';
            }
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        function formatRuleName(name) {
            const parts = name.split(' > ');
            if (parts.length === 1) {
                return name;
            }
            return `${parts[0]} > ... > ${parts[parts.length - 1]}`;
        }

        function viewMarkdown(index) {
            const rule = processedRules[index];
            document.getElementById('modal-title').textContent = `Markdown - ${rule.displayName}`;
            document.getElementById('modal-content').textContent = rule.markdown;
            document.getElementById('markdown-modal').style.display = 'block';
        }

        function closeMarkdownModal() {
            document.getElementById('markdown-modal').style.display = 'none';
        }

        async function analyzeRule(index, isBatchAnalysis = false, retryCount = 0) {
            const maxRetries = 3;
            
            // åªæœ‰åœ¨æ‰¹é‡åˆ†ææ—¶æ‰æ£€æŸ¥ stopAnalysisFlag
            if (isBatchAnalysis && stopAnalysisFlag) {
                console.log('æ‰¹é‡åˆ†æè¢«åœæ­¢æ ‡å¿—é˜»æ­¢');
                return;
            }

            const rule = processedRules[index];
            if (!rule) {
                console.error(`è§„åˆ™ç´¢å¼• ${index} ä¸å­˜åœ¨`);
                return;
            }

            const outputFile = rule.outputFile;

            console.log(`å¼€å§‹åˆ†æè§„åˆ™: ${outputFile}, æ‰¹é‡åˆ†æ: ${isBatchAnalysis}, é‡è¯•æ¬¡æ•°: ${retryCount}`);
            console.log(`è§„åˆ™ç±»å‹: ${rule.type}, Markdowné•¿åº¦: ${rule.markdown ? rule.markdown.length : 0}`);

            const textarea = document.getElementById(`analysis-${outputFile}`);
            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);

            if (!textarea || !analyzeBtn) {
                console.error(`æ‰¾ä¸åˆ°UIå…ƒç´ : textarea=${!!textarea}, analyzeBtn=${!!analyzeBtn}`);
                return;
            }

            // å¦‚æœè¿™ä¸ªè§„åˆ™å·²ç»åœ¨åˆ†æä¸­ï¼Œä¸é‡å¤åˆ†æ
            if (analysisControllers.has(outputFile)) {
                console.log(`è§„åˆ™ ${outputFile} å·²åœ¨åˆ†æä¸­ï¼Œè·³è¿‡`);
                return;
            }

            // æ˜¾ç¤ºåœæ­¢æŒ‰é’®ï¼Œéšè—åˆ†ææŒ‰é’®
            if (analyzeBtn) analyzeBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'inline-block';

            if (retryCount > 0) {
                textarea.value = `é‡è¯•ä¸­... (${retryCount}/${maxRetries})`;
            } else {
                textarea.value = 'åˆ†æä¸­...';
            }
            textarea.disabled = true;

            // ä¸ºè¿™ä¸ªç‰¹å®šçš„åˆ†æåˆ›å»º AbortController
            const controller = new AbortController();
            analysisControllers.set(outputFile, controller);

            console.log(`åˆ›å»ºäº†æ§åˆ¶å™¨ï¼Œå½“å‰æ§åˆ¶å™¨æ•°é‡: ${analysisControllers.size}`);

            // æ£€æŸ¥æ§åˆ¶å™¨æ˜¯å¦ç«‹å³è¢«ä¸­æ­¢
            if (controller.signal.aborted) {
                console.error('æ§åˆ¶å™¨åˆ›å»ºåç«‹å³è¢«ä¸­æ­¢ï¼');
                analysisControllers.delete(outputFile);
                textarea.value = 'åˆ†æå¤±è´¥ï¼šæ§åˆ¶å™¨è¢«ä¸­æ­¢';
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                return;
            }

            try {
                console.log(`å‘é€åˆ†æè¯·æ±‚: ${rule.type}, Markdownå‰100å­—ç¬¦: ${rule.markdown ? rule.markdown.substring(0, 100) : 'null'}`);

                // ç¡®ä¿ markdown å­˜åœ¨
                if (!rule.markdown) {
                    throw new Error('Markdownå†…å®¹ä¸ºç©º');
                }

                const requestBody = {
                    content: rule.markdown,
                    type: rule.type
                };

                console.log(`è¯·æ±‚ä½“å¤§å°: ${JSON.stringify(requestBody).length} å­—èŠ‚`);

                const response = await fetch('http://localhost:3002/analyze-rule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                console.log(`æ”¶åˆ°å“åº”: ${response.status}`);

                // æ£€æŸ¥å“åº”æ˜¯å¦æ­£å¸¸
                if (!response.ok) {
                    if (response.status === 500 && retryCount < maxRetries) {
                        // HTTP 500 é”™è¯¯ï¼Œè¿›è¡Œé‡è¯•
                        console.log(`HTTP 500é”™è¯¯ï¼Œå°†åœ¨2ç§’åé‡è¯• (${retryCount + 1}/${maxRetries})`);
                        analysisControllers.delete(outputFile);
                        
                        // ç­‰å¾…2ç§’åé‡è¯•
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                if (result.success) {
                    // æå–å¹¶æ˜¾ç¤ºç®€åŒ–çš„å›ç­”
                    const simplifiedAnswer = extractCodexAnswer(result.analysis);
                    textarea.value = simplifiedAnswer;
                    // ç§»é™¤ readonlyï¼Œä½¿å…¶å¯ç¼–è¾‘
                    textarea.readOnly = false;
                    console.log(`åˆ†ææˆåŠŸ: ${outputFile}`);
                } else {
                    if (retryCount < maxRetries) {
                        console.log(`åˆ†æå¤±è´¥ï¼Œå°†é‡è¯•: ${result.error}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = `åˆ†æå¤±è´¥: ${result.error}`;
                    console.log(`åˆ†æå¤±è´¥: ${outputFile}, é”™è¯¯: ${result.error}`);
                }
            } catch (error) {
                console.error(`åˆ†æå‡ºé”™: ${outputFile}`, error);
                console.error('é”™è¯¯è¯¦æƒ…:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });

                if (error.name === 'AbortError') {
                    console.log('è¯·æ±‚è¢«ä¸­æ­¢ï¼Œæ§åˆ¶å™¨çŠ¶æ€:', controller.signal.aborted);
                    textarea.value = 'åˆ†æå·²å–æ¶ˆ';
                } else if (error.message.includes('Failed to fetch')) {
                    if (retryCount < maxRetries) {
                        console.log(`ç½‘ç»œé”™è¯¯ï¼Œå°†é‡è¯•: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·ç¡®ä¿æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ';
                } else if (error.message === 'Markdownå†…å®¹ä¸ºç©º') {
                    textarea.value = 'é”™è¯¯ï¼šæ²¡æœ‰å¯åˆ†æçš„å†…å®¹';
                } else {
                    if (retryCount < maxRetries && !error.name === 'AbortError') {
                        console.log(`é€šç”¨é”™è¯¯ï¼Œå°†é‡è¯•: ${error.message}`);
                        analysisControllers.delete(outputFile);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        return await analyzeRule(index, isBatchAnalysis, retryCount + 1);
                    }
                    textarea.value = `é”™è¯¯: ${error.message}`;
                }
            } finally {
                textarea.disabled = false;
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                // æ¸…ç†æ§åˆ¶å™¨
                analysisControllers.delete(outputFile);
                console.log(`æ¸…ç†æ§åˆ¶å™¨ï¼Œå‰©ä½™æ§åˆ¶å™¨æ•°é‡: ${analysisControllers.size}`);
            }
        }

        function stopSingleAnalysis(outputFile) {
            const controller = analysisControllers.get(outputFile);
            if (controller) {
                controller.abort();
                analysisControllers.delete(outputFile);
            }

            const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
            const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
            const textarea = document.getElementById(`analysis-${outputFile}`);

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (textarea) {
                textarea.value = 'åˆ†æå·²åœæ­¢';
                textarea.disabled = false;
            }
        }

        let isBatchAnalyzing = false;

        async function toggleBatchAnalysis() {
            if (isBatchAnalyzing) {
                // å½“å‰æ­£åœ¨åˆ†æï¼Œæ‰§è¡Œåœæ­¢æ“ä½œ
                stopAnalysis();
            } else {
                // å½“å‰æœªåœ¨åˆ†æï¼Œå¼€å§‹æ‰¹é‡åˆ†æ
                await analyzeAllRules();
            }
        }

        async function analyzeAllRules() {
            isBatchAnalyzing = true;
            stopAnalysisFlag = false;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            batchBtn.className = 'btn btn-danger';
            batchBtn.innerHTML = 'â¹ï¸ åœæ­¢åˆ†æ';
            
            showStatus('å¼€å§‹æ‰¹é‡åˆ†æ...', 'info');

            // å¹¶å‘æ‰§è¡Œæ‰€æœ‰åˆ†æä»»åŠ¡
            const analysisPromises = [];
            for (let i = 0; i < processedRules.length; i++) {
                if (stopAnalysisFlag) {
                    break;
                }
                // ä¸ç­‰å¾…æ¯ä¸ªåˆ†æå®Œæˆï¼Œç›´æ¥æ¨å…¥Promiseæ•°ç»„
                analysisPromises.push(analyzeRule(i, true));
            }

            try {
                // ç­‰å¾…æ‰€æœ‰åˆ†æä»»åŠ¡å®Œæˆ
                await Promise.allSettled(analysisPromises);
            } catch (error) {
                console.error('æ‰¹é‡åˆ†æè¿‡ç¨‹ä¸­å‡ºé”™:', error);
            }

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            isBatchAnalyzing = false;
            batchBtn.className = 'btn btn-success';
            batchBtn.innerHTML = 'ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™';
            
            if (!stopAnalysisFlag) {
                showStatus('âœ… æ‰€æœ‰è§„åˆ™åˆ†æå®Œæˆ', 'success');
            } else {
                showStatus('æ‰¹é‡åˆ†æå·²åœæ­¢', 'info');
            }
        }

        function stopAnalysis() {
            stopAnalysisFlag = true;
            isBatchAnalyzing = false;
            
            // æ¢å¤æ‰¹é‡åˆ†ææŒ‰é’®çŠ¶æ€
            const batchBtn = document.getElementById('batchAnalyzeBtn');
            if (batchBtn) {
                batchBtn.className = 'btn btn-success';
                batchBtn.innerHTML = 'ğŸ¤– Codex åˆ†ææ‰€æœ‰è§„åˆ™';
            }
            
            // åœæ­¢æ‰€æœ‰æ­£åœ¨è¿›è¡Œçš„åˆ†æ
            analysisControllers.forEach((controller, outputFile) => {
                controller.abort();
                // æ›´æ–°å¯¹åº”çš„UI
                const analyzeBtn = document.getElementById(`analyze-btn-${outputFile}`);
                const stopBtn = document.getElementById(`stop-btn-${outputFile}`);
                const textarea = document.getElementById(`analysis-${outputFile}`);

                if (analyzeBtn) analyzeBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                if (textarea && textarea.value === 'åˆ†æä¸­...') {
                    textarea.value = 'æ‰¹é‡åˆ†æå·²åœæ­¢';
                    textarea.disabled = false;
                }
            });
            analysisControllers.clear();

            showStatus('æ‰¹é‡åˆ†æå·²åœæ­¢', 'info');
        }

        async function fixAll() {
            const analyses = [];

            document.querySelectorAll('.codex-analysis').forEach(textarea => {
                if (textarea.value && textarea.value !== '' && !textarea.value.includes('åˆ†æä¸­...')) {
                    analyses.push(textarea.value);
                }
            });

            if (analyses.length === 0) {
                showStatus('æ²¡æœ‰å¯ç”¨çš„åˆ†æç»“æœ', 'error');
                return;
            }

            showStatus(`æ­£åœ¨æ‰§è¡Œä¿®å¤ï¼ˆå…± ${analyses.length} ä¸ªä»»åŠ¡ï¼‰...`, 'info');

            try {
                const response = await fetch('http://localhost:3002/fix-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ analyses })
                });

                const result = await response.json();
                if (result.success) {
                    if (result.url) {
                        document.getElementById('prover-link').href = result.url;
                        document.getElementById('prover-link').textContent = result.url;
                        document.getElementById('prover-url').style.display = 'block';
                        showStatus('âœ… ä¿®å¤å®Œæˆï¼ŒéªŒè¯å·²å¯åŠ¨', 'success');
                    } else {
                        showStatus(result.message || 'ä¿®å¤å®Œæˆ', 'success');
                    }
                } else {
                    showStatus(`ä¿®å¤å¤±è´¥: ${result.error}`, 'error');
                }
            } catch (error) {
                showStatus(`é”™è¯¯: ${error.message}`, 'error');
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = `status-message status-${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // æ ¹æ®å‚è€ƒé¡¹ç›®é‡å†™çš„convertToMarkdownå‡½æ•°
        function convertToMarkdown(rule) {
            const traceData = rule.content;
            const simplifiedRuleName = rule.ruleName.split('â†³')[0].trim();
            let md = `# Certora Trace Analysis\n\n`;
            md += `**Rule:** ${simplifiedRuleName}\n`;
            md += `**Status:** ${rule.status}\n`;
            md += `**File:** ${rule.outputFile}\n\n`;

            // 1. Call Trace (first position)
            if (traceData.callTrace) {
                md += `## ğŸŒ³ Call Trace\n\n`;
                let globalStateCounter = 1;
                md += convertTraceToMarkdown(traceData.callTrace, 0, { counter: globalStateCounter });
            }

            // 2. Variables (second position) - ç›´æ¥ä»variablesæ•°ç»„ä¸­æå–
            md += `\n## ğŸ“Š Variables\n\n`;
            if (traceData.variables && Array.isArray(traceData.variables) && traceData.variables.length > 0) {
                md += renderVariablesFromArray(traceData.variables);
            } else {
                md += `æš‚æ— å˜é‡æ•°æ®\n\n`;
            }

            // 3. Global State Diff (third position) - ä»Call Traceä¸­çš„Global StateèŠ‚ç‚¹è®¡ç®—å˜åŒ–
            const globalStateDiff = calculateGlobalStateDiff(traceData.callTrace);
            if (Object.keys(globalStateDiff).length > 0) {
                md += `## ğŸ”„ Global State Diff\n\n`;
                md += renderGlobalStateDiff(globalStateDiff);
            }

            // 4. Call Resolution Warnings (last position)
            if (traceData.callResolutionWarnings && traceData.callResolutionWarnings.length > 0) {
                md += `## ğŸš¨ Call Resolution Warnings\n\n`;
                traceData.callResolutionWarnings.forEach((warning, index) => {
                    md += `### Warning #${index + 1}\n\n`;
                    if (warning.caller) {
                        md += `**Caller**: ${warning.caller.name || 'Unknown'}\n`;
                    }
                    if (warning.callee) {
                        md += `**Callee**: ${warning.callee.name || 'Unknown'}\n`;
                    }
                    if (warning.summary) {
                        md += `**Summary**: ${warning.summary}\n`;
                    }
                    if (warning.callSite) {
                        md += `**Call Site**: ${warning.callSite.snippet || 'Unknown'}\n`;
                        if (warning.callSite.jumpToDefinition) {
                            md += `**Location**: ${warning.callSite.jumpToDefinition.file}:${warning.callSite.jumpToDefinition.start.line}\n`;
                        }
                    }
                    if (warning.comments && warning.comments.length > 0) {
                        md += `**Comments**:\n`;
                        warning.comments.forEach(comment => {
                            if (typeof comment === 'object') {
                                const key = Object.keys(comment)[0];
                                md += `- **${key}**: ${comment[key]}\n`;
                            } else {
                                md += `- ${comment}\n`;
                            }
                        });
                    }
                    md += `\n`;
                });
            }

            return md;
        }

        // Call Traceè½¬æ¢ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function convertTraceToMarkdown(node, level, context = { counter: 1 }) {
            const indent = '  '.repeat(level);
            let md = '';

            let messageText = node.message?.text || '';
            if (node.message?.arguments) {
                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    let value = '?';

                    if (arg.value !== undefined) {
                        value = arg.value;
                        // å¦‚æœæœ‰å¤šä¸ªå€¼è¡¨ç¤ºï¼Œä¼˜å…ˆæ˜¾ç¤ºå¯è¯»æ€§é«˜çš„
                        if (arg.values && arg.values.length > 1) {
                            const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                            if (decValue && parseInt(decValue) < 1000000) {
                                value = `${arg.value} (${decValue})`;
                            }
                        }
                    } else if (arg.values && Array.isArray(arg.values) && arg.values.length > 0) {
                        value = arg.values[0];
                    }

                    messageText = messageText.replace(placeholder, value);
                });
            }

            if (messageText === 'Global State') {
                messageText = `Global State #${context.counter}`;
                context.counter++;
            }

            const statusBadge = node.status && node.status.trim() ? ` **[${node.status}]**` : '';
            md += `${indent}- ${messageText}${statusBadge}\n`;

            if (node.childrenList && node.childrenList.length > 0) {
                node.childrenList.forEach(child => {
                    md += convertTraceToMarkdown(child, level + 1, context);
                });
            }

            return md;
        }

        // è®¡ç®—Global Stateå·®å¼‚ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬  
        function calculateGlobalStateDiff(callTrace) {
            const globalStateNodes = [];

            // æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
            collectGlobalStateNodes(callTrace, globalStateNodes);

            if (globalStateNodes.length === 0) {
                return {};
            }

            // æå–ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªGlobal Stateçš„çŠ¶æ€
            const firstState = extractStateFromGlobalNode(globalStateNodes[0]);
            const lastState = extractStateFromGlobalNode(globalStateNodes[globalStateNodes.length - 1]);

            // è®¡ç®—å·®å¼‚
            const diff = {};

            // æ”¶é›†æ‰€æœ‰çŠ¶æ€é”®
            const allKeys = new Set([...Object.keys(firstState), ...Object.keys(lastState)]);

            allKeys.forEach(key => {
                const firstValue = firstState[key];
                const lastValue = lastState[key];

                // åªæœ‰å½“å€¼ç¡®å®å‘ç”Ÿå˜åŒ–æ—¶æ‰è®°å½•
                if (firstValue !== lastValue) {
                    diff[key] = {
                        from: firstValue || 'undefined',
                        to: lastValue || 'undefined',
                        changed: true
                    };
                } else if (firstValue && lastValue) {
                    // å€¼æ²¡æœ‰å˜åŒ–ï¼Œä½†å­˜åœ¨äºä¸¤ä¸ªçŠ¶æ€ä¸­
                    diff[key] = {
                        from: firstValue,
                        to: lastValue,
                        changed: false
                    };
                }
            });

            return diff;
        }

        // é€’å½’æ”¶é›†æ‰€æœ‰Global StateèŠ‚ç‚¹
        function collectGlobalStateNodes(node, globalStateNodes) {
            if (node && node.message && node.message.text === "Global State") {
                globalStateNodes.push(node);
            }

            if (node && node.childrenList) {
                node.childrenList.forEach(child => {
                    collectGlobalStateNodes(child, globalStateNodes);
                });
            }
        }

        // ä»Global StateèŠ‚ç‚¹ä¸­æå–çŠ¶æ€ä¿¡æ¯
        function extractStateFromGlobalNode(globalStateNode) {
            const state = {};

            if (globalStateNode.childrenList) {
                globalStateNode.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }

            return state;
        }

        // é€’å½’æå–çŠ¶æ€ä¿¡æ¯
        function extractStateRecursively(node, state) {
            // å¦‚æœèŠ‚ç‚¹æœ‰argumentsï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªçŠ¶æ€è®°å½•
            if (node.message && node.message.arguments && node.message.arguments.length > 0) {
                // æ›¿æ¢å ä½ç¬¦å¾—åˆ°å®Œæ•´çš„çŠ¶æ€è·¯å¾„
                let fullPath = node.message.text;
                let stateValue = null;

                node.message.arguments.forEach((arg, index) => {
                    const placeholder = `{${index}}`;
                    if (fullPath.includes(placeholder)) {
                        if (arg.value && arg.value !== '*') {
                            // ä½¿ç”¨æœ€æ˜“è¯»çš„å€¼è¡¨ç¤º
                            let displayValue = arg.value;
                            if (arg.values && arg.values.length > 1) {
                                // å¦‚æœæœ‰åè¿›åˆ¶è¡¨ç¤ºï¼Œä¼˜å…ˆä½¿ç”¨
                                const decValue = arg.values.find(v => !v.startsWith('0x') && v !== arg.value && !isNaN(v));
                                if (decValue && parseInt(decValue) < 1000000) {
                                    displayValue = `${arg.value} (${decValue})`;
                                }
                            }
                            fullPath = fullPath.replace(placeholder, displayValue);

                            // æœ€åä¸€ä¸ªå‚æ•°é€šå¸¸æ˜¯å€¼
                            if (index === node.message.arguments.length - 1) {
                                stateValue = displayValue;
                            }
                        } else {
                            fullPath = fullPath.replace(placeholder, arg.value || 'undefined');
                        }
                    }
                });

                // è§£æè·¯å¾„å’Œå€¼
                const parsed = parseStatePath(fullPath, stateValue);
                if (parsed.path && parsed.value !== null) {
                    state[parsed.path] = parsed.value;
                }
            }

            // é€’å½’å¤„ç†å­èŠ‚ç‚¹
            if (node.childrenList) {
                node.childrenList.forEach(child => {
                    extractStateRecursively(child, state);
                });
            }
        }

        // è§£æçŠ¶æ€è·¯å¾„
        function parseStatePath(fullText, extractedValue) {
            const colonIndex = fullText.indexOf(': ');
            if (colonIndex === -1) {
                return { path: fullText.trim(), value: extractedValue || 'undefined' };
            }

            const path = fullText.substring(0, colonIndex).trim();
            let value = fullText.substring(colonIndex + 2).trim();

            // å¦‚æœæœ‰ä»argumentsä¸­æå–çš„å€¼ï¼Œä¼˜å…ˆä½¿ç”¨
            if (extractedValue && extractedValue !== 'undefined') {
                value = extractedValue;
            }

            // æ¸…ç†å¼•å·
            value = value.replace(/^['"]|['"]$/g, '');

            return { path, value };
        }

        // æ¸²æŸ“Global Stateå·®å¼‚
        function renderGlobalStateDiff(diff) {
            let md = '';

            // æŒ‰è·¯å¾„ç±»å‹åˆ†ç»„
            const groups = {
                'storage': { title: 'Storage Changes', items: [] },
                'balance': { title: 'Balance Changes', items: [] },
                'ghost': { title: 'Ghost Variable Changes', items: [] },
                'other': { title: 'Other Changes', items: [] }
            };

            Object.entries(diff).forEach(([path, change]) => {
                const item = { path, change };

                if (path.includes('storage') || path.includes('balanceOf') || path.includes('_storage')) {
                    groups.storage.items.push(item);
                } else if (path.includes('balance') || path.includes('Balance')) {
                    groups.balance.items.push(item);
                } else if (path.includes('ghost') || path.includes('Ghost')) {
                    groups.ghost.items.push(item);
                } else {
                    groups.other.items.push(item);
                }
            });

            // æ¸²æŸ“å„ç»„
            Object.values(groups).forEach(group => {
                if (group.items.length > 0) {
                    md += `### ${group.title}\n\n`;
                    group.items.forEach(item => {
                        const { path, change } = item;
                        if (change.changed) {
                            md += `- **${path}**: \`${change.from}\` â†’ \`${change.to}\` âœ¨\n`;
                        } else {
                            md += `- **${path}**: \`${change.from}\` (unchanged)\n`;
                        }
                    });
                    md += `\n`;
                }
            });

            return md;
        }

        // ä»variablesæ•°ç»„ä¸­æ¸²æŸ“å±‚æ¬¡ç»“æ„ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function renderVariablesFromArray(variables) {
            let md = '';

            variables.forEach((variable, index) => {
                // åªå¤„ç†æœ‰variableNameå­—æ®µçš„å¯¹è±¡
                if (variable && typeof variable === 'object' && variable.hasOwnProperty('variableName')) {
                    // å¤„ç†æœ‰childrenListçš„å˜é‡
                    if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                        md += renderNestedVariable(variable);
                    } else {
                        // ç®€å•å˜é‡ï¼Œç›´æ¥è¾“å‡ºå˜é‡åå’Œå€¼
                        const name = variable.variableName;
                        const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                        md += `**${name}**: \`${value}\`\n\n`;
                    }
                }
            });

            return md;
        }

        // å¤„ç†åµŒå¥—å˜é‡ - å‚è€ƒé¡¹ç›®ç‰ˆæœ¬
        function renderNestedVariable(variable, parentPath = []) {
            let md = '';
            const currentPath = parentPath.length > 0 ? [...parentPath, variable.variableName] : [variable.variableName];

            // å¦‚æœæœ‰å­å˜é‡ï¼Œé€’å½’å¤„ç†
            if (variable.hasOwnProperty('childrenList') && Array.isArray(variable.childrenList) && variable.childrenList.length > 0) {
                variable.childrenList.forEach(child => {
                    // ç¡®ä¿childæ˜¯æœ‰æ•ˆçš„å¯¹è±¡ä¸”æœ‰variableName
                    if (child && typeof child === 'object' && child.hasOwnProperty('variableName')) {
                        md += renderNestedVariable(child, currentPath);
                    }
                });
            } else {
                // å¶èŠ‚ç‚¹ï¼Œè¾“å‡ºå®Œæ•´è·¯å¾„å’Œå€¼
                const fullPath = currentPath.join('.');
                const value = variable.hasOwnProperty('value') ? variable.value : 'undefined';
                md += `**${fullPath}**: \`${value}\`\n\n`;
            }

            return md;
        }

        // å¯åŠ¨æç¤º
        window.addEventListener('DOMContentLoaded', () => {
            showStatus('è¯·å…ˆè¿è¡ŒæœåŠ¡å™¨: cd /Users/pixelpanda/certora-scraper && node scripts/certora_auto_server.mjs', 'info');
        });

        // ç‚¹å‡»modalå¤–éƒ¨å…³é—­
        // å¤åˆ¶åŠŸèƒ½
        function showCopyNotification(message) {
            // ç§»é™¤ç°æœ‰çš„é€šçŸ¥
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // åˆ›å»ºæ–°é€šçŸ¥
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);

            // 2ç§’åéšè—å¹¶åˆ é™¤
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                // å›é€€æ–¹æ³•
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (err) {
                    document.body.removeChild(textArea);
                    return false;
                }
            }
        }

        function copyMarkdown(index) {
            const rule = processedRules[index];
            if (rule && rule.markdown) {
                copyToClipboard(rule.markdown).then(success => {
                    if (success) {
                        showCopyNotification('âœ… Markdownå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } else {
                        showCopyNotification('âŒ å¤åˆ¶å¤±è´¥');
                    }
                });
            } else {
                showCopyNotification('âŒ æ²¡æœ‰å¯å¤åˆ¶çš„Markdownå†…å®¹');
            }
        }

        function copyCodexAnalysis(outputFile) {
            const textarea = document.getElementById(`analysis-${outputFile}`);
            if (textarea && textarea.value && textarea.value.trim() !== '' && !textarea.value.includes('åˆ†æä¸­...')) {
                copyToClipboard(textarea.value).then(success => {
                    if (success) {
                        showCopyNotification('âœ… Codexåˆ†æå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } else {
                        showCopyNotification('âŒ å¤åˆ¶å¤±è´¥');
                    }
                });
            } else {
                showCopyNotification('âŒ æ²¡æœ‰å¯å¤åˆ¶çš„åˆ†æç»“æœ');
            }
        }

        window.onclick = function (event) {
            const modal1 = document.getElementById('markdown-modal');
            const modal2 = document.getElementById('codex-modal');
            if (event.target == modal1) {
                modal1.style.display = 'none';
            }
            if (event.target == modal2) {
                modal2.style.display = 'none';
            }
        }
    </script>
</body>

</html>